using System.IO;
using System.Numerics;
using System.Text;

namespace JeezFoundation.Algorithm_Generating;

public static class OmnitreeGenerator
{
	public static string Run(int dimensions = Program.DefaultGenerationCount)
	{
		string generatorPath = Path.GetRelativePath(Path.Combine(Path.GetDirectoryName(sourcefilepath())!, "..", ".."), sourcefilepath());

		StringBuilder code = new();
		code.AppendLine($@"//------------------------------------------------------------------------------");
		code.AppendLine($@"// <auto-generated>");
		code.AppendLine($@"// This code was generated from ""{generatorPath}"".");
		code.AppendLine($@"// </auto-generated>");
		code.AppendLine($@"//------------------------------------------------------------------------------");
		code.AppendLine($@"");
		if (dimensions >= 30)
		{
			code.AppendLine($@"using System.Numerics;");
		}
		code.AppendLine($@"using static JeezFoundation.Algorithm.DataStructures.Omnitree;");
		code.AppendLine($@"");
		code.AppendLine($@"namespace JeezFoundation.Algorithm.DataStructures.TEMP;");
		code.AppendLine($@"");

		#region Notes

		code.AppendLine($@"#region Notes");
		code.AppendLine($@"");
		code.AppendLine($@"// Visualizations--------------------------------------------------");
		code.AppendLine($@"//");
		code.AppendLine($@"// 1 Dimensional:");
		code.AppendLine($@"//");
		code.AppendLine($@"//  -1D |-----------|-----------| +1D");
		code.AppendLine($@"//");
		code.AppendLine($@"//       <--- 0 ---> <--- 1 --->");
		code.AppendLine($@"//");
		code.AppendLine($@"// 2 Dimensional:");
		code.AppendLine($@"//       _____________________");
		code.AppendLine($@"//      |          |          |  +2D");
		code.AppendLine($@"//      |          |          |   ^");
		code.AppendLine($@"//      |     2    |     3    |   |");
		code.AppendLine($@"//      |          |          |   |");
		code.AppendLine($@"//      |----------|----------|   |");
		code.AppendLine($@"//      |          |          |   |");
		code.AppendLine($@"//      |          |          |   |");
		code.AppendLine($@"//      |     0    |     1    |   |");
		code.AppendLine($@"//      |          |          |   v");
		code.AppendLine($@"//      |__________|__________|  -2D");
		code.AppendLine($@"//");
		code.AppendLine($@"//       -1D <-----------> +1D ");
		code.AppendLine($@"//");
		code.AppendLine($@"// 3 Dimensional:");
		code.AppendLine($@"//");
		code.AppendLine($@"//            +3D     _____________________");
		code.AppendLine($@"//           7       /         /          /|");
		code.AppendLine($@"//          /       /    6    /     7    / |");
		code.AppendLine($@"//         /       /---------/----------/  |");
		code.AppendLine($@"//        /       /    2    /     3    /|  |");
		code.AppendLine($@"//       L       /_________/__________/ |  |");
		code.AppendLine($@"//    -3D       |          |          | | /|          +2D");
		code.AppendLine($@"//              |          |          | |/ |           ^");
		code.AppendLine($@"//              |     2    |     3    | /  |           |");
		code.AppendLine($@"//              |          |          |/|  | <-- 5     |");
		code.AppendLine($@"//              |----------|----------| |  |           |");
		code.AppendLine($@"//              |          |          | |  /           |");
		code.AppendLine($@"//              |          |          | | /            |");
		code.AppendLine($@"//              |     0    |     1    | |/             |");
		code.AppendLine($@"//              |          |          | /              v");
		code.AppendLine($@"//              |__________|__________|/              -2D");
		code.AppendLine($@"//             ");
		code.AppendLine($@"//                   ^");
		code.AppendLine($@"//                   |");
		code.AppendLine($@"//                   4 (behind 0)");
		code.AppendLine($@"//");
		code.AppendLine($@"//               -1D <-----------> +1D");
		code.AppendLine($@"");
		code.AppendLine($@"#endregion");
		code.AppendLine($@"");

		#endregion

		#region public static partial class Omnitree

		code.AppendLine($@"/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>");
		code.AppendLine($@"public static partial class Omnitree");
		code.AppendLine($@"{{");
		for (int i = 1, I = 2; i <= dimensions; i++, I++)
		{
			code.AppendLine($@"	#region {i} Dimensional");
			code.AppendLine($@"");

			#region public struct Vector<Axis1, Axis2, Axis3...>

			code.AppendLine($@"	/// <summary>Represents a {i}D vector.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""A{j}"">The generic type of the {j} dimension.</typeparam>");
			}
			code.AppendLine($@"	public struct Vector<{Join(1..I, n => $"A{n}", ", ")}>");
			code.AppendLine($@"	{{");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		/// <summary>The value along axis {j}.</summary>");
				code.AppendLine($@"		public A{j} Axis{j};");
			}
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>A location along each axis.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		/// <param name=""axis{j}"">The location along axis {j}.</param>");
			}
			code.AppendLine($@"		public Vector({Join(1..I, n => $"A{n} axis{n}", ", ")})");
			code.AppendLine($@"		{{");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			Axis{j} = axis{j};");
			}
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			if (i > 1)
			{
				code.AppendLine($@"		/// <summary>Converts a tuple to a vector.</summary>");
				code.AppendLine($@"		/// <param name=""tuple"">The tuple to convert to a vector.</param>");
				code.AppendLine($@"		public static implicit operator Vector<{Join(1..I, n => $"A{n}", ", ")}>(({Join(1..I, n => $"A{n} Axis{n}", ", ")}) tuple) =>");
				code.AppendLine($@"			new({Join(1..I, n => $"tuple.Axis{n}", ", ")});");
			}
			else
			{
				code.AppendLine($@"		/// <summary>Converts a tuple to a vector.</summary>");
				code.AppendLine($@"		/// <param name=""axis1"">The 1D cordinate to convert to a vector.</param>");
				code.AppendLine($@"		public static implicit operator Vector<{Join(1..I, n => $"A{n}", ", ")}>(A1 axis1) =>");
				code.AppendLine($@"			new(axis1);");
			}
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			#region public struct Bounds<Axis1, Axis2, Axis3...>

			code.AppendLine($@"	/// <summary>Represents a {i}D bounding box.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
			}
			code.AppendLine($@"	public struct Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>");
			code.AppendLine($@"	{{");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		/// <summary>The minimum value along the {j} dimension.</summary>");
				code.AppendLine($@"		public Bound<Axis{j}> Min{j};");
				code.AppendLine($@"		/// <summary>The maximum value along the {j} dimension.</summary>");
				code.AppendLine($@"		public Bound<Axis{j}> Max{j};");
			}
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>Extends infinitely along each axis.</summary>");
			code.AppendLine($@"		public static Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> None =>");
			code.AppendLine($@"			new Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"				Bound<Axis{j}>.None, Bound<Axis{j}>.None{(j == i ? ");" : ",")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>");
			code.AppendLine($@"		public Bounds(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			Bound<Axis{j}> min{j}, Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"		{{");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			Min{j} = min{j}; Max{j} = max{j};");
			}
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			#region Helper Methods

			code.AppendLine($@"	/// <summary>Checks a node for overlap between two bounds.</summary>");
			code.AppendLine($@"	/// <returns>True if the spaces overlap; False if not.</returns>");
			code.AppendLine($@"	public static bool OverlapCheck<");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>(");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		// Axis {j}");
				code.AppendLine($@"		!(a.Max{j}.Exists && b.Min{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Min{j}.Value) is Less) &&");
				code.AppendLine($@"		!(a.Min{j}.Exists && b.Max{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Max{j}.Value) is Greater){(j == i ? ";" : " &&")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Checks if <paramref name=""a""/> contain <paramref name=""b""/>.</summary>");
			code.AppendLine($@"	/// <param name=""a"">The bounds to check if it contains <paramref name=""b""/>.</param>");
			code.AppendLine($@"	/// <param name=""b"">The vector to check if it is contained in <paramref name=""a""/></param>");
			code.AppendLine($@"	/// <returns>True if <paramref name=""a""/> contains <paramref name=""b""/>; False if not.</returns>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
				code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The method for comparing values along the {j}D axis.</typeparam>");
				code.AppendLine($@"	/// <param name=""compare{j}"">The function for comparing values along the {j}D axis.</param>");
			}
			code.AppendLine($@"	public static bool ContainsCheck<");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>(");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
			code.AppendLine($@"		Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		!(a.Min{j}.Exists && compare{j}.Invoke(b.Axis{j}, a.Min{j}.Value) is Less) &&");
				code.AppendLine($@"		!(a.Max{j}.Exists && compare{j}.Invoke(b.Axis{j}, a.Max{j}.Value) is Greater){(j == i ? ";" : " &&")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Checks if <paramref name=""a""/> contains all of <paramref name=""b""/>.</summary>");
			code.AppendLine($@"	/// <param name=""a"">The bounds to check if it contains all of <paramref name=""b""/>.</param>");
			code.AppendLine($@"	/// <param name=""b"">The bounds to check if it is entirely contained in <paramref name=""a""/></param>");
			code.AppendLine($@"	/// <returns>True if <paramref name=""a""/> contains all of <paramref name=""b""/>; False if not.</returns>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
				code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The method for comparing values along the {j}D axis.</typeparam>");
				code.AppendLine($@"	/// <param name=""compare{j}"">The function for comparing values along the {j}D axis.</param>");
			}
			code.AppendLine($@"	public static bool ContainsCheck<");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>(");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		(a.Min{j}.Exists && !b.Min{j}.Exists) && (a.Max{j}.Exists && !b.Max{j}.Exists) &&");
				code.AppendLine($@"		(b.Min{j}.Exists && a.Min{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Min{j}.Value) is not Less) &&");
				code.AppendLine($@"		(b.Max{j}.Exists && a.Max{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Max{j}.Value) is not Greater){(j == i ? ";" : " &&")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Checks if two vectors are equal.</summary>");
			code.AppendLine($@"	/// <param name=""a"">First vector of the equality check.</param>");
			code.AppendLine($@"	/// <param name=""b"">Second vector of the equality check.</param>");
			code.AppendLine($@"	/// <returns>True if the vectors are equal in value; False if not.</returns>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
				code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The method for comparing elements along the {j} dimension.</typeparam>");
				code.AppendLine($@"	/// <param name=""compare{j}"">The method for comparing elements along the {j} dimension.</param>");
			}
			code.AppendLine($@"	public static bool EqualsCheck<{Join(1..I, n => $"Axis{n}", ", ")}, {Join(1..I, n => $"Compare{n}", ", ")}>(");
			code.AppendLine($@"		Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> a, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b, {Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		compare{j}.Invoke(a.Axis{j}, b.Axis{j}) is Equal{(j == i ? ";" : " &&")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>");
			code.AppendLine($@"	/// <param name=""a"">The bounds to determine if it straddles the extended point.</param>");
			code.AppendLine($@"	/// <param name=""b"">The point representing an extended plan along each axis.</param>");
			code.AppendLine($@"	/// <returns>True if the extended point was straddled or false if not.</returns>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
				code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The method for comparing elements along the {j} dimension.</typeparam>");
				code.AppendLine($@"	/// <param name=""compare{j}"">The method for comparing elements along the {j} dimension.</param>");
			}
			code.AppendLine($@"	public static bool StraddlesLines<");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>(");
			code.AppendLine($@"		Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
			code.AppendLine($@"		Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		(!a.Min{j}.Exists || (a.Min{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Axis{j}) is not Greater)) &&");
				code.AppendLine($@"		(!a.Max{j}.Exists || (a.Max{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Axis{j}) is not Less)){(j == i ? ";" : " ||")}");
			}
			code.AppendLine($@"");

			#endregion

			code.AppendLine($@"	#endregion {i} Dimensional");
			code.AppendLine($@"");
		}
		code.AppendLine($@"}}");
		code.AppendLine($@"");

		#endregion

		for (int i = 1, I = 2; i <= dimensions; i++, I++)
		{
			code.AppendLine($@"#region {i} Dimensional");
			code.AppendLine($@"");

			#region public interface IOmnitree<...>

			code.AppendLine($@"/// <summary>A {i}D SPT data structure.</summary>");
			code.AppendLine($@"/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
			}
			code.AppendLine($@"public interface IOmnitree<T,");
			code.AppendLine($@"	{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Compare{n}", ", ")}>");
			code.AppendLine($@"	: IOmnitree<T>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
			}
			code.AppendLine($@"{{");
			code.AppendLine($@"	#region Properties");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current maximum depth of this tree.</summary>");
			code.AppendLine($@"	public int MaxDepth {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of nodes in this tree.</summary>");
			code.AppendLine($@"	public int NodeCount {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"}}");
			code.AppendLine($@"");

			#endregion

			#region public interface IOmnitreePoints<...>

			code.AppendLine($@"#region OmnitreePoints");
			code.AppendLine($@"");
			code.AppendLine($@"/// <summary>A {i}D SPT data structure.</summary>");
			code.AppendLine($@"/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
			}
			code.AppendLine($@"public interface IOmnitreePoints<T,");
			code.AppendLine($@"	{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Locate{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Compare{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Subdivide{n}", ", ")}>");
			code.AppendLine($@"	: IOmnitree<T,");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Locate{j} : struct, IFunc<T, Axis{j}>");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Subdivide{j} : struct, IFunc<(int Count, int Depth, System.Collections.Generic.IEnumerable<Axis{j}> Values, (Bound<Axis{j}> Min, Bound<Axis{j}> Max) Bounds), Axis{j}>");
			}
			code.AppendLine($@"{{");
			code.AppendLine($@"	#region Properties");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of branches in this tree.</summary>");
			code.AppendLine($@"	public int BranchCount {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of leaves in this tree.</summary>");
			code.AppendLine($@"	public int LeafCount {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");
			code.AppendLine($@"	#region Methods");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Counts the number of values in a sub space of this tree.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate of the space along the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate of the space along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values in the sub space of this tree.</returns>");
			code.AppendLine($@"	int CountSubSpace({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values at the given vector.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values that were removed.</returns>");
			code.AppendLine($@"	int Remove({Join(1..I, n => $"Axis{n} axis{n}", ", ")});");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values at the given space.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values that were removed.</returns>");
			code.AppendLine($@"	int Remove({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values in the given space.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The type of the predicate function to determine removal.</typeparam>");
			code.AppendLine($@"	/// <param name=""where"">The predicate function to determine removal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values that were removed.</returns>");
			code.AppendLine($@"	int Remove<TPredicate>({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")}, TPredicate where = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool>;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values at the given vector.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The type of the predicate function to determine removal.</typeparam>");
			code.AppendLine($@"	/// <param name=""where"">The predicate function to determine removal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values that were removed.</returns>");
			code.AppendLine($@"	int Remove<TPredicate>({Join(1..I, n => $"Axis{n} axis{n}", ", ")}, TPredicate where = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool>;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Performs an action on every value in a space.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TStep"">The type of the step function to perform on every value.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The step function to perform on every value.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The status of the traversal.</returns>");
			code.AppendLine($@"	StepStatus StepperBreak<TStep>({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")}, TStep step = default)");
			code.AppendLine($@"		where TStep : struct, IFunc<T, StepStatus>;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses the tree and ensures each value is in the proper leaf.</summary>");
			code.AppendLine($@"	void Update();");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses a space and ensures each value is in the proper leaf.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	void Update({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"}}");
			code.AppendLine($@"");

			#endregion

			#region public class OmnitreePointsLinked<...>

			code.AppendLine($@"/// <summary>A {i}D SPT data structure.</summary>");
			code.AppendLine($@"/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				code.AppendLine($@"/// <typeparam name=""Subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
			}
			code.AppendLine($@"public class OmnitreePointsLinked<T,");
			code.AppendLine($@"	{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Locate{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Compare{n}", ", ")},");
			code.AppendLine($@"	{Join(1..I, n => $"Subdivide{n}", ", ")}>");
			code.AppendLine($@"	: IOmnitreePoints<T,");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Locate{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Subdivide{n}", ", ")}>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Locate{j} : struct, IFunc<T, Axis{j}>");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	where Subdivide{j} : struct, IFunc<(int Count, int Depth, System.Collections.Generic.IEnumerable<Axis{j}> Values, (Bound<Axis{j}> Min, Bound<Axis{j}> Max) Bounds), Axis{j}>");
			}
			code.AppendLine($@"{{");

			#region Fields

			code.AppendLine($@"	internal {(i < 30 ? "const" : "readonly static")} {(i < 30 ? "int" : "BigInteger")} ChildrenPerNode = {(i < 30 ? $"{Math.Pow(2, i)}" : $"BigInteger.Pow(2, {i})")};");
			code.AppendLine($@"");
			code.AppendLine($@"	internal Node _top;");
			code.AppendLine($@"	internal int _naturalLogLower = 1;");
			code.AppendLine($@"	internal int _naturalLogUpper = 1;");
			code.AppendLine($@"	internal int _load = 1;");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	internal Locate{j} _locate{j};");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	internal Compare{j} _compare{j};");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	internal Subdivide{j} _subdivide{j};");
			}
			code.AppendLine($@"");

			#endregion

			#region Nested Types

			code.AppendLine($@"	#region Nested Types");
			code.AppendLine($@"");

			#region Node

			code.AppendLine($@"	/// <summary>Can be a leaf or a branch.</summary>");
			code.AppendLine($@"	internal abstract class Node");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		internal Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> Bounds;");
			code.AppendLine($@"		internal Branch Parent;");
			code.AppendLine($@"		internal {(i < 30 ? "int" : nameof(BigInteger))} Index;");
			code.AppendLine($@"		internal int Count;");
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>The depth this node is located in the Omnitree.</summary>");
			code.AppendLine($@"		internal int Depth");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int depth = -1;");
			code.AppendLine($@"				for (Node node = this; node is not null; node = node.Parent)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					depth++;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return depth;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>Constructs a node.</summary>");
			code.AppendLine($@"		/// <param name=""bounds"">The bounds of this node.</param>");
			code.AppendLine($@"		/// <param name=""parent"">The parent of this node.</param>");
			code.AppendLine($@"		/// <param name=""index"">The number of elements stored in this node and its children.</param>");
			code.AppendLine($@"		internal Node(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Bounds = bounds;");
			code.AppendLine($@"			Parent = parent;");
			code.AppendLine($@"			Index = index;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Node(Node nodeToClone)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Bounds = nodeToClone.Bounds;");
			code.AppendLine($@"			Parent = nodeToClone.Parent;");
			code.AppendLine($@"			Index = nodeToClone.Index;");
			code.AppendLine($@"			Count = nodeToClone.Count;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal abstract Node Clone();");
			code.AppendLine($@"");
			code.AppendLine($@"		internal abstract int MaxDepth {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal abstract int NodeCount {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal abstract int BranchCount {{ get; }}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal abstract int LeafCount {{ get; }}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			#region Branch

			code.AppendLine($@"	/// <summary>A branch in the tree. Only contains nodes.</summary>");
			code.AppendLine($@"	internal class Branch : Node");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		internal Node[] Children;");
			code.AppendLine($@"		internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> PointOfDivision;");
			code.AppendLine($@"");
			code.AppendLine($@"		/// <summary>Gets child by index.</summary>");
			code.AppendLine($@"		/// <param name=""child_index"">The index of the child to get.</param>");
			code.AppendLine($@"		/// <returns>The child of the given index or null if non-existent.</returns>");
			code.AppendLine($@"		internal Node this[{(i < 30 ? "int" : nameof(BigInteger))} child_index]");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Children is null)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					return null;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				if (Children.Length == ChildrenPerNode)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					return Children[(int)child_index];");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				foreach (Node node in Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (node.Index == child_index)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						return node;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return null;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			set");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				// This error check should be unnecessary... but fuck it... might as well");
			code.AppendLine($@"				if (value.Index != child_index)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					throw new System.Exception(""Bug in Omnitree(index / property mis - match when setting a child on a branch)"");");
			code.AppendLine($@"				}}");
			code.AppendLine($@"");
			code.AppendLine($@"				if (Children is null)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Children = Ɐ(value);");
			code.AppendLine($@"					return;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				else if (Children.Length == ChildrenPerNode)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Children[(int)child_index] = value;");
			code.AppendLine($@"					return;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				for (int i = 0; i < Children.Length; i++)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (Children[i].Index == child_index)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						Children[i] = value;");
			code.AppendLine($@"						return;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				Node[] newArray = new Node[Children.Length + 1];");
			code.AppendLine($@"				if (newArray.Length == ChildrenPerNode)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					for (int i = 0; i < Children.Length; i++)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						newArray[(int)Children[i].Index] = Children[i];");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					newArray[(int)value.Index] = value;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				else");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Array.Copy(Children, newArray, Children.Length);");
			code.AppendLine($@"					newArray[newArray.Length - 1] = value;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				Children = newArray;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Branch(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
			code.AppendLine($@"			: base(bounds, parent, index)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			PointOfDivision = pointOfDivision;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Branch(Branch branchToClone) : base(branchToClone)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Children = branchToClone.Children.Clone() as Node[];");
			code.AppendLine($@"			PointOfDivision = branchToClone.PointOfDivision;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override Node Clone() => new Branch(this);");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int MaxDepth");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int maxDepth = 0;");
			code.AppendLine($@"				foreach (Node node in Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (node is not null)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						maxDepth = Math.Max(maxDepth, node.MaxDepth + 1);");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return maxDepth;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int NodeCount");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int nodeCount = 1;");
			code.AppendLine($@"				foreach (Node node in Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (node is not null)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						nodeCount += node.NodeCount;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return nodeCount;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int BranchCount");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int branchCount = 1;");
			code.AppendLine($@"				foreach (Node node in Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (node is not null)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						branchCount += node.BranchCount;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return branchCount;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int LeafCount");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			get");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int leafCount = 0;");
			code.AppendLine($@"				foreach (Node node in Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (node is not null)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						leafCount += node.LeafCount;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				return leafCount;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			#region Leaf

			code.AppendLine($@"	/// <summary>A branch in the tree. Only contains items.</summary>");
			code.AppendLine($@"	internal class Leaf : Node");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		internal class Node");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			internal T Value;");
			code.AppendLine($@"			internal Leaf.Node Next;");
			code.AppendLine($@"");
			code.AppendLine($@"			internal Node(T value, Leaf.Node next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Value = value;");
			code.AppendLine($@"				Next = next;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Leaf.Node Head;");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
			code.AppendLine($@"			: base(bounds, parent, index) {{ }}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal Leaf(Leaf leaf) : base(leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Head = new Node(leaf.Head.Value, null);");
			code.AppendLine($@"			Node a = Head;");
			code.AppendLine($@"			Node b = leaf.Head;");
			code.AppendLine($@"			while (b is not null)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				a.Next = new Node(b.Next.Value, null);");
			code.AppendLine($@"				a = a.Next;");
			code.AppendLine($@"				b = b.Next;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal void Add(T addition)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Head = new Leaf.Node(addition, Head);");
			code.AppendLine($@"			Count++;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override OmnitreePointsLinked<T, {Join(1..I, n => $"Axis{n}", ", ")}, {Join(1..I, n => $"Locate{n}", ", ")}, {Join(1..I, n => $"Compare{n}", ", ")}, {Join(1..I, n => $"Subdivide{n}", ", ")}>.Node Clone() => new Leaf(this);");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int MaxDepth => 0;");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int NodeCount => 1;");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int BranchCount => 0;");
			code.AppendLine($@"");
			code.AppendLine($@"		internal override int LeafCount => 1;");
			code.AppendLine($@"");
			code.AppendLine($@"		internal System.Collections.Generic.IEnumerable<Axis> GetEnumerable<Axis, Locate>(Locate locate = default)");
			code.AppendLine($@"			where Locate : struct, IFunc<T, Axis>");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			for (Node node = Head; node is not null; node = node.Next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				yield return locate.Invoke(node.Value);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Constructors

			code.AppendLine($@"	#region Constructors");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>This constructor is for cloning purposes.</summary>");
			code.AppendLine($@"	internal OmnitreePointsLinked(");
			code.AppendLine($@"		OmnitreePointsLinked<T,");
			code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"			{Join(1..I, n => $"Locate{n}", ", ")},");
			code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")},");
			code.AppendLine($@"			{Join(1..I, n => $"Subdivide{n}", ", ")}>");
			code.AppendLine($@"		omnitree)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		_top = omnitree._top.Clone();");
			code.AppendLine($@"		_load = omnitree._load;");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		_locate{j} = omnitree._locate{j};");
				code.AppendLine($@"		_compare{j} = omnitree._compare{j};");
				code.AppendLine($@"		_subdivide{j} = omnitree._subdivide{j};");
			}
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"/// <summary>Constructs a new omnitree.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"/// <param name=""locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</param>");
				code.AppendLine($@"/// <param name=""compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</param>");
				code.AppendLine($@"/// <param name=""subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</param>");
			}
			code.AppendLine($@"	public OmnitreePointsLinked(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Locate{j} locate{j} = default,");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Compare{j} compare{j} = default,");
			}
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Subdivide{j} subdivide{j} = default{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		_locate{j} = locate{j};");
				code.AppendLine($@"		_compare{j} = compare{j};");
				code.AppendLine($@"		_subdivide{j} = subdivide{j};");
			}
			code.AppendLine($@"		_top = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Properties

			code.AppendLine($@"	#region Properties");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc/>");
			code.AppendLine($@"	public int Dimensions => {i};");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc/>");
			code.AppendLine($@"	public int Count => _top.Count;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current maximum depth of this tree. Warning! Not an O(1) operation.</summary>");
			code.AppendLine($@"	public int MaxDepth => _top.MaxDepth;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of nodes in this tree. Warning! Not an O(1) operation.</summary>");
			code.AppendLine($@"	public int NodeCount => _top.NodeCount;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of branches in this tree. Warning! Not an O(1) operation.</summary>");
			code.AppendLine($@"	public int BranchCount => _top.BranchCount;");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>The current number of leaves in this tree. Warning! Not an O(1) operation.</summary>");
			code.AppendLine($@"	public int LeafCount => _top.LeafCount;");
			code.AppendLine($@"");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <summary>The function this tree is using to locate <typeparamref name=""T""/>'s along the {i}D axis.</summary>");
				code.AppendLine($@"	public Locate{j} LocateFunction{j} => _locate{j};");
			}
			code.AppendLine($@"");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <summary>The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</summary>");
				code.AppendLine($@"	public Compare{j} CompareFunction{j} => _compare{j};");
			}
			code.AppendLine($@"");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <summary>The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</summary>");
				code.AppendLine($@"	public Subdivide{j} SubdivideFunction{j} => _subdivide{j};");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Steps through all the items at a given coordinate.</summary>");
			code.AppendLine($@"	public System.Collections.Generic.IEnumerable<T> this[{Join(1..I, n => $"Axis{n} axis{n}", ", ")}] => throw new NotImplementedException();");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Methods

			code.AppendLine($@"	#region Methods");
			code.AppendLine($@"");

			#region Add

			code.AppendLine($@"	#region TryAdd");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc />");
			code.AppendLine($@"	public (bool Success, Exception? Exception) TryAdd(T value)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (_top.Count is int.MaxValue)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			return (false, new(""Omnitree.Count is int.MaxValue""));");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> location = FullLocate(value);");
			code.AppendLine($@"		if (_top is Leaf top && top.Count >= _load)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			_top = new Branch(DeterminePointOfDivision(top, 0), Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
			code.AppendLine($@"			for (Leaf.Node list = top.Head; list is not null; list = list.Next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Add(list.Value, _top, FullLocate(list.Value), 0);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		Add(value, _top, location, 0);");
			code.AppendLine($@"		return (true, null);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal void Add(T value, Node node, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> location, int depth)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			if (depth >= _load || leaf.Count < _load)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				leaf.Add(value);");
			code.AppendLine($@"				return;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			else");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Branch parent = node.Parent;");
			code.AppendLine($@"				int child_index = DetermineChildIndex(parent.PointOfDivision, location);");
			code.AppendLine($@"				Branch growth = new(DeterminePointOfDivision(leaf, depth), leaf.Bounds, parent, child_index);");
			code.AppendLine($@"				parent[child_index] = growth;");
			code.AppendLine($@"				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> temp_location = FullLocate(list.Value);");
			code.AppendLine($@"					if (Omnitree.ContainsCheck(growth.Bounds, temp_location, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						Add(list.Value, growth, temp_location, depth);");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					else");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						AdjustParentCounts(parent, 1);");
			code.AppendLine($@"						Add(list.Value, _top, temp_location, 0);");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				Add(value, growth, location, depth);");
			code.AppendLine($@"				return;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Branch branch = node as Branch;");
			code.AppendLine($@"			int child_index = this.DetermineChildIndex(branch.PointOfDivision, location);");
			code.AppendLine($@"			Node child_node = branch[child_index];");
			code.AppendLine($@"			if (child_node is null)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Leaf new_leaf = new(DetermineChildBounds(branch, child_index), branch, child_index);");
			code.AppendLine($@"				branch[child_index] = new_leaf;");
			code.AppendLine($@"				new_leaf.Add(value);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			else");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Add(value, child_node, location, depth + 1);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			branch.Count++;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region DeterminePointOfDivision

			code.AppendLine($@"	#region DeterminePointOfDivision");
			code.AppendLine($@"");
			code.AppendLine($@"	internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> DeterminePointOfDivision(Leaf leaf, int depth) =>");
			code.AppendLine($@"		new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			_subdivide{j}.Invoke((leaf.Count, depth, leaf.GetEnumerable<Axis{j}, Locate{j}>(_locate{j}), (leaf.Bounds.Min{j}, leaf.Bounds.Max{j}))){(j == i ? ");" : ",")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region DetermineChildBounds

			code.AppendLine($@"	#region DetermineChildBounds");
			code.AppendLine($@"");
			code.AppendLine($@"	internal Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> DetermineChildBounds(Branch branch, int child_index)");
			code.AppendLine($@"	{{");
			for (int j = i; j > 0; j--)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, max{j};");
				code.AppendLine($@"		if (child_index >= {(2 << (j - 1)) / 2})");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			min{j} = branch.PointOfDivision.Axis{j};");
				code.AppendLine($@"			max{j} = branch.Bounds.Max{j};");
				code.AppendLine($@"			child_index -= {(2 << (j - 1)) / 2};");
				code.AppendLine($@"		}}");
				code.AppendLine($@"		else");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			min{j} = branch.Bounds.Min{j};");
				code.AppendLine($@"			max{j} = branch.PointOfDivision.Axis{j};");
				code.AppendLine($@"		}}");
			}
			code.AppendLine($@"		return new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ");" : ",")}");
			}
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (predicate)

			code.AppendLine($@"	#region Remove (predicate)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values qualified by the predicate.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
			code.AppendLine($@"	/// <param name=""predicate"">The predicate to qualify removals.</param>");
			code.AppendLine($@"	public int Remove<TPredicate>(TPredicate predicate = default) where TPredicate : struct, IFunc<T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = Remove(_top, predicate);");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal int Remove<TPredicate>(Node node, TPredicate predicate) where TPredicate : struct, IFunc<T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int removals = 0;");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			while (leaf.Head is not null && predicate.Invoke(leaf.Head.Value))");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				leaf.Head = leaf.Head.Next;");
			code.AppendLine($@"				removals++;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			if (leaf.Head is not null)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Leaf.Node list = leaf.Head;");
			code.AppendLine($@"				while (list.Next is not null)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (predicate.Invoke(list.Next.Value))");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						list.Next = list.Next.Next;");
			code.AppendLine($@"						removals++;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			leaf.Count -= removals;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			int skipped = 0;");
			code.AppendLine($@"			for (int i = 0; i + skipped < branch.Children.Length;)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				removals += Remove(branch.Children[i], predicate);");
			code.AppendLine($@"				if (branch.Children[i].Count == 0)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				else");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					i++;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			Node[] newArray = new Node[branch.Children.Length - skipped];");
			code.AppendLine($@"			Array.Copy(branch.Children, newArray, newArray.Length);");
			code.AppendLine($@"			branch.Children = newArray;");
			code.AppendLine($@"			branch.Count -= removals;");
			code.AppendLine($@"			if (branch.Count < _load && branch.Count != 0)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				ShrinkChild(branch.Parent, branch.Index);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return removals;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (vector)

			code.AppendLine($@"	#region Remove (vector)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the values at a given vector.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""axis{j}"">The coordinate along the {j} axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values that were removed.</returns>");
			code.AppendLine($@"	public int Remove({Join(1..I, n => $"Axis{n} axis{n}", ", ")}) =>");
			code.AppendLine($@"		Remove({Join(1..I, n => $"axis{n}, axis{n}", ", ")});");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (space)

			code.AppendLine($@"	#region Remove (space)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
			}
			code.AppendLine($@"	public int Remove(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = Remove(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? "));" : ",")}");
			}
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
			}
			code.AppendLine($@"	public int Remove(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = Remove(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? "));" : ",")}");
			}
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal int Remove(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int removals = 0;");
			code.AppendLine($@"		if (Omnitree.OverlapCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			if (node is Leaf leaf)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Leaf.Node current_node = leaf.Head;");
			code.AppendLine($@"				Leaf.Node previous_node = null;");
			code.AppendLine($@"				while (!(current_node is null))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Leaf.Node temp_previous = current_node;");
			code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, FullLocate(current_node.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						removals++;");
			code.AppendLine($@"						if (current_node == leaf.Head)");
			code.AppendLine($@"						{{");
			code.AppendLine($@"							leaf.Head = leaf.Head.Next;");
			code.AppendLine($@"						}}");
			code.AppendLine($@"						else");
			code.AppendLine($@"						{{");
			code.AppendLine($@"							previous_node.Next = current_node.Next;");
			code.AppendLine($@"							temp_previous = previous_node;");
			code.AppendLine($@"						}}");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					previous_node = temp_previous;");
			code.AppendLine($@"					current_node = current_node.Next;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				leaf.Count -= removals;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			else if (node is Branch branch)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int skipped = 0;");
			code.AppendLine($@"				for (int i = 0; i + skipped < branch.Children.Length;)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					removals += Remove(branch.Children[i], bounds);");
			code.AppendLine($@"					if (branch.Children[i].Count == 0)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					else");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						i++;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				Node[] newArray = new Node[branch.Children.Length - skipped];");
			code.AppendLine($@"				Array.Copy(branch.Children, newArray, newArray.Length);");
			code.AppendLine($@"				branch.Children = newArray;");
			code.AppendLine($@"				branch.Count -= removals;");
			code.AppendLine($@"				if (branch.Count < _load && branch.Count > 0)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					ShrinkChild(branch.Parent, branch.Index);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return removals;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (value)

			code.AppendLine($@"	#region Remove (value)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");

			code.AppendLine($@"	public int Remove<TEquate>(T value, TEquate equate = default)");
			code.AppendLine($@"		where TEquate : struct, IFunc<T, T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		var x = FullLocate(value);");
			code.AppendLine($@"		int count = Remove<PredicateFromEquateAndValue<T, TEquate>>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			x.Axis{j}, x.Axis{j},");
			}
			code.AppendLine($@"			new(value, equate));");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (vector + predicate)

			code.AppendLine($@"	#region Remove (vector + predicate)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
			code.AppendLine($@"	/// <param name=""predicate"">The predicate to qualify removals.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""axis{j}"">The coordinate of the space along the {j} axis.</param>");
			}
			code.AppendLine($@"	public int Remove<TPredicate>({Join(1..I, n => $"Axis{n} axis{n}", ", ")}, TPredicate predicate = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool> =>");
			code.AppendLine($@"		Remove<TPredicate>({Join(1..I, n => $"axis{n}, axis{n}", ", ")}, predicate);");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Remove (space + predicate)

			code.AppendLine($@"	#region Remove (space + predicate)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
			code.AppendLine($@"	/// <param name=""predicate"">The predicate to qualify removals.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
			}
			code.AppendLine($@"	public int Remove<TPredicate>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j},");
			}
			code.AppendLine($@"		TPredicate predicate = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = Remove(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			predicate);");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Removes all the items in a given space.</summary>");
			code.AppendLine($@"	/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
			code.AppendLine($@"	/// <param name=""predicate"">The predicate to qualify removals.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
			}
			code.AppendLine($@"	public int Remove<TPredicate>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
			}
			code.AppendLine($@"			TPredicate predicate = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = Remove(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			predicate);");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal int Remove<TPredicate>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, TPredicate predicate = default)");
			code.AppendLine($@"		where TPredicate : struct, IFunc<T, bool>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int removals = 0;");
			code.AppendLine($@"		if (Omnitree.OverlapCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			if (node is Leaf leaf)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Leaf.Node current_node = leaf.Head;");
			code.AppendLine($@"				Leaf.Node previous_node = null;");
			code.AppendLine($@"				while (!(current_node is null))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Leaf.Node temp_previous = current_node;");
			code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, FullLocate(current_node.Value), {Join(1..I, n => $"_compare{n}", ", ")})  && predicate.Invoke(current_node.Value))");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						removals++;");
			code.AppendLine($@"						if (current_node == leaf.Head)");
			code.AppendLine($@"						{{");
			code.AppendLine($@"							leaf.Head = leaf.Head.Next;");
			code.AppendLine($@"						}}");
			code.AppendLine($@"						else");
			code.AppendLine($@"						{{");
			code.AppendLine($@"							previous_node.Next = current_node.Next;");
			code.AppendLine($@"							temp_previous = previous_node;");
			code.AppendLine($@"						}}");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					previous_node = temp_previous;");
			code.AppendLine($@"					current_node = current_node.Next;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				leaf.Count -= removals;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			else if (node is Branch branch)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int skipped = 0;");
			code.AppendLine($@"				for (int i = 0; i + skipped < branch.Children.Length;)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					removals += Remove(branch.Children[i], bounds, predicate);");
			code.AppendLine($@"					if (branch.Children[i].Count == 0)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
			code.AppendLine($@"					}}");
			code.AppendLine($@"					else");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						i++;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				Node[] newArray = new Node[branch.Children.Length - skipped];");
			code.AppendLine($@"				Array.Copy(branch.Children, newArray, newArray.Length);");
			code.AppendLine($@"				branch.Children = newArray;");
			code.AppendLine($@"				branch.Count -= removals;");
			code.AppendLine($@"				if (branch.Count < _load && branch.Count > 0)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					ShrinkChild(branch.Parent, branch.Index);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return removals;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Clear

			code.AppendLine($@"	#region Clear");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Returns this tree to an empty state.</summary>");
			code.AppendLine($@"	public void Clear()");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		_top = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
			code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Clone

			code.AppendLine($@"	#region Clone");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Returns this tree to an empty state.</summary>");
			code.AppendLine($@"	public OmnitreePointsLinked<T,");
			code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Locate{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")},");
			code.AppendLine($@"		{Join(1..I, n => $"Subdivide{n}", ", ")}>");
			code.AppendLine($@"		Clone() => new(this);");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region CountSubSpace

			code.AppendLine($@"	#region CountSubSpace");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc />");
			code.AppendLine($@"	public int CountSubSpace(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ") =>" : ",")}");
			}
			code.AppendLine($@"		CountSubSpace(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? "));" : ",")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Counts the number of values in a sub space of this tree.</summary>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
			}
			code.AppendLine($@"	/// <returns>The number of values in the sub space of this tree.</returns>");
			code.AppendLine($@"	public int CountSubSpace(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} axis{j}{(j == i ? ") =>" : ",")}");
			}
			code.AppendLine($@"		CountSubSpace(_top, new({Join(1..I, n => $"axis{n}, axis{n}", ", ")}));");
			code.AppendLine($@"");
			code.AppendLine($@"	internal int CountSubSpace(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int count = 0;");
			code.AppendLine($@"		if (Omnitree.ContainsCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			count += node.Count;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					count++;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			if (!Omnitree.StraddlesLines(branch.Bounds, branch.PointOfDivision, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				int child_index = DetermineChildIndex(branch.PointOfDivision, bounds);");
			code.AppendLine($@"				Node child = branch[child_index];");
			code.AppendLine($@"				if (child is not null)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					count += CountSubSpace(child, bounds);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"			else");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				foreach (Node child in branch.Children)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					count += CountSubSpace(child, bounds);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return count;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region DetermineChildIndex

			code.AppendLine($@"	#region DetermineChildIndex");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Computes the child index that contains the desired dimensions.</summary>");
			code.AppendLine($@"	/// <param name=""pointOfDivision"">The point of division to compare against.</param>");
			code.AppendLine($@"	/// <param name=""bounds"">The dimensions to determine the child index.</param>");
			code.AppendLine($@"	/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>");
			code.AppendLine($@"	internal int DetermineChildIndex(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (Omnitree.StraddlesLines(bounds, pointOfDivision, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			return -1;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		int child = 0;");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		if (!bounds.Min{j}.Exists || _compare{j}.Invoke(bounds.Min{j}.Value, pointOfDivision.Axis{j}) is not Less) child += 1 << {j - 1};");
			}
			code.AppendLine($@"		return child;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Computes the child index that contains the desired dimensions.</summary>");
			code.AppendLine($@"	/// <param name=""pointOfDivision"">The point of division to compare against.</param>");
			code.AppendLine($@"	/// <param name=""vector"">The dimensions to determine the child index.</param>");
			code.AppendLine($@"	/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>");
			code.AppendLine($@"	internal int DetermineChildIndex(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> vector)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		int child = 0;");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		if (_compare{j}.Invoke(vector.Axis{j}, pointOfDivision.Axis{j}) is not Less) child += 1 << {j - 1};");
			}
			code.AppendLine($@"		return child;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region ShrinkChild

			code.AppendLine($@"	#region ShrinkChild");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>");
			code.AppendLine($@"	/// <param name=""parent"">The parent to shrink a child of.</param>");
			code.AppendLine($@"	/// <param name=""child_index"">The index of the child to shrink.</param>");
			code.AppendLine($@"	internal void ShrinkChild(Branch parent, int child_index)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		Leaf leaf;");
			code.AppendLine($@"		Node removal = null;");
			code.AppendLine($@"		if (parent is null)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			removal = _top;");
			code.AppendLine($@"			leaf = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
			code.AppendLine($@"			_top = leaf;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			removal = parent[child_index];");
			code.AppendLine($@"			leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);");
			code.AppendLine($@"			parent[child_index] = leaf;");
			code.AppendLine($@"		}}");
#warning TODO: optimize
			code.AppendLine($@"		// TODO: optimize");
			code.AppendLine($@"		Stepper<SAction<T>>(removal, new Action<T>(step => {{ leaf.Add(step); }}));");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region AdjustParentCounts

			code.AppendLine($@"	#region AdjustParentCounts");
			code.AppendLine($@"");
			code.AppendLine($@"	internal void AdjustParentCounts(Node parent, int adjustment)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		for (Node node = parent; node is not null; node = node.Parent)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			node.Count += adjustment;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region GetContainingParent

			code.AppendLine($@"	#region NearestContainingNode");
			code.AppendLine($@"");
			code.AppendLine($@"	internal Node NearestContainingNode(Node node, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> vector)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		while (node is not null && !Omnitree.ContainsCheck(node.Bounds, vector, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			node = node.Parent;");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return node;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region FullLocate

			code.AppendLine($@"	#region FullLocate");
			code.AppendLine($@"");
			code.AppendLine($@"	internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> FullLocate(T value) => new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		_locate{j}.Invoke(value){(j == i ? ");" : ",")}");
			}
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Update

			code.AppendLine($@"	#region Update");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc/>");
			code.AppendLine($@"	public void Update()");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		throw new NotImplementedException();");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Update (space)

			code.AppendLine($@"	#region Update (space)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc/>");
			code.AppendLine($@"	public void Update(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Bound<Axis{j}> min{j}, Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			code.AppendLine($@"		throw new NotImplementedException();");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Stepper

			code.AppendLine($@"	#region Stepper");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			code.AppendLine($@"	public void Stepper<Step>(Step step = default)");
			code.AppendLine($@"		where Step : struct, IAction<T> =>");
			code.AppendLine($@"		Stepper(_top, step);");
			code.AppendLine($@"");
			code.AppendLine($@"	internal void Stepper<Step>(Node node, Step step)");
			code.AppendLine($@"		where Step : struct, IAction<T>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Leaf.Node list = leaf.Head;");
			code.AppendLine($@"			while (list is not null)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				step.Invoke(list.Value);");
			code.AppendLine($@"				list = list.Next;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			foreach (Node child in branch.Children)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				Stepper(child, step);");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region StepperBreak

			code.AppendLine($@"	#region StepperBreak");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			code.AppendLine($@"	public StepStatus StepperBreak(Func<T, StepStatus> step)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (step is null) throw new ArgumentNullException(nameof(step));");
			code.AppendLine($@"		return StepperBreak<SFunc<T, StepStatus>>(step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			code.AppendLine($@"	public StepStatus StepperBreak<Step>(Step step = default)");
			code.AppendLine($@"		where Step : struct, IFunc<T, StepStatus> =>");
			code.AppendLine($@"		StepperBreak(_top, step);");
			code.AppendLine($@"");
			code.AppendLine($@"	internal StepStatus StepperBreak<Step>(Node node, Step step)");
			code.AppendLine($@"		where Step : struct, IFunc<T, StepStatus>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			Leaf.Node list = leaf.Head;");
			code.AppendLine($@"			while (list is not null)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (step.Invoke(list.Value) is Break)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					return Break;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				list = list.Next;");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		else if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			foreach (Node child in branch.Children)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (StepperBreak(child, step) is Break)");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					return Break;");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return Continue;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Stepper (space)

			code.AppendLine($@"	#region Stepper (space)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public void Stepper(Action<T> step,");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (step is null) throw new ArgumentNullException(nameof(step));");
			code.AppendLine($@"		Stepper<SAction<T>>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public void Stepper(Action<T> step,");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
			}
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (step is null) throw new ArgumentNullException(nameof(step));");
			code.AppendLine($@"		Stepper<SAction<T>>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public void Stepper<Step>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j},");
			}
			code.AppendLine($@"		Step step = default)");
			code.AppendLine($@"		where Step : struct, IAction<T>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		Stepper<Step>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public void Stepper<Step>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
			}
			code.AppendLine($@"		Step step = default)");
			code.AppendLine($@"		where Step : struct, IAction<T>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		Stepper<Step>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal void Stepper<Step>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Step step)");
			code.AppendLine($@"		where Step : struct, IAction<T>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					step.Invoke(list.Value);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			foreach (Node child in branch.Children)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Omnitree.ContainsCheck(bounds, child.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Stepper(child, step);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				else if (Omnitree.OverlapCheck(child.Bounds, bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					Stepper(child, bounds, step);");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region StepperBreak (space)

			code.AppendLine($@"	#region StepperBreak (space)");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public StepStatus StepperBreak(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j},");
			}
			code.AppendLine($@"		Func<T, StepStatus> step)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (step is null) throw new ArgumentNullException(nameof(step));");
			code.AppendLine($@"		return StepperBreak<SFunc<T, StepStatus>>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public StepStatus StepperBreak(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
			}
			code.AppendLine($@"		Func<T, StepStatus> step)");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (step is null) throw new ArgumentNullException(nameof(step));");
			code.AppendLine($@"		return StepperBreak<SFunc<T, StepStatus>>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public StepStatus StepperBreak<Step>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		Axis{j} min{j}, Axis{j} max{j},");
			}
			code.AppendLine($@"		Step step = default)");
			code.AppendLine($@"		where Step : struct, IFunc<T, StepStatus>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		return StepperBreak<Step>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <summary>Traverses this tree and performs a step on every value.</summary>");
			code.AppendLine($@"	/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
			code.AppendLine($@"	/// <param name=""step"">The action to perform on every during traversal.</param>");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"	/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
				code.AppendLine($@"	/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
			}
			code.AppendLine($@"	public StepStatus StepperBreak<Step>(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"		JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> min{j}, JeezFoundation.Algorithm.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
			}
			code.AppendLine($@"		Step step = default)");
			code.AppendLine($@"		where Step : struct, IFunc<T, StepStatus>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		return StepperBreak<Step>(_top, new(");
			for (int j = 1; j <= i; j++)
			{
				code.AppendLine($@"			min{j}, max{j}{(j == i ? ")," : ",")}");
			}
			code.AppendLine($@"			step);");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	internal StepStatus StepperBreak<Step>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Step step)");
			code.AppendLine($@"		where Step : struct, IFunc<T, StepStatus>");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		if (node is Leaf leaf)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (step.Invoke(list.Value) is Break)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						return Break;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		if (node is Branch branch)");
			code.AppendLine($@"		{{");
			code.AppendLine($@"			foreach (Node child in branch.Children)");
			code.AppendLine($@"			{{");
			code.AppendLine($@"				if (Omnitree.ContainsCheck(bounds, child.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (StepperBreak(child, step) is Break)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						return Break;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"				else if (Omnitree.OverlapCheck(child.Bounds, bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
			code.AppendLine($@"				{{");
			code.AppendLine($@"					if (StepperBreak(child, bounds, step) is Break)");
			code.AppendLine($@"					{{");
			code.AppendLine($@"						return Break;");
			code.AppendLine($@"					}}");
			code.AppendLine($@"				}}");
			code.AppendLine($@"			}}");
			code.AppendLine($@"		}}");
			code.AppendLine($@"		return Continue;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region Stepper

			// /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
			// /// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
			// /// <param name="axis1">The axis of the removal along the  1D axis.</param>
			// /// <param name="axis2">The axis of the removal along the  2D axis.</param>
			// /// <param name="axis3">The axis of the removal along the  3D axis.</param>
			// public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			// 	Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

			// internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
			// {
			// 	Node current = node;
			// 	while (current is not null)
			// 	{
			// 		if (current is Leaf)
			// 		{
			// 			for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
			// 				if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
			// 					step(leaf_node.Value);
			// 			break;
			// 		}
			// 		else
			// 		{
			// 			Branch branch = current as Branch;
			// 			int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
			// 			current = branch[child_index];
			// 		}
			// 	}
			// }

			// /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
			// /// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
			// /// <param name="axis1">The axis of the removal along the  1D axis.</param>
			// /// <param name="axis2">The axis of the removal along the  2D axis.</param>
			// /// <param name="axis3">The axis of the removal along the  3D axis.</param>
			// public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			// 	Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

			// internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
			// {
			// 	Node current = node;
			// 	while (current is not null)
			// 	{
			// 		if (current is Leaf)
			// 		{
			// 			for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
			// 			{
			// 				StepStatus status = StepStatus.Continue;
			// 				if (EqualsCheck(vector, LocateVector(list.Value)) &&
			// 					(status = step(list.Value)) != StepStatus.Continue)
			// 					return status;
			// 			}
			// 		}
			// 		else
			// 		{
			// 			Branch branch = current as Branch;
			// 			int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
			// 			current = branch[child_index];
			// 		}
			// 	}
			// 	return StepStatus.Continue;
			// }

			// System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

			// public System.Collections.Generic.IEnumerator<T> GetEnumerator()
			// {
			// 	// Note: this can be optimized.
			// 	IList<T> list = new ListLinked<T>();
			// 	Stepper(x => list.Add(x));
			// 	return list.GetEnumerator();
			// }

			// #endregion

			#endregion

			#region GetEnumerator

			code.AppendLine($@"	#region GetEnumerator");
			code.AppendLine($@"");
			code.AppendLine($@"	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc />");
			code.AppendLine($@"	public System.Collections.Generic.IEnumerator<T> GetEnumerator()");
			code.AppendLine($@"	{{");
#warning TODO: optimize
			code.AppendLine($@"		// TODO: optimize");
			code.AppendLine($@"		return ((System.Collections.Generic.IEnumerable<T>)ToArray()).GetEnumerator();");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region ToArray

			code.AppendLine($@"	#region ToArray");
			code.AppendLine($@"");
			code.AppendLine($@"	/// <inheritdoc />");
			code.AppendLine($@"	public T[] ToArray()");
			code.AppendLine($@"	{{");
			code.AppendLine($@"		T[] array = new T[_top.Count];");
			code.AppendLine($@"		int i = 0;");
#warning TODO: optimize
			code.AppendLine($@"		// TODO: optimize");
			code.AppendLine($@"		Stepper<SAction<T>>(new Action<T>(x => array[i++] = x));");
			code.AppendLine($@"		return array;");
			code.AppendLine($@"	}}");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			code.AppendLine($@"}}");

			#endregion

			code.AppendLine($@"");
			code.AppendLine($@"#endregion");
			code.AppendLine($@"");
			code.AppendLine($@"#endregion");
			if (i < dimensions)
			{
				code.AppendLine($@"");
			}
		}
		code.AppendLine($@"");
		return code.ToString();
	}
}
