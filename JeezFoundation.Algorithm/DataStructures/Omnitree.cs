//------------------------------------------------------------------------------
// <auto-generated>
//	This code was generated from the "Omnitree.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable

using System;
using System.Numerics;
using static JeezFoundation.Algorithm.Statics;

namespace JeezFoundation.Algorithm.DataStructures
{
	#region Notes

	// Visualizations--------------------------------------------------
	//
	// 1 Dimensional:
	//
	//  -1D |-----------|-----------| +1D
	//
	//       <--- 0 ---> <--- 1 --->
	//
	// 2 Dimensional:
	//       _____________________
	//      |          |          |  +2D
	//      |          |          |   ^
	//      |     2    |     3    |   |
	//      |          |          |   |
	//      |----------|----------|   |
	//      |          |          |   |
	//      |          |          |   |
	//      |     0    |     1    |   |
	//      |          |          |   v
	//      |__________|__________|  -2D
	//
	//       -1D <-----------> +1D 
	//
	// 3 Dimensional:
	//
	//            +3D     _____________________
	//           7       /         /          /|
	//          /       /    6    /     7    / |
	//         /       /---------/----------/  |
	//        /       /    2    /     3    /|  |
	//       L       /_________/__________/ |  |
	//    -3D       |          |          | | /|          +2D
	//              |          |          | |/ |           ^
	//              |     2    |     3    | /  |           |
	//              |          |          |/|  | <-- 5     |
	//              |----------|----------| |  |           |
	//              |          |          | |  /           |
	//              |          |          | | /            |
	//              |     0    |     1    | |/             |
	//              |          |          | /              v
	//              |__________|__________|/              -2D
	//             
	//                   ^
	//                   |
	//                   4 (behind 0)
	//
	//               -1D <-----------> +1D

	#endregion

	/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>
	public static partial class Omnitree
	{
		#region Spacial Types (Bound, Vector, Bounds), Location/Bounding Delegates, And Dimensional Helper Methods

		#region 1 Dimensional

		/// <summary>Represents a 1D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		public struct Vector<A1
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
				> Default =>
				new Vector<A1
					>(default(A1)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			public Vector(A1 axis1
				)
			{
				this.Axis1 = axis1;
			}
		}

		/// <summary>Represents a 1D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		public struct Bounds<A1
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				> None =>
				new Bounds<A1
					>(Bound<A1>.None, Bound<A1>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
			}
		}

		/// <summary>Delegate for locating an item in 1D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		public delegate void Location<T, A1
			>(T item, out A1 axis1
			);

		/// <summary>Delegate for getting the 1D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		public delegate void GetBounds<T, A1
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			);

		/// <summary>Delegate for getting the 1D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		public delegate void GetBoundings<T, A1
			>(T item, out A1 min1, out A1 max1
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			> ConvertToGetBounds<T, A1
			>(GetBoundings<T, A1
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1) =>
			{
				A1 min1; A1 max1;
				getBoundings(item
					, out min1, out max1
					);
				minBound1 = min1; maxBound1 = max1;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1>(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b,
			Func<Axis1, Axis1, CompareResult> compare1) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1>(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector,
			Func<Axis1, Axis1, CompareResult> compare1) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1>(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b,
			Func<Axis1, Axis1, CompareResult> compare1) =>
			(a.Min1.Exists && !b.Min1.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1>(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b,
			Func<Axis1, Axis1, bool> equate1) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1>(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector,
			Func<Axis1, Axis1, CompareResult> compare1) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1>(this IOmnitreePoints<T, Axis1> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1>(this IOmnitreePoints<T, Axis1> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			omnitree.Locate(removal, out axis1
				);
			omnitree.Remove(
				axis1,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1>(this IOmnitreeBounds<T, Axis1> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1>(this IOmnitreeBounds<T, Axis1> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			omnitree.GetBounds(removal, out min1, out max1
				);
			omnitree.RemoveOverlapped(min1, max1
				, x => equate(x, removal));
		}

		#endregion

		#region 2 Dimensional

		/// <summary>Represents a 2D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		public struct Vector<A1
			, A2
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
				> Default =>
				new Vector<A1
					, A2
					>(default(A1)
					, default(A2)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			public Vector(A1 axis1
				, A2 axis2
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
			}
		}

		/// <summary>Represents a 2D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		public struct Bounds<A1
			, A2
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				> None =>
				new Bounds<A1
					, A2
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
			}
		}

		/// <summary>Delegate for locating an item in 2D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		public delegate void Location<T, A1
			, A2
			>(T item, out A1 axis1
			, out A2 axis2
			);

		/// <summary>Delegate for getting the 2D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			);

		/// <summary>Delegate for getting the 2D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			> ConvertToGetBounds<T, A1
			, A2
			>(GetBoundings<T, A1
			, A2
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2>(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2>(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2>(this IOmnitreePoints<T, Axis1, Axis2> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2>(this IOmnitreePoints<T, Axis1, Axis2> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			omnitree.Locate(removal, out axis1
				, out axis2
				);
			omnitree.Remove(
				axis1,
				axis2,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2>(this IOmnitreeBounds<T, Axis1, Axis2> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2>(this IOmnitreeBounds<T, Axis1, Axis2> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, x => equate(x, removal));
		}

		#endregion

		#region 3 Dimensional

		/// <summary>Represents a 3D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		public struct Vector<A1
			, A2
			, A3
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;
			/// <summary>The value along axis 3.</summary>
			public A3 Axis3;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
, A3
				> Default =>
				new Vector<A1
					, A2
					, A3
					>(default(A1)
					, default(A2)
					, default(A3)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			/// <param name="axis3">The location along axis 3.</param>
			public Vector(A1 axis1
				, A2 axis2
				, A3 axis3
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
				this.Axis3 = axis3;
			}
		}

		/// <summary>Represents a 3D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		public struct Bounds<A1
			, A2
			, A3
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;
			/// <summary>The minimum value along the 3 dimension.</summary>
			public Bound<A3> Min3;
			/// <summary>The maximum value along the 3 dimension.</summary>
			public Bound<A3> Max3;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				, A3
				> None =>
				new Bounds<A1
					, A2
					, A3
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					, Bound<A3>.None, Bound<A3>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				, Bound<A3> min3, Bound<A3> max3
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
				this.Min3 = min3;
				this.Max3 = max3;
			}
		}

		/// <summary>Delegate for locating an item in 3D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		/// <param name="axis3">The location of the item along the 3 dimension.</param>
		public delegate void Location<T, A1
			, A2
			, A3
			>(T item, out A1 axis1
			, out A2 axis2
			, out A3 axis3
			);

		/// <summary>Delegate for getting the 3D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			, A3
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			, out Bound<A3> min3, out Bound<A3> max3
			);

		/// <summary>Delegate for getting the 3D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			, A3
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			, out A3 min3, out A3 max3
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			, A3
			> ConvertToGetBounds<T, A1
			, A2
			, A3
			>(GetBoundings<T, A1
			, A2
			, A3
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2			, out Bound<A3> minBound3, out Bound<A3> maxBound3) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				A3 min3; A3 max3;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					, out min3, out max3
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
				minBound3 = min3; maxBound3 = max3;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) is Less ? false :
			a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) is CompareResult.Less ? false :
			bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			|| (a.Min3.Exists && !b.Min3.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			|| (a.Max3.Exists && !b.Max3.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != CompareResult.Less ? false :
			b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2, Axis3>(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2, Func<Axis3, Axis3, bool> equate3) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			!equate3(a.Axis3, b.Axis3) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="Axis3">The generic type of the 3 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <param name="compare3">The delegate for comparing values along the the 3 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2, Axis3>(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			(!bounds.Min3.Exists || (bounds.Min3.Exists && compare3(bounds.Min3.Value, vector.Axis3) != CompareResult.Greater)) &&
			(!bounds.Max3.Exists || (bounds.Max3.Exists && compare3(bounds.Max3.Value, vector.Axis3) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3>(this IOmnitreePoints<T, Axis1, Axis2, Axis3> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3>(this IOmnitreePoints<T, Axis1, Axis2, Axis3> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			omnitree.Locate(removal, out axis1
				, out axis2
				, out axis3
				);
			omnitree.Remove(
				axis1,
				axis2,
				axis3,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				, out min3, out max3
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, min3, max3
				, x => equate(x, removal));
		}

		#endregion

		#region 4 Dimensional

		/// <summary>Represents a 4D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		public struct Vector<A1
			, A2
			, A3
			, A4
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;
			/// <summary>The value along axis 3.</summary>
			public A3 Axis3;
			/// <summary>The value along axis 4.</summary>
			public A4 Axis4;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
, A3
, A4
				> Default =>
				new Vector<A1
					, A2
					, A3
					, A4
					>(default(A1)
					, default(A2)
					, default(A3)
					, default(A4)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			/// <param name="axis3">The location along axis 3.</param>
			/// <param name="axis4">The location along axis 4.</param>
			public Vector(A1 axis1
				, A2 axis2
				, A3 axis3
				, A4 axis4
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
				this.Axis3 = axis3;
				this.Axis4 = axis4;
			}
		}

		/// <summary>Represents a 4D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		public struct Bounds<A1
			, A2
			, A3
			, A4
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;
			/// <summary>The minimum value along the 3 dimension.</summary>
			public Bound<A3> Min3;
			/// <summary>The maximum value along the 3 dimension.</summary>
			public Bound<A3> Max3;
			/// <summary>The minimum value along the 4 dimension.</summary>
			public Bound<A4> Min4;
			/// <summary>The maximum value along the 4 dimension.</summary>
			public Bound<A4> Max4;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				, A3
				, A4
				> None =>
				new Bounds<A1
					, A2
					, A3
					, A4
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					, Bound<A3>.None, Bound<A3>.None
					, Bound<A4>.None, Bound<A4>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				, Bound<A3> min3, Bound<A3> max3
				, Bound<A4> min4, Bound<A4> max4
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
				this.Min3 = min3;
				this.Max3 = max3;
				this.Min4 = min4;
				this.Max4 = max4;
			}
		}

		/// <summary>Delegate for locating an item in 4D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		/// <param name="axis3">The location of the item along the 3 dimension.</param>
		/// <param name="axis4">The location of the item along the 4 dimension.</param>
		public delegate void Location<T, A1
			, A2
			, A3
			, A4
			>(T item, out A1 axis1
			, out A2 axis2
			, out A3 axis3
			, out A4 axis4
			);

		/// <summary>Delegate for getting the 4D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			, A3
			, A4
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			, out Bound<A3> min3, out Bound<A3> max3
			, out Bound<A4> min4, out Bound<A4> max4
			);

		/// <summary>Delegate for getting the 4D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			, A3
			, A4
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			, out A3 min3, out A3 max3
			, out A4 min4, out A4 max4
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			, A3
			, A4
			> ConvertToGetBounds<T, A1
			, A2
			, A3
			, A4
			>(GetBoundings<T, A1
			, A2
			, A3
			, A4
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2			, out Bound<A3> minBound3, out Bound<A3> maxBound3			, out Bound<A4> minBound4, out Bound<A4> maxBound4) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				A3 min3; A3 max3;
				A4 min4; A4 max4;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					, out min3, out max3
					, out min4, out max4
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
				minBound3 = min3; maxBound3 = max3;
				minBound4 = min4; maxBound4 = max4;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) is Less ? false :
			a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) is Greater ? false :
			a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) is Less ? false :
			a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) is CompareResult.Less ? false :
			bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) is CompareResult.Greater ? false :
			bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) is CompareResult.Less ? false :
			bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			|| (a.Min3.Exists && !b.Min3.Exists)
			|| (a.Min4.Exists && !b.Min4.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			|| (a.Max3.Exists && !b.Max3.Exists)
			|| (a.Max4.Exists && !b.Max4.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != CompareResult.Less ? false :
			b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != CompareResult.Greater ? false :
			b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != CompareResult.Less ? false :
			b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2, Func<Axis3, Axis3, bool> equate3, Func<Axis4, Axis4, bool> equate4) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			!equate3(a.Axis3, b.Axis3) ? false :
			!equate4(a.Axis4, b.Axis4) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="Axis3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="Axis4">The generic type of the 4 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <param name="compare3">The delegate for comparing values along the the 3 dimension.</param>
		/// <param name="compare4">The delegate for comparing values along the the 4 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2, Axis3, Axis4>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			(!bounds.Min3.Exists || (bounds.Min3.Exists && compare3(bounds.Min3.Value, vector.Axis3) != CompareResult.Greater)) &&
			(!bounds.Max3.Exists || (bounds.Max3.Exists && compare3(bounds.Max3.Value, vector.Axis3) != CompareResult.Less)) ? true :
			(!bounds.Min4.Exists || (bounds.Min4.Exists && compare4(bounds.Min4.Value, vector.Axis4) != CompareResult.Greater)) &&
			(!bounds.Max4.Exists || (bounds.Max4.Exists && compare4(bounds.Max4.Value, vector.Axis4) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			omnitree.Locate(removal, out axis1
				, out axis2
				, out axis3
				, out axis4
				);
			omnitree.Remove(
				axis1,
				axis2,
				axis3,
				axis4,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				, out min3, out max3
				, out min4, out max4
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, min3, max3
				, min4, max4
				, x => equate(x, removal));
		}

		#endregion

		#region 5 Dimensional

		/// <summary>Represents a 5D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		public struct Vector<A1
			, A2
			, A3
			, A4
			, A5
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;
			/// <summary>The value along axis 3.</summary>
			public A3 Axis3;
			/// <summary>The value along axis 4.</summary>
			public A4 Axis4;
			/// <summary>The value along axis 5.</summary>
			public A5 Axis5;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
, A3
, A4
, A5
				> Default =>
				new Vector<A1
					, A2
					, A3
					, A4
					, A5
					>(default(A1)
					, default(A2)
					, default(A3)
					, default(A4)
					, default(A5)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			/// <param name="axis3">The location along axis 3.</param>
			/// <param name="axis4">The location along axis 4.</param>
			/// <param name="axis5">The location along axis 5.</param>
			public Vector(A1 axis1
				, A2 axis2
				, A3 axis3
				, A4 axis4
				, A5 axis5
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
				this.Axis3 = axis3;
				this.Axis4 = axis4;
				this.Axis5 = axis5;
			}
		}

		/// <summary>Represents a 5D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		public struct Bounds<A1
			, A2
			, A3
			, A4
			, A5
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;
			/// <summary>The minimum value along the 3 dimension.</summary>
			public Bound<A3> Min3;
			/// <summary>The maximum value along the 3 dimension.</summary>
			public Bound<A3> Max3;
			/// <summary>The minimum value along the 4 dimension.</summary>
			public Bound<A4> Min4;
			/// <summary>The maximum value along the 4 dimension.</summary>
			public Bound<A4> Max4;
			/// <summary>The minimum value along the 5 dimension.</summary>
			public Bound<A5> Min5;
			/// <summary>The maximum value along the 5 dimension.</summary>
			public Bound<A5> Max5;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				, A3
				, A4
				, A5
				> None =>
				new Bounds<A1
					, A2
					, A3
					, A4
					, A5
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					, Bound<A3>.None, Bound<A3>.None
					, Bound<A4>.None, Bound<A4>.None
					, Bound<A5>.None, Bound<A5>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				, Bound<A3> min3, Bound<A3> max3
				, Bound<A4> min4, Bound<A4> max4
				, Bound<A5> min5, Bound<A5> max5
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
				this.Min3 = min3;
				this.Max3 = max3;
				this.Min4 = min4;
				this.Max4 = max4;
				this.Min5 = min5;
				this.Max5 = max5;
			}
		}

		/// <summary>Delegate for locating an item in 5D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		/// <param name="axis3">The location of the item along the 3 dimension.</param>
		/// <param name="axis4">The location of the item along the 4 dimension.</param>
		/// <param name="axis5">The location of the item along the 5 dimension.</param>
		public delegate void Location<T, A1
			, A2
			, A3
			, A4
			, A5
			>(T item, out A1 axis1
			, out A2 axis2
			, out A3 axis3
			, out A4 axis4
			, out A5 axis5
			);

		/// <summary>Delegate for getting the 5D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			, out Bound<A3> min3, out Bound<A3> max3
			, out Bound<A4> min4, out Bound<A4> max4
			, out Bound<A5> min5, out Bound<A5> max5
			);

		/// <summary>Delegate for getting the 5D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			, out A3 min3, out A3 max3
			, out A4 min4, out A4 max4
			, out A5 min5, out A5 max5
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			> ConvertToGetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			>(GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2			, out Bound<A3> minBound3, out Bound<A3> maxBound3			, out Bound<A4> minBound4, out Bound<A4> maxBound4			, out Bound<A5> minBound5, out Bound<A5> maxBound5) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				A3 min3; A3 max3;
				A4 min4; A4 max4;
				A5 min5; A5 max5;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					, out min3, out max3
					, out min4, out max4
					, out min5, out max5
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
				minBound3 = min3; maxBound3 = max3;
				minBound4 = min4; maxBound4 = max4;
				minBound5 = min5; maxBound5 = max5;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) is Less ? false :
			a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) is Greater ? false :
			a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) is Less ? false :
			a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) is Greater ? false :
			a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) is Less ? false :
			a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) is CompareResult.Less ? false :
			bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) is CompareResult.Greater ? false :
			bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) is CompareResult.Less ? false :
			bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) is CompareResult.Greater ? false :
			bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) is CompareResult.Less ? false :
			bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			|| (a.Min3.Exists && !b.Min3.Exists)
			|| (a.Min4.Exists && !b.Min4.Exists)
			|| (a.Min5.Exists && !b.Min5.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			|| (a.Max3.Exists && !b.Max3.Exists)
			|| (a.Max4.Exists && !b.Max4.Exists)
			|| (a.Max5.Exists && !b.Max5.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != CompareResult.Less ? false :
			b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != CompareResult.Greater ? false :
			b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != CompareResult.Less ? false :
			b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != CompareResult.Greater ? false :
			b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != CompareResult.Less ? false :
			b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2, Func<Axis3, Axis3, bool> equate3, Func<Axis4, Axis4, bool> equate4, Func<Axis5, Axis5, bool> equate5) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			!equate3(a.Axis3, b.Axis3) ? false :
			!equate4(a.Axis4, b.Axis4) ? false :
			!equate5(a.Axis5, b.Axis5) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="Axis3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="Axis4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="Axis5">The generic type of the 5 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <param name="compare3">The delegate for comparing values along the the 3 dimension.</param>
		/// <param name="compare4">The delegate for comparing values along the the 4 dimension.</param>
		/// <param name="compare5">The delegate for comparing values along the the 5 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2, Axis3, Axis4, Axis5>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			(!bounds.Min3.Exists || (bounds.Min3.Exists && compare3(bounds.Min3.Value, vector.Axis3) != CompareResult.Greater)) &&
			(!bounds.Max3.Exists || (bounds.Max3.Exists && compare3(bounds.Max3.Value, vector.Axis3) != CompareResult.Less)) ? true :
			(!bounds.Min4.Exists || (bounds.Min4.Exists && compare4(bounds.Min4.Value, vector.Axis4) != CompareResult.Greater)) &&
			(!bounds.Max4.Exists || (bounds.Max4.Exists && compare4(bounds.Max4.Value, vector.Axis4) != CompareResult.Less)) ? true :
			(!bounds.Min5.Exists || (bounds.Min5.Exists && compare5(bounds.Min5.Value, vector.Axis5) != CompareResult.Greater)) &&
			(!bounds.Max5.Exists || (bounds.Max5.Exists && compare5(bounds.Max5.Value, vector.Axis5) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			omnitree.Locate(removal, out axis1
				, out axis2
				, out axis3
				, out axis4
				, out axis5
				);
			omnitree.Remove(
				axis1,
				axis2,
				axis3,
				axis4,
				axis5,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				, out min3, out max3
				, out min4, out max4
				, out min5, out max5
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, min3, max3
				, min4, max4
				, min5, max5
				, x => equate(x, removal));
		}

		#endregion

		#region 6 Dimensional

		/// <summary>Represents a 6D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		public struct Vector<A1
			, A2
			, A3
			, A4
			, A5
			, A6
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;
			/// <summary>The value along axis 3.</summary>
			public A3 Axis3;
			/// <summary>The value along axis 4.</summary>
			public A4 Axis4;
			/// <summary>The value along axis 5.</summary>
			public A5 Axis5;
			/// <summary>The value along axis 6.</summary>
			public A6 Axis6;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
, A3
, A4
, A5
, A6
				> Default =>
				new Vector<A1
					, A2
					, A3
					, A4
					, A5
					, A6
					>(default(A1)
					, default(A2)
					, default(A3)
					, default(A4)
					, default(A5)
					, default(A6)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			/// <param name="axis3">The location along axis 3.</param>
			/// <param name="axis4">The location along axis 4.</param>
			/// <param name="axis5">The location along axis 5.</param>
			/// <param name="axis6">The location along axis 6.</param>
			public Vector(A1 axis1
				, A2 axis2
				, A3 axis3
				, A4 axis4
				, A5 axis5
				, A6 axis6
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
				this.Axis3 = axis3;
				this.Axis4 = axis4;
				this.Axis5 = axis5;
				this.Axis6 = axis6;
			}
		}

		/// <summary>Represents a 6D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		public struct Bounds<A1
			, A2
			, A3
			, A4
			, A5
			, A6
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;
			/// <summary>The minimum value along the 3 dimension.</summary>
			public Bound<A3> Min3;
			/// <summary>The maximum value along the 3 dimension.</summary>
			public Bound<A3> Max3;
			/// <summary>The minimum value along the 4 dimension.</summary>
			public Bound<A4> Min4;
			/// <summary>The maximum value along the 4 dimension.</summary>
			public Bound<A4> Max4;
			/// <summary>The minimum value along the 5 dimension.</summary>
			public Bound<A5> Min5;
			/// <summary>The maximum value along the 5 dimension.</summary>
			public Bound<A5> Max5;
			/// <summary>The minimum value along the 6 dimension.</summary>
			public Bound<A6> Min6;
			/// <summary>The maximum value along the 6 dimension.</summary>
			public Bound<A6> Max6;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				, A3
				, A4
				, A5
				, A6
				> None =>
				new Bounds<A1
					, A2
					, A3
					, A4
					, A5
					, A6
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					, Bound<A3>.None, Bound<A3>.None
					, Bound<A4>.None, Bound<A4>.None
					, Bound<A5>.None, Bound<A5>.None
					, Bound<A6>.None, Bound<A6>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				, Bound<A3> min3, Bound<A3> max3
				, Bound<A4> min4, Bound<A4> max4
				, Bound<A5> min5, Bound<A5> max5
				, Bound<A6> min6, Bound<A6> max6
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
				this.Min3 = min3;
				this.Max3 = max3;
				this.Min4 = min4;
				this.Max4 = max4;
				this.Min5 = min5;
				this.Max5 = max5;
				this.Min6 = min6;
				this.Max6 = max6;
			}
		}

		/// <summary>Delegate for locating an item in 6D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		/// <param name="axis3">The location of the item along the 3 dimension.</param>
		/// <param name="axis4">The location of the item along the 4 dimension.</param>
		/// <param name="axis5">The location of the item along the 5 dimension.</param>
		/// <param name="axis6">The location of the item along the 6 dimension.</param>
		public delegate void Location<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			>(T item, out A1 axis1
			, out A2 axis2
			, out A3 axis3
			, out A4 axis4
			, out A5 axis5
			, out A6 axis6
			);

		/// <summary>Delegate for getting the 6D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		/// <param name="min6">The minimum bound of the item along the 6 dimension.</param>
		/// <param name="max6">The maximum bound of the item along the 6 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			, out Bound<A3> min3, out Bound<A3> max3
			, out Bound<A4> min4, out Bound<A4> max4
			, out Bound<A5> min5, out Bound<A5> max5
			, out Bound<A6> min6, out Bound<A6> max6
			);

		/// <summary>Delegate for getting the 6D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		/// <param name="min6">The minimum bound of the item along the 6 dimension.</param>
		/// <param name="max6">The maximum bound of the item along the 6 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			, out A3 min3, out A3 max3
			, out A4 min4, out A4 max4
			, out A5 min5, out A5 max5
			, out A6 min6, out A6 max6
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			> ConvertToGetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			>(GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2			, out Bound<A3> minBound3, out Bound<A3> maxBound3			, out Bound<A4> minBound4, out Bound<A4> maxBound4			, out Bound<A5> minBound5, out Bound<A5> maxBound5			, out Bound<A6> minBound6, out Bound<A6> maxBound6) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				A3 min3; A3 max3;
				A4 min4; A4 max4;
				A5 min5; A5 max5;
				A6 min6; A6 max6;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					, out min3, out max3
					, out min4, out max4
					, out min5, out max5
					, out min6, out max6
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
				minBound3 = min3; maxBound3 = max3;
				minBound4 = min4; maxBound4 = max4;
				minBound5 = min5; maxBound5 = max5;
				minBound6 = min6; maxBound6 = max6;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) is Less ? false :
			a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) is Greater ? false :
			a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) is Less ? false :
			a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) is Greater ? false :
			a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) is Less ? false :
			a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) is Greater ? false :
			a.Max6.Exists && b.Min6.Exists && compare6(a.Max6.Value, b.Min6.Value) is Less ? false :
			a.Min6.Exists && b.Max6.Exists && compare6(a.Min6.Value, b.Max6.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) is CompareResult.Less ? false :
			bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) is CompareResult.Greater ? false :
			bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) is CompareResult.Less ? false :
			bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) is CompareResult.Greater ? false :
			bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) is CompareResult.Less ? false :
			bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) is CompareResult.Greater ? false :
			bounds.Min6.Exists && compare6(vector.Axis6, bounds.Min6.Value) is CompareResult.Less ? false :
			bounds.Max6.Exists && compare6(vector.Axis6, bounds.Max6.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			|| (a.Min3.Exists && !b.Min3.Exists)
			|| (a.Min4.Exists && !b.Min4.Exists)
			|| (a.Min5.Exists && !b.Min5.Exists)
			|| (a.Min6.Exists && !b.Min6.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			|| (a.Max3.Exists && !b.Max3.Exists)
			|| (a.Max4.Exists && !b.Max4.Exists)
			|| (a.Max5.Exists && !b.Max5.Exists)
			|| (a.Max6.Exists && !b.Max6.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != CompareResult.Less ? false :
			b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != CompareResult.Greater ? false :
			b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != CompareResult.Less ? false :
			b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != CompareResult.Greater ? false :
			b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != CompareResult.Less ? false :
			b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != CompareResult.Greater ? false :
			b.Min6.Exists && a.Min6.Exists && compare6(a.Min6.Value, b.Min6.Value) != CompareResult.Less ? false :
			b.Max6.Exists && a.Max6.Exists && compare6(a.Max6.Value, b.Max6.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2, Func<Axis3, Axis3, bool> equate3, Func<Axis4, Axis4, bool> equate4, Func<Axis5, Axis5, bool> equate5, Func<Axis6, Axis6, bool> equate6) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			!equate3(a.Axis3, b.Axis3) ? false :
			!equate4(a.Axis4, b.Axis4) ? false :
			!equate5(a.Axis5, b.Axis5) ? false :
			!equate6(a.Axis6, b.Axis6) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="Axis3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="Axis4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="Axis5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="Axis6">The generic type of the 6 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <param name="compare3">The delegate for comparing values along the the 3 dimension.</param>
		/// <param name="compare4">The delegate for comparing values along the the 4 dimension.</param>
		/// <param name="compare5">The delegate for comparing values along the the 5 dimension.</param>
		/// <param name="compare6">The delegate for comparing values along the the 6 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			(!bounds.Min3.Exists || (bounds.Min3.Exists && compare3(bounds.Min3.Value, vector.Axis3) != CompareResult.Greater)) &&
			(!bounds.Max3.Exists || (bounds.Max3.Exists && compare3(bounds.Max3.Value, vector.Axis3) != CompareResult.Less)) ? true :
			(!bounds.Min4.Exists || (bounds.Min4.Exists && compare4(bounds.Min4.Value, vector.Axis4) != CompareResult.Greater)) &&
			(!bounds.Max4.Exists || (bounds.Max4.Exists && compare4(bounds.Max4.Value, vector.Axis4) != CompareResult.Less)) ? true :
			(!bounds.Min5.Exists || (bounds.Min5.Exists && compare5(bounds.Min5.Value, vector.Axis5) != CompareResult.Greater)) &&
			(!bounds.Max5.Exists || (bounds.Max5.Exists && compare5(bounds.Max5.Value, vector.Axis5) != CompareResult.Less)) ? true :
			(!bounds.Min6.Exists || (bounds.Min6.Exists && compare6(bounds.Min6.Value, vector.Axis6) != CompareResult.Greater)) &&
			(!bounds.Max6.Exists || (bounds.Max6.Exists && compare6(bounds.Max6.Value, vector.Axis6) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			Axis6 axis6;
			omnitree.Locate(removal, out axis1
				, out axis2
				, out axis3
				, out axis4
				, out axis5
				, out axis6
				);
			omnitree.Remove(
				axis1,
				axis2,
				axis3,
				axis4,
				axis5,
				axis6,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				, out min3, out max3
				, out min4, out max4
				, out min5, out max5
				, out min6, out max6
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, min3, max3
				, min4, max4
				, min5, max5
				, min6, max6
				, x => equate(x, removal));
		}

		#endregion

		#region 7 Dimensional

		/// <summary>Represents a 7D vector.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		public struct Vector<A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			>
		{
			/// <summary>The value along axis 1.</summary>
			public A1 Axis1;
			/// <summary>The value along axis 2.</summary>
			public A2 Axis2;
			/// <summary>The value along axis 3.</summary>
			public A3 Axis3;
			/// <summary>The value along axis 4.</summary>
			public A4 Axis4;
			/// <summary>The value along axis 5.</summary>
			public A5 Axis5;
			/// <summary>The value along axis 6.</summary>
			public A6 Axis6;
			/// <summary>The value along axis 7.</summary>
			public A7 Axis7;

			/// <summary>Returns a vector with defaulted values.</summary>
			public static Vector<A1
, A2
, A3
, A4
, A5
, A6
, A7
				> Default =>
				new Vector<A1
					, A2
					, A3
					, A4
					, A5
					, A6
					, A7
					>(default(A1)
					, default(A2)
					, default(A3)
					, default(A4)
					, default(A5)
					, default(A6)
					, default(A7)
					);

			/// <summary>A location along each axis.</summary>
			/// <param name="axis1">The location along axis 1.</param>
			/// <param name="axis2">The location along axis 2.</param>
			/// <param name="axis3">The location along axis 3.</param>
			/// <param name="axis4">The location along axis 4.</param>
			/// <param name="axis5">The location along axis 5.</param>
			/// <param name="axis6">The location along axis 6.</param>
			/// <param name="axis7">The location along axis 7.</param>
			public Vector(A1 axis1
				, A2 axis2
				, A3 axis3
				, A4 axis4
				, A5 axis5
				, A6 axis6
				, A7 axis7
				)
			{
				this.Axis1 = axis1;
				this.Axis2 = axis2;
				this.Axis3 = axis3;
				this.Axis4 = axis4;
				this.Axis5 = axis5;
				this.Axis6 = axis6;
				this.Axis7 = axis7;
			}
		}

		/// <summary>Represents a 7D bounding box.</summary>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		public struct Bounds<A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
>
		{
			/// <summary>The minimum value along the 1 dimension.</summary>
			public Bound<A1> Min1;
			/// <summary>The maximum value along the 1 dimension.</summary>
			public Bound<A1> Max1;
			/// <summary>The minimum value along the 2 dimension.</summary>
			public Bound<A2> Min2;
			/// <summary>The maximum value along the 2 dimension.</summary>
			public Bound<A2> Max2;
			/// <summary>The minimum value along the 3 dimension.</summary>
			public Bound<A3> Min3;
			/// <summary>The maximum value along the 3 dimension.</summary>
			public Bound<A3> Max3;
			/// <summary>The minimum value along the 4 dimension.</summary>
			public Bound<A4> Min4;
			/// <summary>The maximum value along the 4 dimension.</summary>
			public Bound<A4> Max4;
			/// <summary>The minimum value along the 5 dimension.</summary>
			public Bound<A5> Min5;
			/// <summary>The maximum value along the 5 dimension.</summary>
			public Bound<A5> Max5;
			/// <summary>The minimum value along the 6 dimension.</summary>
			public Bound<A6> Min6;
			/// <summary>The maximum value along the 6 dimension.</summary>
			public Bound<A6> Max6;
			/// <summary>The minimum value along the 7 dimension.</summary>
			public Bound<A7> Min7;
			/// <summary>The maximum value along the 7 dimension.</summary>
			public Bound<A7> Max7;

			/// <summary>Extends infinitely along each axis.</summary>
			public static Bounds<A1
				, A2
				, A3
				, A4
				, A5
				, A6
				, A7
				> None =>
				new Bounds<A1
					, A2
					, A3
					, A4
					, A5
					, A6
					, A7
					>(Bound<A1>.None, Bound<A1>.None
					, Bound<A2>.None, Bound<A2>.None
					, Bound<A3>.None, Bound<A3>.None
					, Bound<A4>.None, Bound<A4>.None
					, Bound<A5>.None, Bound<A5>.None
					, Bound<A6>.None, Bound<A6>.None
					, Bound<A7>.None, Bound<A7>.None
					);
			
			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
			public Bounds(
				Bound<A1> min1, Bound<A1> max1
				, Bound<A2> min2, Bound<A2> max2
				, Bound<A3> min3, Bound<A3> max3
				, Bound<A4> min4, Bound<A4> max4
				, Bound<A5> min5, Bound<A5> max5
				, Bound<A6> min6, Bound<A6> max6
				, Bound<A7> min7, Bound<A7> max7
				)
			{
				this.Min1 = min1;
				this.Max1 = max1;
				this.Min2 = min2;
				this.Max2 = max2;
				this.Min3 = min3;
				this.Max3 = max3;
				this.Min4 = min4;
				this.Max4 = max4;
				this.Min5 = min5;
				this.Max5 = max5;
				this.Min6 = min6;
				this.Max6 = max6;
				this.Min7 = min7;
				this.Max7 = max7;
			}
		}

		/// <summary>Delegate for locating an item in 7D space.</summary>
		/// <typeparam name="T">The generic type of the item to locate.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		/// <param name="item">The item to locate.</param>
		/// <param name="axis1">The location of the item along the 1 dimension.</param>
		/// <param name="axis2">The location of the item along the 2 dimension.</param>
		/// <param name="axis3">The location of the item along the 3 dimension.</param>
		/// <param name="axis4">The location of the item along the 4 dimension.</param>
		/// <param name="axis5">The location of the item along the 5 dimension.</param>
		/// <param name="axis6">The location of the item along the 6 dimension.</param>
		/// <param name="axis7">The location of the item along the 7 dimension.</param>
		public delegate void Location<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			>(T item, out A1 axis1
			, out A2 axis2
			, out A3 axis3
			, out A4 axis4
			, out A5 axis5
			, out A6 axis6
			, out A7 axis7
			);

		/// <summary>Delegate for getting the 7D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		/// <param name="min6">The minimum bound of the item along the 6 dimension.</param>
		/// <param name="max6">The maximum bound of the item along the 6 dimension.</param>
		/// <param name="min7">The minimum bound of the item along the 7 dimension.</param>
		/// <param name="max7">The maximum bound of the item along the 7 dimension.</param>
		public delegate void GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			>(T item, out Bound<A1> min1, out Bound<A1> max1
			, out Bound<A2> min2, out Bound<A2> max2
			, out Bound<A3> min3, out Bound<A3> max3
			, out Bound<A4> min4, out Bound<A4> max4
			, out Bound<A5> min5, out Bound<A5> max5
			, out Bound<A6> min6, out Bound<A6> max6
			, out Bound<A7> min7, out Bound<A7> max7
			);

		/// <summary>Delegate for getting the 7D bounding box of an item.</summary>
		/// <typeparam name="T">The generic type of the item to get the bounding box of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		/// <param name="item">The item to get the bounding box of.</param>
		/// <param name="min1">The minimum bound of the item along the 1 dimension.</param>
		/// <param name="max1">The maximum bound of the item along the 1 dimension.</param>
		/// <param name="min2">The minimum bound of the item along the 2 dimension.</param>
		/// <param name="max2">The maximum bound of the item along the 2 dimension.</param>
		/// <param name="min3">The minimum bound of the item along the 3 dimension.</param>
		/// <param name="max3">The maximum bound of the item along the 3 dimension.</param>
		/// <param name="min4">The minimum bound of the item along the 4 dimension.</param>
		/// <param name="max4">The maximum bound of the item along the 4 dimension.</param>
		/// <param name="min5">The minimum bound of the item along the 5 dimension.</param>
		/// <param name="max5">The maximum bound of the item along the 5 dimension.</param>
		/// <param name="min6">The minimum bound of the item along the 6 dimension.</param>
		/// <param name="max6">The maximum bound of the item along the 6 dimension.</param>
		/// <param name="min7">The minimum bound of the item along the 7 dimension.</param>
		/// <param name="max7">The maximum bound of the item along the 7 dimension.</param>
		public delegate void GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			>(T item, out A1 min1, out A1 max1
			, out A2 min2, out A2 max2
			, out A3 min3, out A3 max3
			, out A4 min4, out A4 max4
			, out A5 min5, out A5 max5
			, out A6 min6, out A6 max6
			, out A7 min7, out A7 max7
			);

		/// <summary>Converts an Omnitree.GetBoundings delegate into an Omnitree.GetBounds delegate.</summary>
		/// <typeparam name="T">The generic type to get the bounds of.</typeparam>
		/// <typeparam name="A1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="A2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="A3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="A4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="A5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="A6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="A7">The generic type of the 7 dimension.</typeparam>
		/// <param name="getBoundings">The Omnitree.GetBoundings to convert into a Omnitree.GetBounds.</param>
		/// <returns>The converted Omnitree.GetBounds delegate.</returns>
		public static GetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			> ConvertToGetBounds<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			>(GetBoundings<T, A1
			, A2
			, A3
			, A4
			, A5
			, A6
			, A7
			> getBoundings) =>
			(T item
			, out Bound<A1> minBound1, out Bound<A1> maxBound1			, out Bound<A2> minBound2, out Bound<A2> maxBound2			, out Bound<A3> minBound3, out Bound<A3> maxBound3			, out Bound<A4> minBound4, out Bound<A4> maxBound4			, out Bound<A5> minBound5, out Bound<A5> maxBound5			, out Bound<A6> minBound6, out Bound<A6> maxBound6			, out Bound<A7> minBound7, out Bound<A7> maxBound7) =>
			{
				A1 min1; A1 max1;
				A2 min2; A2 max2;
				A3 min3; A3 max3;
				A4 min4; A4 max4;
				A5 min5; A5 max5;
				A6 min6; A6 max6;
				A7 min7; A7 max7;
				getBoundings(item
					, out min1, out max1
					, out min2, out max2
					, out min3, out max3
					, out min4, out max4
					, out min5, out max5
					, out min6, out max6
					, out min7, out max7
					);
				minBound1 = min1; maxBound1 = max1;
				minBound2 = min2; maxBound2 = max2;
				minBound3 = min3; maxBound3 = max3;
				minBound4 = min4; maxBound4 = max4;
				minBound5 = min5; maxBound5 = max5;
				minBound6 = min6; maxBound6 = max6;
				minBound7 = min7; maxBound7 = max7;
			};

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		public static bool InclusionCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6, Func<Axis7, Axis7, CompareResult> compare7) =>
			a.Max1.Exists && b.Min1.Exists && compare1(a.Max1.Value, b.Min1.Value) is Less ? false :
			a.Min1.Exists && b.Max1.Exists && compare1(a.Min1.Value, b.Max1.Value) is Greater ? false :
			a.Max2.Exists && b.Min2.Exists && compare2(a.Max2.Value, b.Min2.Value) is Less ? false :
			a.Min2.Exists && b.Max2.Exists && compare2(a.Min2.Value, b.Max2.Value) is Greater ? false :
			a.Max3.Exists && b.Min3.Exists && compare3(a.Max3.Value, b.Min3.Value) is Less ? false :
			a.Min3.Exists && b.Max3.Exists && compare3(a.Min3.Value, b.Max3.Value) is Greater ? false :
			a.Max4.Exists && b.Min4.Exists && compare4(a.Max4.Value, b.Min4.Value) is Less ? false :
			a.Min4.Exists && b.Max4.Exists && compare4(a.Min4.Value, b.Max4.Value) is Greater ? false :
			a.Max5.Exists && b.Min5.Exists && compare5(a.Max5.Value, b.Min5.Value) is Less ? false :
			a.Min5.Exists && b.Max5.Exists && compare5(a.Min5.Value, b.Max5.Value) is Greater ? false :
			a.Max6.Exists && b.Min6.Exists && compare6(a.Max6.Value, b.Min6.Value) is Less ? false :
			a.Min6.Exists && b.Max6.Exists && compare6(a.Min6.Value, b.Max6.Value) is Greater ? false :
			a.Max7.Exists && b.Min7.Exists && compare7(a.Max7.Value, b.Min7.Value) is Less ? false :
			a.Min7.Exists && b.Max7.Exists && compare7(a.Min7.Value, b.Max7.Value) is Greater ? false :
			true;

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6, Func<Axis7, Axis7, CompareResult> compare7) =>
			// if the location is not outside the bounds, it must be inside
			bounds.Min1.Exists && compare1(vector.Axis1, bounds.Min1.Value) is CompareResult.Less ? false :
			bounds.Max1.Exists && compare1(vector.Axis1, bounds.Max1.Value) is CompareResult.Greater ? false :
			bounds.Min2.Exists && compare2(vector.Axis2, bounds.Min2.Value) is CompareResult.Less ? false :
			bounds.Max2.Exists && compare2(vector.Axis2, bounds.Max2.Value) is CompareResult.Greater ? false :
			bounds.Min3.Exists && compare3(vector.Axis3, bounds.Min3.Value) is CompareResult.Less ? false :
			bounds.Max3.Exists && compare3(vector.Axis3, bounds.Max3.Value) is CompareResult.Greater ? false :
			bounds.Min4.Exists && compare4(vector.Axis4, bounds.Min4.Value) is CompareResult.Less ? false :
			bounds.Max4.Exists && compare4(vector.Axis4, bounds.Max4.Value) is CompareResult.Greater ? false :
			bounds.Min5.Exists && compare5(vector.Axis5, bounds.Min5.Value) is CompareResult.Less ? false :
			bounds.Max5.Exists && compare5(vector.Axis5, bounds.Max5.Value) is CompareResult.Greater ? false :
			bounds.Min6.Exists && compare6(vector.Axis6, bounds.Min6.Value) is CompareResult.Less ? false :
			bounds.Max6.Exists && compare6(vector.Axis6, bounds.Max6.Value) is CompareResult.Greater ? false :
			bounds.Min7.Exists && compare7(vector.Axis7, bounds.Min7.Value) is CompareResult.Less ? false :
			bounds.Max7.Exists && compare7(vector.Axis7, bounds.Max7.Value) is CompareResult.Greater ? false :
			true;

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		public static bool EncapsulationCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6, Func<Axis7, Axis7, CompareResult> compare7) =>
			(a.Min1.Exists && !b.Min1.Exists)
			|| (a.Min2.Exists && !b.Min2.Exists)
			|| (a.Min3.Exists && !b.Min3.Exists)
			|| (a.Min4.Exists && !b.Min4.Exists)
			|| (a.Min5.Exists && !b.Min5.Exists)
			|| (a.Min6.Exists && !b.Min6.Exists)
			|| (a.Min7.Exists && !b.Min7.Exists)
			? false :
			(a.Max1.Exists && !b.Max1.Exists)
			|| (a.Max2.Exists && !b.Max2.Exists)
			|| (a.Max3.Exists && !b.Max3.Exists)
			|| (a.Max4.Exists && !b.Max4.Exists)
			|| (a.Max5.Exists && !b.Max5.Exists)
			|| (a.Max6.Exists && !b.Max6.Exists)
			|| (a.Max7.Exists && !b.Max7.Exists)
			? false :
			b.Min1.Exists && a.Min1.Exists && compare1(a.Min1.Value, b.Min1.Value) != CompareResult.Less ? false :
			b.Max1.Exists && a.Max1.Exists && compare1(a.Max1.Value, b.Max1.Value) != CompareResult.Greater ? false :
			b.Min2.Exists && a.Min2.Exists && compare2(a.Min2.Value, b.Min2.Value) != CompareResult.Less ? false :
			b.Max2.Exists && a.Max2.Exists && compare2(a.Max2.Value, b.Max2.Value) != CompareResult.Greater ? false :
			b.Min3.Exists && a.Min3.Exists && compare3(a.Min3.Value, b.Min3.Value) != CompareResult.Less ? false :
			b.Max3.Exists && a.Max3.Exists && compare3(a.Max3.Value, b.Max3.Value) != CompareResult.Greater ? false :
			b.Min4.Exists && a.Min4.Exists && compare4(a.Min4.Value, b.Min4.Value) != CompareResult.Less ? false :
			b.Max4.Exists && a.Max4.Exists && compare4(a.Max4.Value, b.Max4.Value) != CompareResult.Greater ? false :
			b.Min5.Exists && a.Min5.Exists && compare5(a.Min5.Value, b.Min5.Value) != CompareResult.Less ? false :
			b.Max5.Exists && a.Max5.Exists && compare5(a.Max5.Value, b.Max5.Value) != CompareResult.Greater ? false :
			b.Min6.Exists && a.Min6.Exists && compare6(a.Min6.Value, b.Min6.Value) != CompareResult.Less ? false :
			b.Max6.Exists && a.Max6.Exists && compare6(a.Max6.Value, b.Max6.Value) != CompareResult.Greater ? false :
			b.Min7.Exists && a.Min7.Exists && compare7(a.Min7.Value, b.Min7.Value) != CompareResult.Less ? false :
			b.Max7.Exists && a.Max7.Exists && compare7(a.Max7.Value, b.Max7.Value) != CompareResult.Greater ? false :
			true;

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		public static bool EqualsCheck<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b,
			Func<Axis1, Axis1, bool> equate1, Func<Axis2, Axis2, bool> equate2, Func<Axis3, Axis3, bool> equate3, Func<Axis4, Axis4, bool> equate4, Func<Axis5, Axis5, bool> equate5, Func<Axis6, Axis6, bool> equate6, Func<Axis7, Axis7, bool> equate7) =>
			!equate1(a.Axis1, b.Axis1) ? false :
			!equate2(a.Axis2, b.Axis2) ? false :
			!equate3(a.Axis3, b.Axis3) ? false :
			!equate4(a.Axis4, b.Axis4) ? false :
			!equate5(a.Axis5, b.Axis5) ? false :
			!equate6(a.Axis6, b.Axis6) ? false :
			!equate7(a.Axis7, b.Axis7) ? false :
			true;

		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>
		/// <typeparam name="Axis1">The generic type of the 1 dimension.</typeparam>
		/// <typeparam name="Axis2">The generic type of the 2 dimension.</typeparam>
		/// <typeparam name="Axis3">The generic type of the 3 dimension.</typeparam>
		/// <typeparam name="Axis4">The generic type of the 4 dimension.</typeparam>
		/// <typeparam name="Axis5">The generic type of the 5 dimension.</typeparam>
		/// <typeparam name="Axis6">The generic type of the 6 dimension.</typeparam>
		/// <typeparam name="Axis7">The generic type of the 7 dimension.</typeparam>
		/// <param name="bounds">The bounds to determine if it straddles the extended point.</param>
		/// <param name="vector">The point representing an extended plan along each axis.</param>
		/// <param name="compare1">The delegate for comparing values along the the 1 dimension.</param>
		/// <param name="compare2">The delegate for comparing values along the the 2 dimension.</param>
		/// <param name="compare3">The delegate for comparing values along the the 3 dimension.</param>
		/// <param name="compare4">The delegate for comparing values along the the 4 dimension.</param>
		/// <param name="compare5">The delegate for comparing values along the the 5 dimension.</param>
		/// <param name="compare6">The delegate for comparing values along the the 6 dimension.</param>
		/// <param name="compare7">The delegate for comparing values along the the 7 dimension.</param>
		/// <returns>True if the extended point was straddled or false if not.</returns>
		public static bool StraddlesLines<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector,
			Func<Axis1, Axis1, CompareResult> compare1, Func<Axis2, Axis2, CompareResult> compare2, Func<Axis3, Axis3, CompareResult> compare3, Func<Axis4, Axis4, CompareResult> compare4, Func<Axis5, Axis5, CompareResult> compare5, Func<Axis6, Axis6, CompareResult> compare6, Func<Axis7, Axis7, CompareResult> compare7) =>
			(!bounds.Min1.Exists || (bounds.Min1.Exists && compare1(bounds.Min1.Value, vector.Axis1) != CompareResult.Greater)) &&
			(!bounds.Max1.Exists || (bounds.Max1.Exists && compare1(bounds.Max1.Value, vector.Axis1) != CompareResult.Less)) ? true :
			(!bounds.Min2.Exists || (bounds.Min2.Exists && compare2(bounds.Min2.Value, vector.Axis2) != CompareResult.Greater)) &&
			(!bounds.Max2.Exists || (bounds.Max2.Exists && compare2(bounds.Max2.Value, vector.Axis2) != CompareResult.Less)) ? true :
			(!bounds.Min3.Exists || (bounds.Min3.Exists && compare3(bounds.Min3.Value, vector.Axis3) != CompareResult.Greater)) &&
			(!bounds.Max3.Exists || (bounds.Max3.Exists && compare3(bounds.Max3.Value, vector.Axis3) != CompareResult.Less)) ? true :
			(!bounds.Min4.Exists || (bounds.Min4.Exists && compare4(bounds.Min4.Value, vector.Axis4) != CompareResult.Greater)) &&
			(!bounds.Max4.Exists || (bounds.Max4.Exists && compare4(bounds.Max4.Value, vector.Axis4) != CompareResult.Less)) ? true :
			(!bounds.Min5.Exists || (bounds.Min5.Exists && compare5(bounds.Min5.Value, vector.Axis5) != CompareResult.Greater)) &&
			(!bounds.Max5.Exists || (bounds.Max5.Exists && compare5(bounds.Max5.Value, vector.Axis5) != CompareResult.Less)) ? true :
			(!bounds.Min6.Exists || (bounds.Min6.Exists && compare6(bounds.Min6.Value, vector.Axis6) != CompareResult.Greater)) &&
			(!bounds.Max6.Exists || (bounds.Max6.Exists && compare6(bounds.Max6.Value, vector.Axis6) != CompareResult.Less)) ? true :
			(!bounds.Min7.Exists || (bounds.Min7.Exists && compare7(bounds.Min7.Value, vector.Axis7) != CompareResult.Greater)) &&
			(!bounds.Max7.Exists || (bounds.Max7.Exists && compare7(bounds.Max7.Value, vector.Axis7) != CompareResult.Less)) ? true :
			false;

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <typeparam name="Axis7">The geneic type of the 7D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);
		
		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <typeparam name="Axis7">The geneic type of the 7D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree, T removal, Func<T, T, bool> equate)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			Axis6 axis6;
			Axis7 axis7;
			omnitree.Locate(removal, out axis1
				, out axis2
				, out axis3
				, out axis4
				, out axis5
				, out axis6
				, out axis7
				);
			omnitree.Remove(
				axis1,
				axis2,
				axis3,
				axis4,
				axis5,
				axis6,
				axis7,
				x => equate(x, removal));
		}

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <typeparam name="Axis7">The geneic type of the 7D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree, T removal) => Remove(omnitree, removal, Statics.Equate);

		/// <summary>Removes all occurences of a value from the omnitree.</summary>
		/// <typeparam name="T">The generic value type being stored in the omnitree.</typeparam>
		/// <typeparam name="Axis1">The geneic type of the 1D axis.</typeparam>
		/// <typeparam name="Axis2">The geneic type of the 2D axis.</typeparam>
		/// <typeparam name="Axis3">The geneic type of the 3D axis.</typeparam>
		/// <typeparam name="Axis4">The geneic type of the 4D axis.</typeparam>
		/// <typeparam name="Axis5">The geneic type of the 5D axis.</typeparam>
		/// <typeparam name="Axis6">The geneic type of the 6D axis.</typeparam>
		/// <typeparam name="Axis7">The geneic type of the 7D axis.</typeparam>
		/// <param name="omnitree">The omnitree to remove from.</param>
		/// <param name="removal">The value to have all occurences removed.</param>
		/// <param name="equate">The delegate for checking for equality.</param>
		public static void Remove<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree,T removal, Func<T, T, bool> equate)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
			omnitree.GetBounds(removal, out min1, out max1
				, out min2, out max2
				, out min3, out max3
				, out min4, out max4
				, out min5, out max5
				, out min6, out max6
				, out min7, out max7
				);
			omnitree.RemoveOverlapped(min1, max1
				, min2, max2
				, min3, max3
				, min4, max4
				, min5, max5
				, min6, max6
				, min7, max7
				, x => equate(x, removal));
		}

		#endregion

		#endregion
	}

	#region Omnitree

	#region 1 Dimensional

	/// <summary>Inheritance base for 1D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	public interface IOmnitree<T, Axis1> : IOmnitree<T> { }

	#endregion

	#region 2 Dimensional

	/// <summary>Inheritance base for 2D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2> : IOmnitree<T> { }

	#endregion

	#region 3 Dimensional

	/// <summary>Inheritance base for 3D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2, Axis3> : IOmnitree<T> { }

	#endregion

	#region 4 Dimensional

	/// <summary>Inheritance base for 4D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2, Axis3, Axis4> : IOmnitree<T> { }

	#endregion

	#region 5 Dimensional

	/// <summary>Inheritance base for 5D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitree<T> { }

	#endregion

	#region 6 Dimensional

	/// <summary>Inheritance base for 6D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitree<T> { }

	#endregion

	#region 7 Dimensional

	/// <summary>Inheritance base for 7D omnitrees.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	/// <typeparam name="Axis7">The type 7D axis.</typeparam>
	public interface IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitree<T> { }

	#endregion

	#endregion
	
	#region OmnitreePoints

	#region 1 Dimensional

	/// <summary>Inheritance base for 1D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1> : IOmnitree<T, Axis1>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 1D space.</summary>
		Omnitree.Location<T, Axis1
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		void Remove(Axis1 axis1);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1);

		#endregion
	}

	/// <summary>Omnitree that stores points along 1 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1> : IOmnitreePoints<T, Axis1>
	{
		internal const int _dimensions = 1;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 1);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> _subdivisionOverride1;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 1D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 1D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				subdivisionOverride1
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1] =>
			step => Stepper(step, axis1);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			return new Omnitree.Vector<Axis1>(
				division1
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1>(min1, max1);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1>(bounds.Min1.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Update(Axis1 min1, Axis1 max1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		public void Update(Axis1 axis1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1>(axis1), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1>(axis1));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1>(axis1));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Vector<Axis1> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1> LocateVector(T value)
		{
			Axis1 axis1;
			this._locate(value, out axis1
);
			return new Omnitree.Vector<Axis1>(axis1);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 2 Dimensional

	/// <summary>Inheritance base for 2D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2> : IOmnitree<T, Axis1, Axis2>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 2D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2);

		#endregion
	}

	/// <summary>Omnitree that stores points along 2 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2> : IOmnitreePoints<T, Axis1, Axis2>
	{
		internal const int _dimensions = 2;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 2);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride2;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 2D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 2D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2] =>
			step => Stepper(step, axis1, axis2);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2>(
				division1
		
				, division2
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2>(bounds.Min1.Value
						, bounds.Min2.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1
				, axis2
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2>(axis1, axis2));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Vector<Axis1, Axis2> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			this._locate(value, out axis1
, out axis2
);
			return new Omnitree.Vector<Axis1, Axis2>(axis1, axis2);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 3 Dimensional

	/// <summary>Inheritance base for 3D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2, Axis3> : IOmnitree<T, Axis1, Axis2, Axis3>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 3D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);

		#endregion
	}

	/// <summary>Omnitree that stores points along 3 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3> : IOmnitreePoints<T, Axis1, Axis2, Axis3>
	{
		internal const int _dimensions = 3;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 3);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride3;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2, Axis3> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 3D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 3D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				compare3 is null ? true : false,
				compare3 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
,
				subdivisionOverride3
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <param name="axis3">The coordinate along axis 3.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3] =>
			step => Stepper(step, axis1, axis2, axis3);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2, Axis3> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 { get { return this._compare3; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2, Axis3> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					, out _
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			Axis3 division3;
			if (!(_subdivisionOverride3 is null))
			{
				division3 = _subdivisionOverride3(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis3[] values = new Axis3[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out values[i]
					);
				if (_defaultCompare3) Array.Sort(values);
				else SortQuick<Axis3>(values, this._compare3);
				int index = (leaf.Count - 1) / 2;
				division3 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2, Axis3>(
				division1
		
				, division2
		
				, division3
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = branch.PointOfDivision.Axis3;
				max3 = branch.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = branch.Bounds.Min3;
				max3 = branch.PointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2, Axis3> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3>(bounds.Min1.Value
						, bounds.Min2.Value
						, bounds.Min3.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1
				, axis2
				, axis3
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			this._locate(value, out axis1
, out axis2
, out axis3
);
			return new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 4 Dimensional

	/// <summary>Inheritance base for 4D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 4D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);

		#endregion
	}

	/// <summary>Omnitree that stores points along 4 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4>
	{
		internal const int _dimensions = 4;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 4);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride4;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 4D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 4D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				compare3 is null ? true : false,
				compare3 ?? Compare,
				compare4 is null ? true : false,
				compare4 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
,
				subdivisionOverride3
,
				subdivisionOverride4
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <param name="axis3">The coordinate along axis 3.</param>
		/// <param name="axis4">The coordinate along axis 4.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4] =>
			step => Stepper(step, axis1, axis2, axis3, axis4);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 { get { return this._compare3; } }
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 { get { return this._compare4; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					, out _
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					, out _
					, out _
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			Axis3 division3;
			if (!(_subdivisionOverride3 is null))
			{
				division3 = _subdivisionOverride3(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis3[] values = new Axis3[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out values[i]
					, out _
					);
				if (_defaultCompare3) Array.Sort(values);
				else SortQuick<Axis3>(values, this._compare3);
				int index = (leaf.Count - 1) / 2;
				division3 = values[index];
			}

			Axis4 division4;
			if (!(_subdivisionOverride4 is null))
			{
				division4 = _subdivisionOverride4(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis4[] values = new Axis4[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out values[i]
					);
				if (_defaultCompare4) Array.Sort(values);
				else SortQuick<Axis4>(values, this._compare4);
				int index = (leaf.Count - 1) / 2;
				division4 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(
				division1
		
				, division2
		
				, division3
		
				, division4
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = branch.PointOfDivision.Axis4;
				max4 = branch.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = branch.Bounds.Min4;
				max4 = branch.PointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = branch.PointOfDivision.Axis3;
				max3 = branch.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = branch.Bounds.Min3;
				max3 = branch.PointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(bounds.Min1.Value
						, bounds.Min2.Value
						, bounds.Min3.Value
						, bounds.Min4.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1
				, axis2
				, axis3
				, axis4
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			this._locate(value, out axis1
, out axis2
, out axis3
, out axis4
);
			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(axis1, axis2, axis3, axis4);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 5 Dimensional

	/// <summary>Inheritance base for 5D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 5D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);

		#endregion
	}

	/// <summary>Omnitree that stores points along 5 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5>
	{
		internal const int _dimensions = 5;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 5);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride5;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 5D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 5D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				compare3 is null ? true : false,
				compare3 ?? Compare,
				compare4 is null ? true : false,
				compare4 ?? Compare,
				compare5 is null ? true : false,
				compare5 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
,
				subdivisionOverride3
,
				subdivisionOverride4
,
				subdivisionOverride5
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <param name="axis3">The coordinate along axis 3.</param>
		/// <param name="axis4">The coordinate along axis 4.</param>
		/// <param name="axis5">The coordinate along axis 5.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5] =>
			step => Stepper(step, axis1, axis2, axis3, axis4, axis5);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 { get { return this._compare3; } }
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 { get { return this._compare4; } }
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 { get { return this._compare5; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			Axis3 division3;
			if (!(_subdivisionOverride3 is null))
			{
				division3 = _subdivisionOverride3(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis3[] values = new Axis3[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					);
				if (_defaultCompare3) Array.Sort(values);
				else SortQuick<Axis3>(values, this._compare3);
				int index = (leaf.Count - 1) / 2;
				division3 = values[index];
			}

			Axis4 division4;
			if (!(_subdivisionOverride4 is null))
			{
				division4 = _subdivisionOverride4(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis4[] values = new Axis4[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					);
				if (_defaultCompare4) Array.Sort(values);
				else SortQuick<Axis4>(values, this._compare4);
				int index = (leaf.Count - 1) / 2;
				division4 = values[index];
			}

			Axis5 division5;
			if (!(_subdivisionOverride5 is null))
			{
				division5 = _subdivisionOverride5(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis5[] values = new Axis5[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					);
				if (_defaultCompare5) Array.Sort(values);
				else SortQuick<Axis5>(values, this._compare5);
				int index = (leaf.Count - 1) / 2;
				division5 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(
				division1
		
				, division2
		
				, division3
		
				, division4
		
				, division5
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = branch.PointOfDivision.Axis5;
				max5 = branch.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = branch.Bounds.Min5;
				max5 = branch.PointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = branch.PointOfDivision.Axis4;
				max4 = branch.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = branch.Bounds.Min4;
				max4 = branch.PointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = branch.PointOfDivision.Axis3;
				max3 = branch.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = branch.Bounds.Min3;
				max3 = branch.PointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(bounds.Min1.Value
						, bounds.Min2.Value
						, bounds.Min3.Value
						, bounds.Min4.Value
						, bounds.Min5.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1
				, axis2
				, axis3
				, axis4
				, axis5
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			this._locate(value, out axis1
, out axis2
, out axis3
, out axis4
, out axis5
);
			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis2, axis3, axis4, axis5);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 6 Dimensional

	/// <summary>Inheritance base for 6D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 6D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);

		#endregion
	}

	/// <summary>Omnitree that stores points along 6 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
	{
		internal const int _dimensions = 6;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 6);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal bool _defaultCompare6;
		internal Func<Axis6, Axis6, CompareResult> _compare6;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride5;
		internal Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride6;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._defaultCompare6 = omnitree._defaultCompare6;
			this._compare6 = omnitree._compare6;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
			this._subdivisionOverride6 = omnitree._subdivisionOverride6;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			bool defaultCompare6,
			Func<Axis6, Axis6, CompareResult> compare6,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}

			if (compare6 is null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._defaultCompare6 = defaultCompare6;
			this._compare6 = compare6;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._subdivisionOverride6 = subdivisionOverride6;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 6D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 6D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5 = null
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				compare3 is null ? true : false,
				compare3 ?? Compare,
				compare4 is null ? true : false,
				compare4 ?? Compare,
				compare5 is null ? true : false,
				compare5 ?? Compare,
				compare6 is null ? true : false,
				compare6 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
,
				subdivisionOverride3
,
				subdivisionOverride4
,
				subdivisionOverride5
,
				subdivisionOverride6
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <param name="axis3">The coordinate along axis 3.</param>
		/// <param name="axis4">The coordinate along axis 4.</param>
		/// <param name="axis5">The coordinate along axis 5.</param>
		/// <param name="axis6">The coordinate along axis 6.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6] =>
			step => Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 { get { return this._compare3; } }
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 { get { return this._compare4; } }
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 { get { return this._compare5; } }
		/// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
		public Func<Axis6, Axis6, CompareResult> Compare6 { get { return this._compare6; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			Axis3 division3;
			if (!(_subdivisionOverride3 is null))
			{
				division3 = _subdivisionOverride3(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis3[] values = new Axis3[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					);
				if (_defaultCompare3) Array.Sort(values);
				else SortQuick<Axis3>(values, this._compare3);
				int index = (leaf.Count - 1) / 2;
				division3 = values[index];
			}

			Axis4 division4;
			if (!(_subdivisionOverride4 is null))
			{
				division4 = _subdivisionOverride4(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis4[] values = new Axis4[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					);
				if (_defaultCompare4) Array.Sort(values);
				else SortQuick<Axis4>(values, this._compare4);
				int index = (leaf.Count - 1) / 2;
				division4 = values[index];
			}

			Axis5 division5;
			if (!(_subdivisionOverride5 is null))
			{
				division5 = _subdivisionOverride5(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis5[] values = new Axis5[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					);
				if (_defaultCompare5) Array.Sort(values);
				else SortQuick<Axis5>(values, this._compare5);
				int index = (leaf.Count - 1) / 2;
				division5 = values[index];
			}

			Axis6 division6;
			if (!(_subdivisionOverride6 is null))
			{
				division6 = _subdivisionOverride6(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis6[] values = new Axis6[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					);
				if (_defaultCompare6) Array.Sort(values);
				else SortQuick<Axis6>(values, this._compare6);
				int index = (leaf.Count - 1) / 2;
				division6 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
				division1
		
				, division2
		
				, division3
		
				, division4
		
				, division5
		
				, division6
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis6> min6, max6;
			if (child_index >= 32)
			{
				min6 = branch.PointOfDivision.Axis6;
				max6 = branch.Bounds.Max6;
				child_index -= 32;
			}
			else
			{
				min6 = branch.Bounds.Min6;
				max6 = branch.PointOfDivision.Axis6;
			}

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = branch.PointOfDivision.Axis5;
				max5 = branch.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = branch.Bounds.Min5;
				max5 = branch.PointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = branch.PointOfDivision.Axis4;
				max4 = branch.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = branch.Bounds.Min4;
				max4 = branch.PointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = branch.PointOfDivision.Axis3;
				max3 = branch.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = branch.Bounds.Min3;
				max3 = branch.PointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(bounds.Min1.Value
						, bounds.Min2.Value
						, bounds.Min3.Value
						, bounds.Min4.Value
						, bounds.Min5.Value
						, bounds.Min6.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			, Axis6 axis6
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1
				, axis2
				, axis3
				, axis4
				, axis5
				, axis6
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				, _compare6
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) is Less))
				child += 1 << 5;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			, (a, b) => _compare6(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			Axis6 axis6;
			this._locate(value, out axis1
, out axis2
, out axis3
, out axis4
, out axis5
, out axis6
);
			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis2, axis3, axis4, axis5, axis6);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 7 Dimensional

	/// <summary>Inheritance base for 7D omnitrees that store points.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	/// <typeparam name="Axis7">The type 7D axis.</typeparam>
	public interface IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
	{
		#region Properties

		/// <summary>Steps through the values at a given location.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>

		/// <returns>A Stepper of the items at the given coordinates.</returns>
		Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7] { get; }

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to locate items in 7D space.</summary>
		Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			, Axis7
			> Locate { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);

		#endregion
	}

	/// <summary>Omnitree that stores points along 7 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	/// <typeparam name="Axis7">The type 7D axis.</typeparam>
	public class OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitreePoints<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
	{
		internal const int _dimensions = 7;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 7);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.Location<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			, Axis7
			> _locate;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal bool _defaultCompare6;
		internal Func<Axis6, Axis6, CompareResult> _compare6;
		internal bool _defaultCompare7;
		internal Func<Axis7, Axis7, CompareResult> _compare7;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride5;
		internal Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride6;
		internal Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride7;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal abstract class Node
		{
			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Bounds;
			internal Branch Parent;
			internal int Index;
			internal int Count;

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;
			}

			internal abstract Node Clone();
		}

		/// <summary>A branch in the tree. Only contains nodes.</summary>
		internal class Branch : Node
		{
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (this.Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					this.Children = newArray;
				}
			}

			internal Branch(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{
				this.PointOfDivision = pointOfDivision;
			}

			internal Branch(Branch branchToClone) : base(branchToClone)
			{
				Children = branchToClone.Children.Clone() as Node[];
				PointOfDivision = branchToClone.PointOfDivision;
			}

			internal override Node Clone() =>
				new Branch(this);
		}

		/// <summary>A branch in the tree. Only contains items.</summary>
		internal class Leaf : Node
		{
			internal class Node
			{
				internal T Value;
				internal Leaf.Node Next;

				internal Node(T value, Leaf.Node next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Leaf.Node Head;

			internal Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Branch parent, int index)
				: base(bounds, parent, index)
			{ }

			internal Leaf(Leaf leaf) : base(leaf)
			{
				Head = new Node(leaf.Head.Value, null);
				Node a = Head;
				Node b = leaf.Head;
				while (b is not null)
				{
					a.Next = new Node(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new Leaf.Node(addition, Head);
				this.Count++;
			}

			internal override OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.Node Clone() =>
				new Leaf(this);
		}

		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreePointsLinked(OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._locate = omnitree._locate;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._defaultCompare6 = omnitree._defaultCompare6;
			this._compare6 = omnitree._compare6;
			this._defaultCompare7 = omnitree._defaultCompare7;
			this._compare7 = omnitree._compare7;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
			this._subdivisionOverride6 = omnitree._subdivisionOverride6;
			this._subdivisionOverride7 = omnitree._subdivisionOverride7;
		}

		internal OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			bool defaultCompare6,
			Func<Axis6, Axis6, CompareResult> compare6,
			bool defaultCompare7,
			Func<Axis7, Axis7, CompareResult> compare7,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6
,
			Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7
			)
		{
			if (locate is null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}

			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}

			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}

			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}

			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}

			if (compare6 is null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}

			if (compare7 is null)
			{
				throw new ArgumentNullException(nameof(compare7));
			}

			this._locate = locate;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._defaultCompare6 = defaultCompare6;
			this._compare6 = compare6;
			this._defaultCompare7 = defaultCompare7;
			this._compare7 = compare7;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._subdivisionOverride6 = subdivisionOverride6;
			this._subdivisionOverride7 = subdivisionOverride7;
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 7D omnitree that stores points.</summary>
		/// <param name="locate">The delegate for locating items in 7D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>

		/// <param name="compare7">The delegate for comparing values along the 7D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>

		/// <param name="subdivisionOverride7">The subdivision overide to be used when splitting the 7 dimension.</param>
		public OmnitreePointsLinked(
			Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> locate,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Func<Axis7, Axis7, CompareResult> compare7 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5 = null
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6 = null
,
			Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7 = null
			)
			: this(
				locate,
				compare1 is null ? true : false,
				compare1 ?? Compare,
				compare2 is null ? true : false,
				compare2 ?? Compare,
				compare3 is null ? true : false,
				compare3 ?? Compare,
				compare4 is null ? true : false,
				compare4 ?? Compare,
				compare5 is null ? true : false,
				compare5 ?? Compare,
				compare6 is null ? true : false,
				compare6 ?? Compare,
				compare7 is null ? true : false,
				compare7 ?? Compare,
				subdivisionOverride1
,
				subdivisionOverride2
,
				subdivisionOverride3
,
				subdivisionOverride4
,
				subdivisionOverride5
,
				subdivisionOverride6
,
				subdivisionOverride7
				) { }

		#endregion

		#region Properties

		/// <summary>Steps through all the items at a given coordinate.</summary>
		/// <param name="axis1">The coordinate along axis 1.</param>
		/// <param name="axis2">The coordinate along axis 2.</param>
		/// <param name="axis3">The coordinate along axis 3.</param>
		/// <param name="axis4">The coordinate along axis 4.</param>
		/// <param name="axis5">The coordinate along axis 5.</param>
		/// <param name="axis6">The coordinate along axis 6.</param>
		/// <param name="axis7">The coordinate along axis 7.</param>
		/// <returns>The stepper for the items at the given coordinate.</returns>
		public Action<Action<T>> this[Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7] =>
			step => Stepper(step, axis1, axis2, axis3, axis4, axis5, axis6, axis7);

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions { get { return _dimensions; } }

		/// <summary>The location function the Omnitree is using.</summary>
		public Omnitree.Location<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Locate { get { return this._locate; } }

		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 { get { return this._compare1; } }
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 { get { return this._compare2; } }
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 { get { return this._compare3; } }
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 { get { return this._compare4; } }
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 { get { return this._compare5; } }
		/// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
		public Func<Axis6, Axis6, CompareResult> Compare6 { get { return this._compare6; } }
		/// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
		public Func<Axis7, Axis7, CompareResult> Compare7 { get { return this._compare7; } }

		/// <summary>The current number of items in the tree.</summary>
		public int Count { get { return this._top.Count; } }

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
					(Node node, int current_depth, ref int max_depth) =>
					{
						if (current_depth > max_depth)
							max_depth = current_depth;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
					};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
					(Node node, ref int current_count) =>
					{
						current_count++;
						if (node is Branch)
							foreach (Node child in (node as Branch).Children)
								nodeCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void BranchCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int BranchCount
		{
			get
			{
				BranchCountFinder branchCountFinder = null;
				branchCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Branch)
						{
							current_count++;
							foreach (Node child in (node as Branch).Children)
								branchCountFinder(child, ref current_count);
						}
					};

				int _current_count = 0;
				branchCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		internal delegate void LeafCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int LeafCount
		{
			get
			{
				LeafCountFinder leafCountFinder = null;
				leafCountFinder =
					(Node node, ref int current_count) =>
					{
						if (node is Leaf)
							current_count++;
						else
							foreach (Node child in (node as Branch).Children)
								leafCountFinder(child, ref current_count);
					};

				int _current_count = 0;
				leafCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(addition);

			// grow the first branch of the tree
			if (this._top is Leaf && (this._top as Leaf).Count >= _load)
			{
				Leaf top = this._top as Leaf;

				// create the new branch from the median values
				this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Leaf.Node list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, LocateVector(list.Value), 0);
			}

			this.Add(addition, this._top, location, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="location">The location of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location, int depth)
		{
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				if (depth >= _load || !(leaf.Count >= _load))
				{
					leaf.Add(addition);
					return;
				}
				else
				{
					Branch parent = node.Parent;
					int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					parent[child_index] = growth;
					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
					{
						Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> temp_location = LocateVector(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_location))
							Add(list.Value, growth, temp_location, depth);
						else
						{
							ReduceParentCounts(parent, 1);
							Add(list.Value, this._top, temp_location, depth);
						}
					}

					Add(addition, growth, location, depth);
					return;
				}
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				Node child_node = branch[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
					branch[child_index] = new_leaf;
					new_leaf.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, location, depth + 1);

				branch.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineMedians(Leaf leaf)
		{

			Axis1 division1;
			if (!(_subdivisionOverride1 is null))
			{
				division1 = _subdivisionOverride1(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis1[] values = new Axis1[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare1) Array.Sort(values);
				else SortQuick<Axis1>(values, this._compare1);
				int index = (leaf.Count - 1) / 2;
				division1 = values[index];
			}

			Axis2 division2;
			if (!(_subdivisionOverride2 is null))
			{
				division2 = _subdivisionOverride2(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis2[] values = new Axis2[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare2) Array.Sort(values);
				else SortQuick<Axis2>(values, this._compare2);
				int index = (leaf.Count - 1) / 2;
				division2 = values[index];
			}

			Axis3 division3;
			if (!(_subdivisionOverride3 is null))
			{
				division3 = _subdivisionOverride3(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis3[] values = new Axis3[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					, out _
					);
				if (_defaultCompare3) Array.Sort(values);
				else SortQuick<Axis3>(values, this._compare3);
				int index = (leaf.Count - 1) / 2;
				division3 = values[index];
			}

			Axis4 division4;
			if (!(_subdivisionOverride4 is null))
			{
				division4 = _subdivisionOverride4(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis4[] values = new Axis4[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					, out _
					);
				if (_defaultCompare4) Array.Sort(values);
				else SortQuick<Axis4>(values, this._compare4);
				int index = (leaf.Count - 1) / 2;
				division4 = values[index];
			}

			Axis5 division5;
			if (!(_subdivisionOverride5 is null))
			{
				division5 = _subdivisionOverride5(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis5[] values = new Axis5[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					, out _
					);
				if (_defaultCompare5) Array.Sort(values);
				else SortQuick<Axis5>(values, this._compare5);
				int index = (leaf.Count - 1) / 2;
				division5 = values[index];
			}

			Axis6 division6;
			if (!(_subdivisionOverride6 is null))
			{
				division6 = _subdivisionOverride6(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis6[] values = new Axis6[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					, out _
					);
				if (_defaultCompare6) Array.Sort(values);
				else SortQuick<Axis6>(values, this._compare6);
				int index = (leaf.Count - 1) / 2;
				division6 = values[index];
			}

			Axis7 division7;
			if (!(_subdivisionOverride7 is null))
			{
				division7 = _subdivisionOverride7(leaf.Bounds, x =>
					{
						for (Leaf.Node node = leaf.Head; node is not null; node = node.Next)
						{
							x(node.Value);
						}
					});
			}
			else
			{
				Axis7[] values = new Axis7[leaf.Count];
				Leaf.Node for_current = leaf.Head;
				for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
					this._locate(for_current.Value
					, out _
					, out _
					, out _
					, out _
					, out _
					, out _
					, out values[i]
					);
				if (_defaultCompare7) Array.Sort(values);
				else SortQuick<Axis7>(values, this._compare7);
				int index = (leaf.Count - 1) / 2;
				division7 = values[index];
			}

			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
				division1
		
				, division2
		
				, division3
		
				, division4
		
				, division5
		
				, division6
		
				, division7
		
				);
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineChildBounds(Branch branch, int child_index)
		{

			Omnitree.Bound<Axis7> min7, max7;
			if (child_index >= 64)
			{
				min7 = branch.PointOfDivision.Axis7;
				max7 = branch.Bounds.Max7;
				child_index -= 64;
			}
			else
			{
				min7 = branch.Bounds.Min7;
				max7 = branch.PointOfDivision.Axis7;
			}

			Omnitree.Bound<Axis6> min6, max6;
			if (child_index >= 32)
			{
				min6 = branch.PointOfDivision.Axis6;
				max6 = branch.Bounds.Max6;
				child_index -= 32;
			}
			else
			{
				min6 = branch.Bounds.Min6;
				max6 = branch.PointOfDivision.Axis6;
			}

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = branch.PointOfDivision.Axis5;
				max5 = branch.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = branch.Bounds.Min5;
				max5 = branch.PointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = branch.PointOfDivision.Axis4;
				max4 = branch.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = branch.Bounds.Min4;
				max4 = branch.PointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = branch.PointOfDivision.Axis3;
				max3 = branch.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = branch.Bounds.Min3;
				max3 = branch.PointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = branch.PointOfDivision.Axis2;
				max2 = branch.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = branch.Bounds.Min2;
				max2 = branch.PointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = branch.PointOfDivision.Axis1;
				max1 = branch.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = branch.Bounds.Min1;
				max1 = branch.PointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Clone()
		{
			return new OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpace(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			return CountSubSpace(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}
		/// <summary>Counts the number of items in a sub space.</summary>
		/// <param name="node">The current traversal node.</param>
		/// <param name="bounds">The bounds of the sub space being counted.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		internal int CountSubSpace(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						count++;
			}
			else
			{
				Branch branch = node as Branch;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(bounds.Min1.Value
						, bounds.Min2.Value
						, bounds.Min3.Value
						, bounds.Min4.Value
						, bounds.Min5.Value
						, bounds.Min6.Value
						, bounds.Min7.Value
						));
					Node child = branch[child_index];
					if (child is not null)
					{
						count += this.CountSubSpace(child, bounds);
					}
				}
				else
				{
					foreach (Node child in (node as Branch).Children)
						count += this.CountSubSpace(child, bounds);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, location);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> location = LocateVector(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, location))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, location);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, location, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				while (leaf.Head is not null && where(leaf.Head.Value))
				{
					leaf.Head = leaf.Head.Next;
					removals++;
				}
				if (leaf.Head is not null)
				{
					Leaf.Node list = leaf.Head;
					while (list.Next is not null)
					{
						if (where(list.Next.Value))
						{
							list.Next = list.Next.Next;
							removals++;
						}
					}
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				branch.Count -= removals;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);

				return removals;
			}
		}

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				if (node is Leaf)
				{
					Leaf leaf = node as Leaf;
					Leaf.Node current_node = leaf.Head;
					Leaf.Node previous_node = null;
					while (!(current_node is null))
					{
						Leaf.Node temp_previous = current_node;
						if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
						{
							removals++;
							if (current_node == leaf.Head)
								leaf.Head = leaf.Head.Next;
							else
							{
								previous_node.Next = current_node.Next;
								temp_previous = previous_node;
							}
						}
						previous_node = temp_previous;
						current_node = current_node.Next;
					}
					leaf.Count -= removals;
				}
				else
				{
					Branch branch = node as Branch;
					int skipped = 0;
					for (int i = 0; i + skipped < branch.Children.Length; )
					{
						removals += this.Remove(branch.Children[i], bounds);
						if (branch.Children[i].Count is 0)
							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[branch.Children.Length - skipped];
					Array.Copy(branch.Children, newArray, newArray.Length);
					branch.Children = newArray;

					branch.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (branch.Count < _load && branch.Count > 0)
						ShrinkChild(branch.Parent, branch.Index);
				}
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current = leaf.Head;
				Leaf.Node previous = null;
				while (current is not null)
				{
					if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
					{
						removals++;
						if (previous is null)
						{
							leaf.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}

				leaf.Count -= removals;
				return removals;
			}
			else
			{
				Branch branch = node as Branch;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Remove(branch.Children[i], bounds, where);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				node.Count -= removals;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);

				return removals;
			}
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void Remove(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			, Axis6 axis6
			, Axis7 axis7
			)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1
				, axis2
				, axis3
				, axis4
				, axis5
				, axis6
				, axis7
				));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void Remove(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where)
		{
			this.Remove(this._top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7), where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		internal int Remove(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector, Predicate<T> where)
		{
			int removals = 0;
			if (node is Leaf)
			{
				Leaf leaf = node as Leaf;
				Leaf.Node current_node = leaf.Head;
				Leaf.Node previous_node = null;
				while (!(current_node is null))
				{
					Leaf.Node temp_previous = current_node;
					if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
					{
						removals++;
						if (current_node == leaf.Head)
							leaf.Head = leaf.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}
				leaf.Count -= removals;
			}
			else
			{
				Branch branch = node as Branch;
				int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				removals += Remove(branch[child_index], vector, where);
				branch.Count -= removals;
				// convert this branch back into a leaf
				// Note: if count is zero, it will be chopped off
				if (branch.Count < _load && branch.Count > 0)
					ShrinkChild(branch.Parent, branch.Index);
			}
			return removals;
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			if (node is Leaf)
			{
				Leaf.Node list = (node as Leaf).Head;
				while (list is not null)
				{
					step(list.Value);
					list = list.Next;
				}
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					this.Stepper(step, child);
			}
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf leaf)
			{
				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)
				{
					if (step.Invoke(list.Value) is Break) return Break;
				}
			}
			else if (node is Branch branch)
			{
				foreach (Node child in branch.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if ((status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Stepper(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Stepper(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal void Stepper(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)))
						step(list.Value);
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.Stepper(step, child, bounds);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			Stepper(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			StepStatus status = StepStatus.Continue;
			if (node is Leaf)
			{
				for (Leaf.Node list = (node as Leaf).Head; list is not null; list = list.Next)
					if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
						(status = step(list.Value)) != StepStatus.Continue)
						break;
			}
			else
			{
				foreach (Node child in (node as Branch).Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.Stepper(step, child, bounds)) != StepStatus.Continue)
						break;
			}
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));

		internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
						if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
							step(leaf_node.Value);
					break;
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7) =>
			Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7));

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
		{
			Node current = node;
			while (current is not null)
			{
				if (current is Leaf)
				{
					for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
					{
						StepStatus status = StepStatus.Continue;
						if (EqualsCheck(vector, LocateVector(list.Value)) &&
							(status = step(list.Value)) != StepStatus.Continue)
							return status;
					}
				}
				else
				{
					Branch branch = current as Branch;
					int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
					current = branch[child_index];
				}
			}
			return StepStatus.Continue;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				, _compare6
				, _compare7
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="vector">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
		{
			int child = 0;
			if (!(this._compare1(vector.Axis1, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!(this._compare2(vector.Axis2, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!(this._compare3(vector.Axis3, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!(this._compare4(vector.Axis4, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!(this._compare5(vector.Axis5, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			if (!(this._compare6(vector.Axis6, pointOfDivision.Axis6) is Less))
				child += 1 << 5;
			if (!(this._compare7(vector.Axis7, pointOfDivision.Axis7) is Less))
				child += 1 << 6;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Branch parent, int child_index)
		{
			Leaf leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Leaf(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			, (a, b) => _compare6(a, b) is Equal
			, (a, b) => _compare7(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="vector">The coordinates of the value.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, vector))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> LocateVector(T value)
		{
			Axis1 axis1;
			Axis2 axis2;
			Axis3 axis3;
			Axis4 axis4;
			Axis5 axis5;
			Axis6 axis6;
			Axis7 axis7;
			this._locate(value, out axis1
, out axis2
, out axis3
, out axis4
, out axis5
, out axis6
, out axis7
);
			return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis2, axis3, axis4, axis5, axis6, axis7);
		}

		#endregion

		#endregion
	}

	#endregion

	#endregion

	#region OmnitreeBounds

	#region 1 Dimensional

	/// <summary>Inheritance base for 1D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1> : IOmnitree<T, Axis1>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 1D space.</summary>
		Omnitree.GetBounds<T, Axis1
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void Update(Axis1 min1, Axis1 max1);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		void RemoveOverlapped(Axis1 axis1);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 1 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1> : IOmnitreeBounds<T, Axis1>
	{
		internal const int _dimensions = 1;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 1);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> _subdivisionOverride1;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 1D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 1D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			subdivisionOverride1
			) { }

		/// <summary>Constructs a new 1D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 1D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1>> subdivisionOverride1 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			subdivisionOverride1
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 1D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//	}
			//	return new Omnitree.Vector<Axis1>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1>(min1, max1);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Update(Axis1 min1, Axis1 max1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(min1, max1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		public void Update(Axis1 axis1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1)
		{
			this.Update(new Omnitree.Bounds<Axis1>(axis1, axis1), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(axis1, axis1));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1>(min1, max1), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			)
		{
			this.RemoveOverlapped(axis1, axis1
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1>(min1, max1));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1>, Omnitree.Bounds<Axis1>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1>(axis1, axis1
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1>(axis1, axis1
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1> pointOfDivision, Omnitree.Bounds<Axis1> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1> bounds, Omnitree.Vector<Axis1> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1> a, Omnitree.Bounds<Axis1> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1> a, Omnitree.Vector<Axis1> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			this._getBounds(value,
				out min1, out max1
				);
			return new Omnitree.Bounds<Axis1>(
				min1, max1
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 2 Dimensional

	/// <summary>Inheritance base for 2D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2> : IOmnitree<T, Axis1, Axis2>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 2D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 2 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2> : IOmnitreeBounds<T, Axis1, Axis2>
	{
		internal const int _dimensions = 2;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 2);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> _subdivisionOverride2;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 2D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 2D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
			) { }

		/// <summary>Constructs a new 2D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 2D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2>> subdivisionOverride2 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 2D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1, axis2, axis2));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2>(min1, max1, min2, max2));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2>, Omnitree.Bounds<Axis1, Axis2>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1
				, axis2, axis2
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2>(axis1, axis1
				, axis2, axis2
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2> pointOfDivision, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> bounds, Omnitree.Vector<Axis1, Axis2> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2> a, Omnitree.Bounds<Axis1, Axis2> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2> a, Omnitree.Vector<Axis1, Axis2> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
				);
			return new Omnitree.Bounds<Axis1, Axis2>(
				min1, max1
,
				min2, max2
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 3 Dimensional

	/// <summary>Inheritance base for 3D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3> : IOmnitree<T, Axis1, Axis2, Axis3>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 3D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 3 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> : IOmnitreeBounds<T, Axis1, Axis2, Axis3>
	{
		internal const int _dimensions = 3;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 3);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> _subdivisionOverride3;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2, Axis3> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 3D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 3D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
			) { }

		/// <summary>Constructs a new 3D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 3D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>
		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2, Axis3> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride2 = null
			, Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3>> subdivisionOverride3 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 3D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			, Axis3
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 => _compare3;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2, Axis3> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
, 
					out values3[i * 2], out values3[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2, Axis3>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
, 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis3>> values3 = new ArrayJagged<Omnitree.Bound<Axis3>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
//,
			//			out min3, out max3
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//		values3[i * 2] = min3; values3[i * 2 + 1] = max3;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2, Axis3>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//		, Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = pointOfDivision.Axis3;
				max3 = node.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = node.Bounds.Min3;
				max3 = pointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1, axis2, axis2, axis3, axis3));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(min1, max1, min2, max2, min3, max3));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3>, Omnitree.Bounds<Axis1, Axis2, Axis3>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> bounds, Omnitree.Vector<Axis1, Axis2, Axis3> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3> a, Omnitree.Bounds<Axis1, Axis2, Axis3> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3> a, Omnitree.Vector<Axis1, Axis2, Axis3> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2, Axis3> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
,
				out min3, out max3
				);
			return new Omnitree.Bounds<Axis1, Axis2, Axis3>(
				min1, max1
,
				min2, max2
,
				min3, max3
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 4 Dimensional

	/// <summary>Inheritance base for 4D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 4D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 4 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4>
	{
		internal const int _dimensions = 4;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 4);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> _subdivisionOverride4;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 4D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 4D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
			) { }

		/// <summary>Constructs a new 4D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 4D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>
		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>
		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride2 = null
			, Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride3 = null
			, Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> subdivisionOverride4 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 4D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 => _compare3;
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 => _compare4;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
				Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
, 
					out values3[i * 2], out values3[i * 2 + 1]
, 
					out values4[i * 2], out values4[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
, 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
, 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis3>> values3 = new ArrayJagged<Omnitree.Bound<Axis3>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis4>> values4 = new ArrayJagged<Omnitree.Bound<Axis4>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			//		Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
//,
			//			out min3, out max3
//,
			//			out min4, out max4
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//		values3[i * 2] = min3; values3[i * 2 + 1] = max3;
			//		values4[i * 2] = min4; values4[i * 2 + 1] = max4;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//		, Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
			//		, Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = pointOfDivision.Axis4;
				max4 = node.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = node.Bounds.Min4;
				max4 = pointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = pointOfDivision.Axis3;
				max3 = node.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = node.Bounds.Min3;
				max3 = pointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(min1, max1, min2, max2, min3, max3, min4, max4));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
,
				out min3, out max3
,
				out min4, out max4
				);
			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4>(
				min1, max1
,
				min2, max2
,
				min3, max3
,
				min4, max4
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 5 Dimensional

	/// <summary>Inheritance base for 5D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 5D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 5 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5>
	{
		internal const int _dimensions = 5;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 5);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> _subdivisionOverride5;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 5D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 5D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
			) { }

		/// <summary>Constructs a new 5D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 5D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>
		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>
		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>
		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride2 = null
			, Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride3 = null
			, Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride4 = null
			, Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> subdivisionOverride5 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 5D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 => _compare3;
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 => _compare4;
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 => _compare5;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
				Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
				Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
, 
					out values3[i * 2], out values3[i * 2 + 1]
, 
					out values4[i * 2], out values4[i * 2 + 1]
, 
					out values5[i * 2], out values5[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
, 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
, 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
, 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis3>> values3 = new ArrayJagged<Omnitree.Bound<Axis3>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis4>> values4 = new ArrayJagged<Omnitree.Bound<Axis4>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis5>> values5 = new ArrayJagged<Omnitree.Bound<Axis5>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			//		Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			//		Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
//,
			//			out min3, out max3
//,
			//			out min4, out max4
//,
			//			out min5, out max5
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//		values3[i * 2] = min3; values3[i * 2 + 1] = max3;
			//		values4[i * 2] = min4; values4[i * 2 + 1] = max4;
			//		values5[i * 2] = min5; values5[i * 2 + 1] = max5;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//		, Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
			//		, Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
			//		, Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = pointOfDivision.Axis5;
				max5 = node.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = node.Bounds.Min5;
				max5 = pointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = pointOfDivision.Axis4;
				max4 = node.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = node.Bounds.Min4;
				max4 = pointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = pointOfDivision.Axis3;
				max3 = node.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = node.Bounds.Min3;
				max3 = pointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
,
				out min3, out max3
,
				out min4, out max4
,
				out min5, out max5
				);
			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5>(
				min1, max1
,
				min2, max2
,
				min3, max3
,
				min4, max4
,
				min5, max5
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 6 Dimensional

	/// <summary>Inheritance base for 6D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 6D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
, Axis6
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 6 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>
	{
		internal const int _dimensions = 6;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 6);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
, Axis6
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal bool _defaultCompare6;
		internal Func<Axis6, Axis6, CompareResult> _compare6;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride5;
		internal Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> _subdivisionOverride6;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._defaultCompare6 = omnitree._defaultCompare6;
			this._compare6 = omnitree._compare6;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
			this._subdivisionOverride6 = omnitree._subdivisionOverride6;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			bool defaultCompare6,
			Func<Axis6, Axis6, CompareResult> compare6,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 is null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._defaultCompare6 = defaultCompare6;
			this._compare6 = compare6;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._subdivisionOverride6 = subdivisionOverride6;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 6D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 6D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5 = null
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			compare6 is null ? true : false,
			compare6 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
,
			subdivisionOverride6
			) { }

		/// <summary>Constructs a new 6D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 6D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>
		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>
		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>
		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>
		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride2 = null
			, Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride3 = null
			, Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride4 = null
			, Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride5 = null
			, Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> subdivisionOverride6 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			compare6 is null ? true : false,
			compare6 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
,
			subdivisionOverride6
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 6D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 => _compare3;
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 => _compare4;
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 => _compare5;
		/// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
		public Func<Axis6, Axis6, CompareResult> Compare6 => _compare6;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
				Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
				Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
				Omnitree.Bound<Axis6>[] values6 = new Omnitree.Bound<Axis6>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
, 
					out values3[i * 2], out values3[i * 2 + 1]
, 
					out values4[i * 2], out values4[i * 2 + 1]
, 
					out values5[i * 2], out values5[i * 2 + 1]
, 
					out values6[i * 2], out values6[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
, 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
, 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
, 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
, 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare : this._compare6)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis3>> values3 = new ArrayJagged<Omnitree.Bound<Axis3>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis4>> values4 = new ArrayJagged<Omnitree.Bound<Axis4>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis5>> values5 = new ArrayJagged<Omnitree.Bound<Axis5>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis6>> values6 = new ArrayJagged<Omnitree.Bound<Axis6>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			//		Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			//		Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			//		Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
//,
			//			out min3, out max3
//,
			//			out min4, out max4
//,
			//			out min5, out max5
//,
			//			out min6, out max6
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//		values3[i * 2] = min3; values3[i * 2 + 1] = max3;
			//		values4[i * 2] = min4; values4[i * 2 + 1] = max4;
			//		values5[i * 2] = min5; values5[i * 2 + 1] = max5;
			//		values6[i * 2] = min6; values6[i * 2 + 1] = max6;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//		, Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
			//		, Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
			//		, Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
			//		, Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare : this._compare6)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis6> min6, max6;
			if (child_index >= 32)
			{
				min6 = pointOfDivision.Axis6;
				max6 = node.Bounds.Max6;
				child_index -= 32;
			}
			else
			{
				min6 = node.Bounds.Min6;
				max6 = pointOfDivision.Axis6;
			}

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = pointOfDivision.Axis5;
				max5 = node.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = node.Bounds.Min5;
				max5 = pointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = pointOfDivision.Axis4;
				max4 = node.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = node.Bounds.Min4;
				max4 = pointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = pointOfDivision.Axis3;
				max3 = node.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = node.Bounds.Min3;
				max3 = pointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			, Axis6 axis6
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				, _compare6
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			if (!bounds.Min6.Exists || !(this._compare6(bounds.Min6.Value, pointOfDivision.Axis6) is Less))
				child += 1 << 5;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			, (a, b) => _compare6(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
,
				out min3, out max3
,
				out min4, out max4
,
				out min5, out max5
,
				out min6, out max6
				);
			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6>(
				min1, max1
,
				min2, max2
,
				min3, max3
,
				min4, max4
,
				min5, max5
,
				min6, max6
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#region 7 Dimensional

	/// <summary>Inheritance base for 7D omnitrees that store bounds.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	/// <typeparam name="Axis7">The type 7D axis.</typeparam>
	public interface IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitree<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
	{
		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		int Dimensions { get; }

		/// <summary>The delegate being used by the omnitree to get the bounds of values in 7D space.</summary>
		Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
, Axis6
, Axis7
			> GetBounds { get; }

		#endregion

		#region Methods

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		void Update();
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7);
		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Removes all the items in a given space where equality is met.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where);
		/// <summary>Removes all the items in a given space where predicate is met.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The predicate constraint of the removal.</param>
		void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7);

		#endregion
	}

	/// <summary>Omnitree that stores bounds along 7 dimensions implemented as a linked tree.</summary>
	/// <typeparam name="T">The type of items to store in the omnitree.</typeparam>
	/// <typeparam name="Axis1">The type 1D axis.</typeparam>
	/// <typeparam name="Axis2">The type 2D axis.</typeparam>
	/// <typeparam name="Axis3">The type 3D axis.</typeparam>
	/// <typeparam name="Axis4">The type 4D axis.</typeparam>
	/// <typeparam name="Axis5">The type 5D axis.</typeparam>
	/// <typeparam name="Axis6">The type 6D axis.</typeparam>
	/// <typeparam name="Axis7">The type 7D axis.</typeparam>
	public class OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> : IOmnitreeBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>
	{
		internal const int _dimensions = 7;
		internal static int _children_per_node = (int)BigInteger.Pow(2, 7);

		internal Node _top;
		internal int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		internal int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
		internal int _load; // ln(count); min = _defaultLoad
		internal Omnitree.GetBounds<T, Axis1
, Axis2
, Axis3
, Axis4
, Axis5
, Axis6
, Axis7
			> _getBounds;
		internal bool _defaultCompare1;
		internal Func<Axis1, Axis1, CompareResult> _compare1;
		internal bool _defaultCompare2;
		internal Func<Axis2, Axis2, CompareResult> _compare2;
		internal bool _defaultCompare3;
		internal Func<Axis3, Axis3, CompareResult> _compare3;
		internal bool _defaultCompare4;
		internal Func<Axis4, Axis4, CompareResult> _compare4;
		internal bool _defaultCompare5;
		internal Func<Axis5, Axis5, CompareResult> _compare5;
		internal bool _defaultCompare6;
		internal Func<Axis6, Axis6, CompareResult> _compare6;
		internal bool _defaultCompare7;
		internal Func<Axis7, Axis7, CompareResult> _compare7;
		internal Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride1;
		internal Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride2;
		internal Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride3;
		internal Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride4;
		internal Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride5;
		internal Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride6;
		internal Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> _subdivisionOverride7;

		#region Nested Types

		/// <summary>Can be a leaf or a branch.</summary>
		internal class Node
		{
			internal class ValueNode
			{
				internal T Value;
				internal ValueNode Next;

				internal ValueNode(T value, ValueNode next)
				{
					Value = value;
					Next = next;
				}
			}

			internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Bounds;
			internal Node Parent;
			internal int Index;
			internal int Count;
			internal ValueNode Head;
			internal Node[] Children;
			internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>? PointOfDivision;

			/// <summary>Gets child by index.</summary>
			/// <param name="child_index">The index of the child to get.</param>
			/// <returns>The child of the given index or null if non-existent.</returns>
			internal Node this[int child_index]
			{
				get
				{
					if (Children is null)
						return null;
					if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
						return Children[(int)child_index];
					foreach (Node node in Children)
						if (node.Index == child_index)
							return node;
					return null;
				}
				set
				{
					// This error check should be unnecessary... but fuck it... might as well
					if (value.Index != child_index)
						throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

					// no children yet
					if (Children is null)
					{
						Children = Ɐ(value);
						return;
					}
					// max children overwrite
					else if (Children.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
					{
						Children[(int)child_index] = value;
						return;
					}
					// non-max child overwrite
					for (int i = 0; i < Children.Length; i++)
						if (Children[i].Index == child_index)
						{
							Children[i] = value;
							return;
						}
					// new child
					Node[] newArray = new Node[Children.Length + 1];
					if (newArray.Length == OmnitreePointsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>._children_per_node)
					{
						// new child resulting in a max children branch (sorting required)
						for (int i = 0; i < Children.Length; i++)
						{
							newArray[(int)Children[i].Index] = Children[i];
						}
						newArray[(int)value.Index] = value;
					}
					else
					{
						// new child resulting in a non-max children branch
						Array.Copy(Children, newArray, Children.Length);
						newArray[newArray.Length - 1] = value;
					}
					Children = newArray;
				}
			}

			/// <summary>The depth this node is located in the Omnitree.</summary>
			internal int Depth
			{
				get
				{
					int depth = -1;
					for (Node node = this; node is not null; node = node.Parent)
						depth++;
					return depth;
				}
			}

			/// <summary>Constructs a node.</summary>
			/// <param name="bounds">The bounds of this node.</param>
			/// <param name="parent">The parent of this node.</param>
			/// <param name="index">The number of values stored in this node and its children.</param>
			internal Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node parent, int index)
			{
				Bounds = bounds;
				Parent = parent;
				Index = index;
			}

			internal Node(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node parent, int index)
				: this(bounds, parent, index)
			{
				PointOfDivision = pointOfDivision;
			}

			internal Node(Node nodeToClone)
			{
				this.Bounds = nodeToClone.Bounds;
				this.Parent = nodeToClone.Parent;
				this.Index = nodeToClone.Index;
				this.Count = nodeToClone.Count;

				Children = nodeToClone.Children.Clone() as Node[];
				PointOfDivision = nodeToClone.PointOfDivision;

				ValueNode a = this.Head;
				ValueNode b = nodeToClone.Head;

				while (b is not null)
				{
					a.Next = new ValueNode(b.Next.Value, null);
					a = a.Next;
					b = b.Next;
				}
			}

			internal void Add(T addition)
			{
				Head = new ValueNode(addition, Head);
				Count++;
			}

			internal Node Clone() =>
				new Node(this);
		}
		
		#endregion

		#region Constructors

		/// <summary>This constructor is for cloning purposes</summary>
		internal OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> omnitree)
		{
			this._top = omnitree._top.Clone();
			this._load = omnitree._load;
			this._getBounds = omnitree._getBounds;
			this._defaultCompare1 = omnitree._defaultCompare1;
			this._compare1 = omnitree._compare1;
			this._defaultCompare2 = omnitree._defaultCompare2;
			this._compare2 = omnitree._compare2;
			this._defaultCompare3 = omnitree._defaultCompare3;
			this._compare3 = omnitree._compare3;
			this._defaultCompare4 = omnitree._defaultCompare4;
			this._compare4 = omnitree._compare4;
			this._defaultCompare5 = omnitree._defaultCompare5;
			this._compare5 = omnitree._compare5;
			this._defaultCompare6 = omnitree._defaultCompare6;
			this._compare6 = omnitree._compare6;
			this._defaultCompare7 = omnitree._defaultCompare7;
			this._compare7 = omnitree._compare7;
			this._subdivisionOverride1 = omnitree._subdivisionOverride1;
			this._subdivisionOverride2 = omnitree._subdivisionOverride2;
			this._subdivisionOverride3 = omnitree._subdivisionOverride3;
			this._subdivisionOverride4 = omnitree._subdivisionOverride4;
			this._subdivisionOverride5 = omnitree._subdivisionOverride5;
			this._subdivisionOverride6 = omnitree._subdivisionOverride6;
			this._subdivisionOverride7 = omnitree._subdivisionOverride7;
		}

		internal OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
			bool defaultCompare1,
			Func<Axis1, Axis1, CompareResult> compare1,
			bool defaultCompare2,
			Func<Axis2, Axis2, CompareResult> compare2,
			bool defaultCompare3,
			Func<Axis3, Axis3, CompareResult> compare3,
			bool defaultCompare4,
			Func<Axis4, Axis4, CompareResult> compare4,
			bool defaultCompare5,
			Func<Axis5, Axis5, CompareResult> compare5,
			bool defaultCompare6,
			Func<Axis6, Axis6, CompareResult> compare6,
			bool defaultCompare7,
			Func<Axis7, Axis7, CompareResult> compare7,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6
,
			Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7
			)
		{
			if (getBounds is null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (compare1 is null)
			{
				throw new ArgumentNullException(nameof(compare1));
			}
			if (compare2 is null)
			{
				throw new ArgumentNullException(nameof(compare2));
			}
			if (compare3 is null)
			{
				throw new ArgumentNullException(nameof(compare3));
			}
			if (compare4 is null)
			{
				throw new ArgumentNullException(nameof(compare4));
			}
			if (compare5 is null)
			{
				throw new ArgumentNullException(nameof(compare5));
			}
			if (compare6 is null)
			{
				throw new ArgumentNullException(nameof(compare6));
			}
			if (compare7 is null)
			{
				throw new ArgumentNullException(nameof(compare7));
			}
			this._getBounds = getBounds;
			this._defaultCompare1 = defaultCompare1;
			this._compare1 = compare1;
			this._defaultCompare2 = defaultCompare2;
			this._compare2 = compare2;
			this._defaultCompare3 = defaultCompare3;
			this._compare3 = compare3;
			this._defaultCompare4 = defaultCompare4;
			this._compare4 = compare4;
			this._defaultCompare5 = defaultCompare5;
			this._compare5 = compare5;
			this._defaultCompare6 = defaultCompare6;
			this._compare6 = compare6;
			this._defaultCompare7 = defaultCompare7;
			this._compare7 = compare7;
			this._subdivisionOverride1 = subdivisionOverride1;
			this._subdivisionOverride2 = subdivisionOverride2;
			this._subdivisionOverride3 = subdivisionOverride3;
			this._subdivisionOverride4 = subdivisionOverride4;
			this._subdivisionOverride5 = subdivisionOverride5;
			this._subdivisionOverride6 = subdivisionOverride6;
			this._subdivisionOverride7 = subdivisionOverride7;
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Constructs a new 7D omnitree that stores bounds.</summary>
		/// <param name="getBounds">The delegate for getting object bounds in 7D space.</param>

		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>

		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>

		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>

		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>

		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>

		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>

		/// <param name="compare7">The delegate for comparing values along the 7D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>

		/// <param name="subdivisionOverride7">The subdivision overide to be used when splitting the 7 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBounds<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBounds,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Func<Axis7, Axis7, CompareResult> compare7 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1 = null
,
			Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2 = null
,
			Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3 = null
,
			Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4 = null
,
			Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5 = null
,
			Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6 = null
,
			Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7 = null
			)
			: this(
			getBounds,
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			compare6 is null ? true : false,
			compare6 ?? Compare,
			compare7 is null ? true : false,
			compare7 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
,
			subdivisionOverride6
,
			subdivisionOverride7
			) { }

		/// <summary>Constructs a new 7D omnitree that stores bounds.</summary>
		/// <param name="getBoundings">The delegate for getting object bounds in 7D space.</param>
		/// <param name="compare1">The delegate for comparing values along the 1D axis.</param>
		/// <param name="compare2">The delegate for comparing values along the 2D axis.</param>
		/// <param name="compare3">The delegate for comparing values along the 3D axis.</param>
		/// <param name="compare4">The delegate for comparing values along the 4D axis.</param>
		/// <param name="compare5">The delegate for comparing values along the 5D axis.</param>
		/// <param name="compare6">The delegate for comparing values along the 6D axis.</param>
		/// <param name="compare7">The delegate for comparing values along the 7D axis.</param>

		/// <param name="subdivisionOverride1">The subdivision overide to be used when splitting the 1 dimension.</param>

		/// <param name="subdivisionOverride2">The subdivision overide to be used when splitting the 2 dimension.</param>

		/// <param name="subdivisionOverride3">The subdivision overide to be used when splitting the 3 dimension.</param>

		/// <param name="subdivisionOverride4">The subdivision overide to be used when splitting the 4 dimension.</param>

		/// <param name="subdivisionOverride5">The subdivision overide to be used when splitting the 5 dimension.</param>

		/// <param name="subdivisionOverride6">The subdivision overide to be used when splitting the 6 dimension.</param>

		/// <param name="subdivisionOverride7">The subdivision overide to be used when splitting the 7 dimension.</param>
		public OmnitreeBoundsLinked(
			Omnitree.GetBoundings<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> getBoundings,
			Func<Axis1, Axis1, CompareResult> compare1 = null,
			Func<Axis2, Axis2, CompareResult> compare2 = null,
			Func<Axis3, Axis3, CompareResult> compare3 = null,
			Func<Axis4, Axis4, CompareResult> compare4 = null,
			Func<Axis5, Axis5, CompareResult> compare5 = null,
			Func<Axis6, Axis6, CompareResult> compare6 = null,
			Func<Axis7, Axis7, CompareResult> compare7 = null,
			Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride1 = null
			, Omnitree.SubdivisionOverride<T, Axis2, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride2 = null
			, Omnitree.SubdivisionOverride<T, Axis3, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride3 = null
			, Omnitree.SubdivisionOverride<T, Axis4, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride4 = null
			, Omnitree.SubdivisionOverride<T, Axis5, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride5 = null
			, Omnitree.SubdivisionOverride<T, Axis6, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride6 = null
			, Omnitree.SubdivisionOverride<T, Axis7, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> subdivisionOverride7 = null
			)
			: this(
			Omnitree.ConvertToGetBounds(getBoundings),
			compare1 is null ? true : false,
			compare1 ?? Compare,
			compare2 is null ? true : false,
			compare2 ?? Compare,
			compare3 is null ? true : false,
			compare3 ?? Compare,
			compare4 is null ? true : false,
			compare4 ?? Compare,
			compare5 is null ? true : false,
			compare5 ?? Compare,
			compare6 is null ? true : false,
			compare6 ?? Compare,
			compare7 is null ? true : false,
			compare7 ?? Compare,
			subdivisionOverride1
,
			subdivisionOverride2
,
			subdivisionOverride3
,
			subdivisionOverride4
,
			subdivisionOverride5
,
			subdivisionOverride6
,
			subdivisionOverride7
			) { }

		#endregion

		#region Properties

		/// <summary>The number of dimensions in this tree.</summary>
		public int Dimensions => _dimensions;

		/// <summary>The delegate being used by the omnitree to locate items in 7D space.</summary>
		public Omnitree.GetBounds<T, Axis1
			, Axis2
			, Axis3
			, Axis4
			, Axis5
			, Axis6
			, Axis7
			> GetBounds => _getBounds;


		/// <summary>The comparison function the Omnitree is using along the 1D axis.</summary>
		public Func<Axis1, Axis1, CompareResult> Compare1 => _compare1;
		/// <summary>The comparison function the Omnitree is using along the 2D axis.</summary>
		public Func<Axis2, Axis2, CompareResult> Compare2 => _compare2;
		/// <summary>The comparison function the Omnitree is using along the 3D axis.</summary>
		public Func<Axis3, Axis3, CompareResult> Compare3 => _compare3;
		/// <summary>The comparison function the Omnitree is using along the 4D axis.</summary>
		public Func<Axis4, Axis4, CompareResult> Compare4 => _compare4;
		/// <summary>The comparison function the Omnitree is using along the 5D axis.</summary>
		public Func<Axis5, Axis5, CompareResult> Compare5 => _compare5;
		/// <summary>The comparison function the Omnitree is using along the 6D axis.</summary>
		public Func<Axis6, Axis6, CompareResult> Compare6 => _compare6;
		/// <summary>The comparison function the Omnitree is using along the 7D axis.</summary>
		public Func<Axis7, Axis7, CompareResult> Compare7 => _compare7;

		/// <summary>The current number of items in the tree.</summary>
		public int Count  => _top.Count;

		internal delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
		/// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int MaxDepth
		{
			get
			{
				MaxDepthFinder maxDepthFinder = null;
				maxDepthFinder =
						(Node node, int current_depth, ref int max_depth) =>
						{
							if (current_depth > max_depth)
								max_depth = current_depth;
							foreach (Node child in node.Children)
								maxDepthFinder(child, current_depth + 1, ref max_depth);
						};
				int _max_depth = -1;
				maxDepthFinder(this._top, 0, ref _max_depth);
				return _max_depth;
			}
		}

		internal delegate void NodeCountFinder(Node node, ref int current_count);
		/// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
		public int NodeCount
		{
			get
			{
				NodeCountFinder nodeCountFinder = null;
				nodeCountFinder =
						(Node node, ref int current_count) =>
						{
							current_count++;
							foreach (Node child in node.Children)
								nodeCountFinder(child, ref current_count);
						};

				int _current_count = 0;
				nodeCountFinder(this._top, ref _current_count);
				return _current_count;
			}
		}

		#endregion

		#region Methods

		#region Add


		#region single

		/// <summary>Tries to add a value.</summary>
		/// <param name="value">The value to be added.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryAdd(T value)
		{
			Add(value);
			return (true, null);
		}

		/// <summary>Adds an item to the tree.</summary>
		/// <param name="addition">The item to be added.</param>
		public void Add(T addition)
		{
			if (this._top.Count is int.MaxValue)
				throw new System.InvalidOperationException("(Count is int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

			// dynamic tree sizes
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);

			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(addition);

			// grow the first branch of the tree
			if (!this._top.PointOfDivision.HasValue && this._top.Count >= _load)
			{
				Node top = this._top;

				// create the new branch from the median values
				this._top = new Node(DetermineMedians(top), Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);

				// iterate through the values and add them to the appropriate children
				for (Node.ValueNode list = top.Head; list is not null; list = list.Next)
					Add(list.Value, this._top, GetBoundings(list.Value), 0);
			}

			this.Add(addition, this._top, bounds, 0);
		}
		
		/// <summary>Recursive version of the add function.</summary>
		/// <param name="addition">The item to be added.</param>
		/// <param name="node">The current node for tree trversal.</param>
		/// <param name="bounds">The bounds of the addition.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal void Add(T addition, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, int depth)
		{
			if (!node.PointOfDivision.HasValue)
			{
				//Leaf leaf = node as Leaf;
				if (depth >= _load || !(node.Count >= _load))
				{
					node.Add(addition);
					return;
				}
				else
				{
					//Node parent = node.Parent;
					//int child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
					//Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
					//parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
					node.Parent[node.Index] = growth;

					for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					{
						Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> temp_bounds = GetBoundings(list.Value);
						if (EncapsulationCheck(growth.Bounds, temp_bounds))
							Add(list.Value, growth, temp_bounds, depth);
						else
						{
							ReduceParentCounts(node.Parent, 1);
							Add(list.Value, this._top, temp_bounds, depth);
						}
					}

					Add(addition, growth, bounds, depth);
					return;
				}
			}
			else
			{
				//Node branch = node as Node;
				int child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
				
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index is -1)
				{
					node.Add(addition);
					return;
				}
				
				Node child_node = node[child_index];

				// null children in branches are just empty leaves
				if (child_node is null)
				{
					Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
					node[child_index] = new_node;
					new_node.Add(addition);
				}
				else
					// child exists already, continue adding
					Add(addition, child_node, bounds, depth + 1);

				node.Count++;
				return;
			}
		}

		internal Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineMedians(Node node)
		{
			//try
			//{
				// extract the values
				Omnitree.Bound<Axis1>[] values1 = new Omnitree.Bound<Axis1>[node.Count * 2];
				Omnitree.Bound<Axis2>[] values2 = new Omnitree.Bound<Axis2>[node.Count * 2];
				Omnitree.Bound<Axis3>[] values3 = new Omnitree.Bound<Axis3>[node.Count * 2];
				Omnitree.Bound<Axis4>[] values4 = new Omnitree.Bound<Axis4>[node.Count * 2];
				Omnitree.Bound<Axis5>[] values5 = new Omnitree.Bound<Axis5>[node.Count * 2];
				Omnitree.Bound<Axis6>[] values6 = new Omnitree.Bound<Axis6>[node.Count * 2];
				Omnitree.Bound<Axis7>[] values7 = new Omnitree.Bound<Axis7>[node.Count * 2];
				Node.ValueNode for_current = node.Head; // used in for loop
				for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
					this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]
, 
					out values2[i * 2], out values2[i * 2 + 1]
, 
					out values3[i * 2], out values3[i * 2 + 1]
, 
					out values4[i * 2], out values4[i * 2 + 1]
, 
					out values5[i * 2], out values5[i * 2 + 1]
, 
					out values6[i * 2], out values6[i * 2 + 1]
, 
					out values7[i * 2], out values7[i * 2 + 1]
					);
				return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
, 
					Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
, 
					Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
, 
					Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
, 
					Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
, 
					Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare : this._compare6)
, 
					Omnitree.SubDivide(values7, this._defaultCompare7 ? Compare : this._compare7)
					);
			//}
			//catch
			//{
				// extract the values
			//	ArrayJagged<Omnitree.Bound<Axis1>> values1 = new ArrayJagged<Omnitree.Bound<Axis1>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis2>> values2 = new ArrayJagged<Omnitree.Bound<Axis2>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis3>> values3 = new ArrayJagged<Omnitree.Bound<Axis3>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis4>> values4 = new ArrayJagged<Omnitree.Bound<Axis4>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis5>> values5 = new ArrayJagged<Omnitree.Bound<Axis5>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis6>> values6 = new ArrayJagged<Omnitree.Bound<Axis6>>(node.Count * 2);
			//	ArrayJagged<Omnitree.Bound<Axis7>> values7 = new ArrayJagged<Omnitree.Bound<Axis7>>(node.Count * 2);
			//	Node.ValueNode for_current = node.Head; // used in for loop
			//	for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
			//	{
			//		Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			//		Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			//		Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			//		Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			//		Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			//		Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			//		Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
			//		this._getBounds(for_current.Value,
			//			out min1, out max1
//,
			//			out min2, out max2
//,
			//			out min3, out max3
//,
			//			out min4, out max4
//,
			//			out min5, out max5
//,
			//			out min6, out max6
//,
			//			out min7, out max7
			//			);
			//		values1[i * 2] = min1; values1[i * 2 + 1] = max1;
			//		values2[i * 2] = min2; values2[i * 2 + 1] = max2;
			//		values3[i * 2] = min3; values3[i * 2 + 1] = max3;
			//		values4[i * 2] = min4; values4[i * 2 + 1] = max4;
			//		values5[i * 2] = min5; values5[i * 2 + 1] = max5;
			//		values6[i * 2] = min6; values6[i * 2 + 1] = max6;
			//		values7[i * 2] = min7; values7[i * 2 + 1] = max7;
			//	}
			//	return new Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
			//		Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare : this._compare1)
			//		, Omnitree.SubDivide(values2, this._defaultCompare2 ? Compare : this._compare2)
			//		, Omnitree.SubDivide(values3, this._defaultCompare3 ? Compare : this._compare3)
			//		, Omnitree.SubDivide(values4, this._defaultCompare4 ? Compare : this._compare4)
			//		, Omnitree.SubDivide(values5, this._defaultCompare5 ? Compare : this._compare5)
			//		, Omnitree.SubDivide(values6, this._defaultCompare6 ? Compare : this._compare6)
			//		, Omnitree.SubDivide(values7, this._defaultCompare7 ? Compare : this._compare7)
			//	);
			//}
		}

		#endregion

		#region Add Helpers

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> DetermineChildBounds(Node node, int child_index)
		{
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision = node.PointOfDivision.Value;

			Omnitree.Bound<Axis7> min7, max7;
			if (child_index >= 64)
			{
				min7 = pointOfDivision.Axis7;
				max7 = node.Bounds.Max7;
				child_index -= 64;
			}
			else
			{
				min7 = node.Bounds.Min7;
				max7 = pointOfDivision.Axis7;
			}

			Omnitree.Bound<Axis6> min6, max6;
			if (child_index >= 32)
			{
				min6 = pointOfDivision.Axis6;
				max6 = node.Bounds.Max6;
				child_index -= 32;
			}
			else
			{
				min6 = node.Bounds.Min6;
				max6 = pointOfDivision.Axis6;
			}

			Omnitree.Bound<Axis5> min5, max5;
			if (child_index >= 16)
			{
				min5 = pointOfDivision.Axis5;
				max5 = node.Bounds.Max5;
				child_index -= 16;
			}
			else
			{
				min5 = node.Bounds.Min5;
				max5 = pointOfDivision.Axis5;
			}

			Omnitree.Bound<Axis4> min4, max4;
			if (child_index >= 8)
			{
				min4 = pointOfDivision.Axis4;
				max4 = node.Bounds.Max4;
				child_index -= 8;
			}
			else
			{
				min4 = node.Bounds.Min4;
				max4 = pointOfDivision.Axis4;
			}

			Omnitree.Bound<Axis3> min3, max3;
			if (child_index >= 4)
			{
				min3 = pointOfDivision.Axis3;
				max3 = node.Bounds.Max3;
				child_index -= 4;
			}
			else
			{
				min3 = node.Bounds.Min3;
				max3 = pointOfDivision.Axis3;
			}

			Omnitree.Bound<Axis2> min2, max2;
			if (child_index >= 2)
			{
				min2 = pointOfDivision.Axis2;
				max2 = node.Bounds.Max2;
				child_index -= 2;
			}
			else
			{
				min2 = node.Bounds.Min2;
				max2 = pointOfDivision.Axis2;
			}

			Omnitree.Bound<Axis1> min1, max1;
			if (child_index >= 1)
			{
				min1 = pointOfDivision.Axis1;
				max1 = node.Bounds.Max1;
				child_index -= 1;
			}
			else
			{
				min1 = node.Bounds.Min1;
				max1 = pointOfDivision.Axis1;
			}

			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7);
		}

		#endregion

		#endregion

		#region Clear

		/// <summary>Returns the tree to an empty state.</summary>
		public void Clear()
		{
			this._top = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Clone

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> Clone()
		{
			return new OmnitreeBoundsLinked<T, Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(this);
		}

		#endregion

		#region Count

		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}
		/// <summary>Counts the number of items encapsulated by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}
		/// <summary>Counts the number of items overlapped by a sub space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		/// <returns>The number of items in the provided sub space.</returns>
		public int CountSubSpaceOverlapped(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}

		internal int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		internal int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		internal int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
		{
			// adjust min/max values
			int count = 0;
			if (EncapsulationCheck(bounds, node.Bounds))
				count += node.Count;
			else if (!node.PointOfDivision.HasValue)
			{
				for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
					if (spatialCheck(bounds, GetBoundings(list.Value)))
						count++;
			}
			else
			{
				Node branch = node as Node;
				if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
				{
					int child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
					Node child = branch[child_index];
					if (child is not null)
					  count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
				else
				{
					foreach (Node child in node.Children)
						count += this.CountSubSpaceBase(child, bounds, spatialCheck);
				}
			}
			return count;
		}

		#endregion

		#region Update

		/// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
		public void Update()
		{
			this.Update(this._top, 0);
		}

		/// <summary>Recursive version of the Update method.</summary>
		/// <param name="node">The current node of iteration.</param>
		/// <param name="depth">The current depth of iteration.</param>
		internal int Update(Node node, int depth)
		{
			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;

						Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

						if (whereToAdd is null)
							throw new System.Exception("an item was updated outside the range of the omnitree");

						this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Update(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void Update(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		public void Update(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
		}
		/// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		public void Update(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			this.Update(new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7), this._top, 0);
		}
		internal int Update(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Node node, int depth)
		{
			if (!InclusionCheck(bounds, node.Bounds))
				return 0;

			int removals = 0;

			{
				Node branch = node as Node;
				int skipped = 0;
				for (int i = 0; i + skipped < branch.Children.Length; )
				{
					removals += this.Update(branch.Children[i], depth + 1);
					if (branch.Children[i].Count is 0)
						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[branch.Children.Length - skipped];
				Array.Copy(branch.Children, newArray, newArray.Length);
				branch.Children = newArray;

				if (branch.Count < _load && branch.Count != 0)
					ShrinkChild(branch.Parent, branch.Index);
			}

			{
				Node.ValueNode current = node.Head;
				Node.ValueNode previous = null;
				while (current is not null)
				{
					Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> item_bounds = GetBoundings(current.Value);
					if (!this.EncapsulationCheck(node.Bounds, item_bounds))
					{
						removals++;
						T updated = current.Value;
						if (previous is null)
						{
							node.Head = current.Next;
							goto HeadRemoved;
						}
						else
							previous.Next = current.Next;
						Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
						if (whereToAdd is null)
							throw new System.Exception("an item was updates outside the range of the omnitree");
						this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
					}
					previous = current;
				HeadRemoved:
					current = current.Next;
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		#endregion

		#region Remove

		/// <summary>Removes all the items qualified by the delegate.</summary>
		/// <param name="where">The predicate to qualify removals.</param>
		public void Remove(Predicate<T> where)
		{
			this.Remove(this._top, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		/// <summary>Recursive version of the remove method.</summary>
		/// <param name="node">The current node of traversal.</param>
		/// <param name="where">The predicate to qualify removals.</param>
		internal int Remove(Node node, Predicate<T> where)
		{
			int removals = 0;

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.Remove(node.Children[i], where);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			// items
			while (node.Head is not null && where(node.Head.Value))
			{
				node.Head = node.Head.Next;
				removals++;
			}
			if (node.Head is not null)
			{
				Node.ValueNode list = node.Head;
				while (list.Next is not null)
				{
					if (where(list.Next.Value))
					{
						list.Next = list.Next.Next;
						removals++;
					}
				}
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Removes all the items encapsulated in a given space.</summary>
		/// <param name="axis1">The coordinate along the 1D axis.</param>
		/// <param name="axis2">The coordinate along the 2D axis.</param>
		/// <param name="axis3">The coordinate along the 3D axis.</param>
		/// <param name="axis4">The coordinate along the 4D axis.</param>
		/// <param name="axis5">The coordinate along the 5D axis.</param>
		/// <param name="axis6">The coordinate along the 6D axis.</param>
		/// <param name="axis7">The coordinate along the 7D axis.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> axis1, Omnitree.Bound<Axis2> axis2, Omnitree.Bound<Axis3> axis3, Omnitree.Bound<Axis4> axis4, Omnitree.Bound<Axis5> axis5, Omnitree.Bound<Axis6> axis6, Omnitree.Bound<Axis7> axis7)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1, axis2, axis2, axis3, axis3, axis4, axis4, axis5, axis5, axis6, axis6, axis7, axis7));
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		/// <summary>Removes all the items overlapping a given space.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
		{
			int removals = 0;
			if (InclusionCheck(bounds, node.Bounds))
			{
				// items
				Node.ValueNode current_node = node.Head;
				Node.ValueNode previous_node = null;
				while (!(current_node is null))
				{
					Node.ValueNode temp_previous = current_node;
					if (spatialCheck(bounds, GetBoundings(current_node.Value)))
					{
						removals++;
						if (current_node == node.Head)
							node.Head = node.Head.Next;
						else
						{
							previous_node.Next = current_node.Next;
							temp_previous = previous_node;
						}
					}
					previous_node = temp_previous;
					current_node = current_node.Next;
				}

				// children
				if (node.Children is not null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
						removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
						if (node.Children[i].Count is 0)
							node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
						else
							i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < _load && node.Count > 0)
						ShrinkChild(node.Parent, node.Index);
				}
			}
			
			node.Count -= removals;
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveEncapsulated(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
		{
			this.RemoveEncapsulated(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
		}
		internal int RemoveEncapsulated(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
		}
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7, Predicate<T> where)
		{
			this.RemoveOverlapped(this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7), where);
		}
		internal int RemoveOverlapped(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Predicate<T> where)
		{
			int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
			return removals;
		}

		internal int RemoveBase(
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
		{
			if (!InclusionCheck(node.Bounds, bounds))
				return 0;
			int removals = 0;
			
			// items
			Node.ValueNode current = node.Head;
			Node.ValueNode previous = null;
			while (current is not null)
			{
				if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
				{
					removals++;
					if (previous is null)
					{
						node.Head = current.Next;
						goto HeadRemoved;
					}
					else
						previous.Next = current.Next;
				}
				previous = current;
			HeadRemoved:
				current = current.Next;
			}

			// children
			if (node.Children is not null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
					removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
					if (node.Children[i].Count is 0)
						node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					else
						i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				if (node.Count < _load && node.Count != 0)
					ShrinkChild(node.Parent, node.Index);
			}

			node.Count -= removals;
			return removals;
		}

		/// <summary>Tries to remove a value.</summary>
		/// <param name="value">The value to remove.</param>
		/// <returns>True if successful or false if not.</returns>
		public (bool Success, Exception? Exception) TryRemove(T value)
		{
			Remove(value);
			return (true, null);
		}

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal) => Omnitree.Remove(this, removal);

		/// <summary>Removes all instances of a given value.</summary>
		public void Remove(T removal, Func<T, T, bool> equate) => Omnitree.Remove(this, removal, equate);

		/// <summary>Removes all the items in a given space.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <returns>The number of items that were removed.</returns>
		public void RemoveOverlapped(Axis1 axis1
			, Axis2 axis2
			, Axis3 axis3
			, Axis4 axis4
			, Axis5 axis5
			, Axis6 axis6
			, Axis7 axis7
			)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				, axis7, axis7
				);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}
		
		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		/// <param name="where">The equality constraint of the removal.</param>
		public void RemoveOverlapped(Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7, Predicate<T> where)
		{
			this.RemoveOverlapped(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				, axis7, axis7
				, where);
			Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);
		}

		#endregion

		#region Stepper And IEnumerable

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public void Stepper(Action<T> step) =>
			this.Stepper(step, this._top);

		internal void Stepper(Action<T> step, Node node)
		{
			Node.ValueNode list = node.Head;
			while (list is not null)
			{
				step(list.Value);
				list = list.Next;
			}
			if (node.Children is not null)
				foreach (Node child in node.Children)
					this.Stepper(step, child);
		}

		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<T, StepStatus> =>
			StepperBreak(_top, step);

		internal StepStatus StepperBreak<TStep>(Node node, TStep step)
			where TStep : struct, IFunc<T, StepStatus>
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
			{
				if (step.Invoke(list.Value) is Break) return Break;
			}
			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
				{
					if (StepperBreak(child, step) is Break) return Break;
				}
			}
			return Continue;
		}

		/// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
		/// <param name="step">The delegate to perform on every item in the tree.</param>
		public StepStatus Stepper(Func<T, StepStatus> step) =>
			Stepper(step, _top);

		internal StepStatus Stepper(Func<T, StepStatus> step, Node node)
		{
			StepStatus status = StepStatus.Continue;
			
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if ((status = step(list.Value)) != StepStatus.Continue)
					break;
			
			if (node.Children is not null)
				foreach (Node child in node.Children)
					if ((status = Stepper(step, child)) != StepStatus.Continue)
						break;
			
			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void StepperEncapsulated(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void StepperEncapsulated(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal void StepperEncapsulated(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public void StepperOverlapped(Action<T> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal void StepperOverlapped(Action<T> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal void StepperBase(
			Action<T> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
		{
			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)))
					step(list.Value);

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds))
						this.Stepper(step, child);
					else if (InclusionCheck(child.Bounds, bounds))
						this.StepperBase(step, child, bounds, spatialCheck);
			}
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus StepperEncapsulated(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			StepperEncapsulated(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal StepStatus StepperEncapsulated(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.EncapsulationCheck(a, b));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 min1, Axis1 max1, Axis2 min2, Axis2 max2, Axis3 min3, Axis3 max3, Axis4 min4, Axis4 max4, Axis5 min5, Axis5 max5, Axis6 min6, Axis6 max6, Axis7 min7, Axis7 max7) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="min1">The minimum coordinate of the space along the 1 axis.</param>
		/// <param name="max1">The maximum coordinate of the space along the 1 axis.</param>
		/// <param name="min2">The minimum coordinate of the space along the 2 axis.</param>
		/// <param name="max2">The maximum coordinate of the space along the 2 axis.</param>
		/// <param name="min3">The minimum coordinate of the space along the 3 axis.</param>
		/// <param name="max3">The maximum coordinate of the space along the 3 axis.</param>
		/// <param name="min4">The minimum coordinate of the space along the 4 axis.</param>
		/// <param name="max4">The maximum coordinate of the space along the 4 axis.</param>
		/// <param name="min5">The minimum coordinate of the space along the 5 axis.</param>
		/// <param name="max5">The maximum coordinate of the space along the 5 axis.</param>
		/// <param name="min6">The minimum coordinate of the space along the 6 axis.</param>
		/// <param name="max6">The maximum coordinate of the space along the 6 axis.</param>
		/// <param name="min7">The minimum coordinate of the space along the 7 axis.</param>
		/// <param name="max7">The maximum coordinate of the space along the 7 axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1, Omnitree.Bound<Axis2> min2, Omnitree.Bound<Axis2> max2, Omnitree.Bound<Axis3> min3, Omnitree.Bound<Axis3> max3, Omnitree.Bound<Axis4> min4, Omnitree.Bound<Axis4> max4, Omnitree.Bound<Axis5> min5, Omnitree.Bound<Axis5> max5, Omnitree.Bound<Axis6> min6, Omnitree.Bound<Axis6> max6, Omnitree.Bound<Axis7> min7, Omnitree.Bound<Axis7> max7) =>
			StepperOverlapped(step, _top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(min1, max1, min2, max2, min3, max3, min4, max4, min5, max5, min6, max6, min7, max7));

		internal StepStatus StepperOverlapped(Func<T, StepStatus> step, Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds) =>
			StepperBase(step, node, bounds, (a, b) => this.InclusionCheck(a, b));

		internal StepStatus StepperBase(
			Func<T, StepStatus> step,
			Node node,
			Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>> spatialCheck)
		{
			StepStatus status = StepStatus.Continue;

			for (Node.ValueNode list = node.Head; list is not null; list = list.Next)
				if (spatialCheck(bounds, GetBoundings(list.Value)) &&
					(status = step(list.Value)) != StepStatus.Continue)
					break;

			if (node.Children is not null)
			{
				foreach (Node child in node.Children)
					// optimization: stop bounds checking if space encapsulates node
					if (EncapsulationCheck(bounds, child.Bounds) &&
						(status = this.Stepper(step, child)) != StepStatus.Continue)
						break;
					else if (InclusionCheck(child.Bounds, bounds) &&
						(status = this.StepperBase(step, child, bounds, spatialCheck)) != StepStatus.Continue)
						break;
			}

			return status;
		}

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		public void StepperOverlapped(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				, axis7, axis7
			));

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
		/// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
		/// <param name="axis1">The axis of the removal along the  1D axis.</param>
		/// <param name="axis2">The axis of the removal along the  2D axis.</param>
		/// <param name="axis3">The axis of the removal along the  3D axis.</param>
		/// <param name="axis4">The axis of the removal along the  4D axis.</param>
		/// <param name="axis5">The axis of the removal along the  5D axis.</param>
		/// <param name="axis6">The axis of the removal along the  6D axis.</param>
		/// <param name="axis7">The axis of the removal along the  7D axis.</param>
		public StepStatus StepperOverlapped(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3, Axis4 axis4, Axis5 axis5, Axis6 axis6, Axis7 axis7) =>
			StepperOverlapped(step, this._top, new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(axis1, axis1
				, axis2, axis2
				, axis3, axis3
				, axis4, axis4
				, axis5, axis5
				, axis6, axis6
				, axis7, axis7
				));

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		public System.Collections.Generic.IEnumerator<T> GetEnumerator()
		{
			// Note: this can be optimized.
			IList<T> list = new ListLinked<T>();
			Stepper(x => list.Add(x));
			return list.GetEnumerator();
		}

		#endregion

		/// <inheritdoc/>
		public T[] ToArray() => throw new NotImplementedException();

		#region Helpers

		internal bool StraddlesLines(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector) =>
			Omnitree.StraddlesLines(bounds, vector
				, _compare1
				, _compare2
				, _compare3
				, _compare4
				, _compare5
				, _compare6
				, _compare7
				);

		/// <summary>Computes the child index that contains the desired dimensions.</summary>
		/// <param name="pointOfDivision">The point of division to compare against.</param>
		/// <param name="bounds">The dimensions to determine the child index.</param>
		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
		internal int DetermineChildIndex(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> pointOfDivision, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

			int child = 0;
			if (!bounds.Min1.Exists || !(this._compare1(bounds.Min1.Value, pointOfDivision.Axis1) is Less))
				child += 1 << 0;
			if (!bounds.Min2.Exists || !(this._compare2(bounds.Min2.Value, pointOfDivision.Axis2) is Less))
				child += 1 << 1;
			if (!bounds.Min3.Exists || !(this._compare3(bounds.Min3.Value, pointOfDivision.Axis3) is Less))
				child += 1 << 2;
			if (!bounds.Min4.Exists || !(this._compare4(bounds.Min4.Value, pointOfDivision.Axis4) is Less))
				child += 1 << 3;
			if (!bounds.Min5.Exists || !(this._compare5(bounds.Min5.Value, pointOfDivision.Axis5) is Less))
				child += 1 << 4;
			if (!bounds.Min6.Exists || !(this._compare6(bounds.Min6.Value, pointOfDivision.Axis6) is Less))
				child += 1 << 5;
			if (!bounds.Min7.Exists || !(this._compare7(bounds.Min7.Value, pointOfDivision.Axis7) is Less))
				child += 1 << 6;
			return child;
		}

		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
		/// <param name="parent">The parent to shrink a child of.</param>
		/// <param name="child_index">The index of the child to shrink.</param>
		internal void ShrinkChild(Node parent, int child_index)
		{
			Node leaf;
			Node removal = null;
			if (parent is null) // top of tree
			{
				removal = this._top;
				leaf = new Node(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>.None, null, -1);
				this._top = leaf;
			}
			else // non-top branch
			{
				removal = parent[child_index];
				leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
				parent[child_index] = leaf;
			}

			this.Stepper((T step) => { leaf.Add(step); }, removal);
		}

		/// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the reduction.</param>
		/// <param name="reduction">The amount to reduce the parent counts by.</param>
		internal void ReduceParentCounts(Node parent, int reduction)
		{
			IncreaseParentCounts(parent, -reduction);
		}

		/// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
		/// <param name="parent">The starting parent of the increase.</param>
		/// <param name="increase">The amount to increase the parent counts by.</param>
		internal void IncreaseParentCounts(Node parent, int increase)
		{
			Node node = parent;
			while (node is not null)
			{
				node.Count += increase;
				node = node.Parent;
			}
		}

		/// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
		/// <returns>True if the spaces overlap; False if not.</returns>
		internal bool InclusionCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.InclusionCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks if a space encapsulates a point.</summary>
		/// <returns>True if the space encapsulates the point; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> vector) =>
			Omnitree.EncapsulationCheck(bounds, vector
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks if a space (left) encapsulates another space (right).</summary>
		/// <returns>True if the left space encapsulates the right; False if not.</returns>
		internal bool EncapsulationCheck(Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.EncapsulationCheck(a, b
			, _compare1
			, _compare2
			, _compare3
			, _compare4
			, _compare5
			, _compare6
			, _compare7
			);

		/// <summary>Checks for equality between two locations.</summary>
		/// <returns>True if equal; False if not;</returns>
		internal bool EqualsCheck(Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> a, Omnitree.Vector<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> b) =>
			Omnitree.EqualsCheck(a, b
			, (a, b) => _compare1(a, b) is Equal
			, (a, b) => _compare2(a, b) is Equal
			, (a, b) => _compare3(a, b) is Equal
			, (a, b) => _compare4(a, b) is Equal
			, (a, b) => _compare5(a, b) is Equal
			, (a, b) => _compare6(a, b) is Equal
			, (a, b) => _compare7(a, b) is Equal
			);

		/// <summary>Gets the nearest parent that encapsulates a location.</summary>
		/// <param name="node">The starting node to find the encapsulating parent of the location.</param>
		/// <param name="bounds">The bounds to get the encapsulating parent from.</param>
		/// <returns>The nearest node that encapsulates the given location.</returns>
		internal Node GetEncapsulationParent(Node node, Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> bounds)
		{
			while (node is not null && !EncapsulationCheck(node.Bounds, bounds))
			{
				node = node.Parent;
			}
			return node;
		}

		internal Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7> GetBoundings(T value)
		{
			Omnitree.Bound<Axis1> min1; Omnitree.Bound<Axis1> max1;
			Omnitree.Bound<Axis2> min2; Omnitree.Bound<Axis2> max2;
			Omnitree.Bound<Axis3> min3; Omnitree.Bound<Axis3> max3;
			Omnitree.Bound<Axis4> min4; Omnitree.Bound<Axis4> max4;
			Omnitree.Bound<Axis5> min5; Omnitree.Bound<Axis5> max5;
			Omnitree.Bound<Axis6> min6; Omnitree.Bound<Axis6> max6;
			Omnitree.Bound<Axis7> min7; Omnitree.Bound<Axis7> max7;
			this._getBounds(value,
				out min1, out max1
,
				out min2, out max2
,
				out min3, out max3
,
				out min4, out max4
,
				out min5, out max5
,
				out min6, out max6
,
				out min7, out max7
				);
			return new Omnitree.Bounds<Axis1, Axis2, Axis3, Axis4, Axis5, Axis6, Axis7>(
				min1, max1
,
				min2, max2
,
				min3, max3
,
				min4, max4
,
				min5, max5
,
				min6, max6
,
				min7, max7
				);
		}

		#endregion

		#endregion
	}

	#endregion

	#endregion
}

#pragma warning enable
