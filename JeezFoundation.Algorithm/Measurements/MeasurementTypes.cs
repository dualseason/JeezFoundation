//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "MeasurementTypes.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

// Measurement Definitions:
//
//	Acceleration: Length/Time/Time
//	AngularAcceleration: Angle/Time/Time
//	Angle: Angle
//	AngularSpeed: Angle/Time
//	Area: Length*Length
//	AreaDensity: Mass/Length/Length
//	Density: Mass/Length/Length/Length
//	ElectricCharge: ElectricCharge
//	ElectricCurrent: ElectricCharge/Time
//	Energy: Mass*Length*Length/Time/Time
//	Force: Mass*Length/Time/Time
//	Length: Length
//	LinearDensity: Mass/Length
//	LinearMass: Mass*Length
//	LinearMassFlow: Mass*Length/Time
//	Mass: Mass
//	MassRate: Mass/Time
//	Power: Mass*Length*Length/Time/Time/Time
//	Pressure: Mass/Length/Time/Time
//	Speed: Length/Time
//	Tempurature: Tempurature
//	Time: Time
//	TimeArea: Time*Time
//	Volume: Length*Length*Length
//	VolumeRate: Length*Length*Length/Time

#region Operators

// Operators:
//
//	Acceleration * AreaDensity = Pressure
//	Acceleration * LinearMass = Energy
//	Acceleration * LinearMassFlow = Power
//	Acceleration * Mass = Force
//	Acceleration * Time = Speed
//	Acceleration * TimeArea = Length
//	AngularAcceleration * Time = AngularSpeed
//	AngularAcceleration * TimeArea = Angle
//	AngularSpeed * Time = Angle
//	Area * AreaDensity = Mass
//	Area * Density = LinearDensity
//	Area * Length = Volume
//	Area * LinearDensity = LinearMass
//	Area * Pressure = Force
//	Area * Speed = VolumeRate
//	AreaDensity * Acceleration = Pressure
//	AreaDensity * Area = Mass
//	AreaDensity * Length = LinearDensity
//	AreaDensity * Volume = LinearMass
//	AreaDensity * VolumeRate = LinearMassFlow
//	Density * Area = LinearDensity
//	Density * Length = AreaDensity
//	Density * Volume = Mass
//	Density * VolumeRate = MassRate
//	ElectricCurrent * Time = ElectricCharge
//	Force * Length = Energy
//	Force * Speed = Power
//	Force * Time = LinearMassFlow
//	Force * TimeArea = LinearMass
//	Length * Area = Volume
//	Length * AreaDensity = LinearDensity
//	Length * Density = AreaDensity
//	Length * Force = Energy
//	Length * Length = Area
//	Length * LinearDensity = Mass
//	Length * Mass = LinearMass
//	Length * MassRate = LinearMassFlow
//	LinearDensity * Area = LinearMass
//	LinearDensity * Length = Mass
//	LinearDensity * Speed = MassRate
//	LinearMass * Acceleration = Energy
//	LinearMassFlow * Acceleration = Power
//	LinearMassFlow * Speed = Energy
//	LinearMassFlow * Time = LinearMass
//	Mass * Acceleration = Force
//	Mass * Length = LinearMass
//	Mass * Speed = LinearMassFlow
//	MassRate * Length = LinearMassFlow
//	MassRate * Speed = Force
//	MassRate * Time = Mass
//	Power * Time = Energy
//	Pressure * Area = Force
//	Pressure * TimeArea = LinearDensity
//	Pressure * Volume = Energy
//	Pressure * VolumeRate = Power
//	Speed * Area = VolumeRate
//	Speed * Force = Power
//	Speed * LinearDensity = MassRate
//	Speed * LinearMassFlow = Energy
//	Speed * Mass = LinearMassFlow
//	Speed * MassRate = Force
//	Speed * Time = Length
//	Time * Acceleration = Speed
//	Time * AngularAcceleration = AngularSpeed
//	Time * AngularSpeed = Angle
//	Time * ElectricCurrent = ElectricCharge
//	Time * Force = LinearMassFlow
//	Time * LinearMassFlow = LinearMass
//	Time * MassRate = Mass
//	Time * Power = Energy
//	Time * Speed = Length
//	Time * Time = TimeArea
//	Time * VolumeRate = Volume
//	TimeArea * Acceleration = Length
//	TimeArea * AngularAcceleration = Angle
//	TimeArea * Force = LinearMass
//	TimeArea * Pressure = LinearDensity
//	Volume * AreaDensity = LinearMass
//	Volume * Density = Mass
//	Volume * Pressure = Energy
//	VolumeRate * AreaDensity = LinearMassFlow
//	VolumeRate * Density = MassRate
//	VolumeRate * Pressure = Power
//	VolumeRate * Time = Volume
//	Angle / AngularAcceleration = TimeArea
//	Angle / AngularSpeed = Time
//	Angle / Time = AngularSpeed
//	Angle / TimeArea = AngularAcceleration
//	AngularSpeed / AngularAcceleration = Time
//	AngularSpeed / Time = AngularAcceleration
//	Area / Length = Length
//	AreaDensity / Density = Length
//	AreaDensity / Length = Density
//	ElectricCharge / ElectricCurrent = Time
//	ElectricCharge / Time = ElectricCurrent
//	Energy / Acceleration = LinearMass
//	Energy / Force = Length
//	Energy / Length = Force
//	Energy / LinearMass = Acceleration
//	Energy / LinearMassFlow = Speed
//	Energy / Power = Time
//	Energy / Pressure = Volume
//	Energy / Speed = LinearMassFlow
//	Energy / Time = Power
//	Energy / Volume = Pressure
//	Force / Acceleration = Mass
//	Force / Area = Pressure
//	Force / Mass = Acceleration
//	Force / MassRate = Speed
//	Force / Pressure = Area
//	Force / Speed = MassRate
//	Length / Acceleration = TimeArea
//	Length / Speed = Time
//	Length / Time = Speed
//	Length / TimeArea = Acceleration
//	LinearDensity / Area = Density
//	LinearDensity / AreaDensity = Length
//	LinearDensity / Density = Area
//	LinearDensity / Length = AreaDensity
//	LinearDensity / Pressure = TimeArea
//	LinearDensity / TimeArea = Pressure
//	LinearMass / Area = LinearDensity
//	LinearMass / AreaDensity = Volume
//	LinearMass / Force = TimeArea
//	LinearMass / Length = Mass
//	LinearMass / LinearDensity = Area
//	LinearMass / LinearMassFlow = Time
//	LinearMass / Mass = Length
//	LinearMass / Time = LinearMassFlow
//	LinearMass / TimeArea = Force
//	LinearMass / Volume = AreaDensity
//	LinearMassFlow / AreaDensity = VolumeRate
//	LinearMassFlow / Force = Time
//	LinearMassFlow / Length = MassRate
//	LinearMassFlow / Mass = Speed
//	LinearMassFlow / MassRate = Length
//	LinearMassFlow / Speed = Mass
//	LinearMassFlow / Time = Force
//	LinearMassFlow / VolumeRate = AreaDensity
//	Mass / Area = AreaDensity
//	Mass / AreaDensity = Area
//	Mass / Density = Volume
//	Mass / Length = LinearDensity
//	Mass / LinearDensity = Length
//	Mass / MassRate = Time
//	Mass / Time = MassRate
//	Mass / Volume = Density
//	MassRate / Density = VolumeRate
//	MassRate / LinearDensity = Speed
//	MassRate / Speed = LinearDensity
//	MassRate / VolumeRate = Density
//	Power / Acceleration = LinearMassFlow
//	Power / Force = Speed
//	Power / LinearMassFlow = Acceleration
//	Power / Pressure = VolumeRate
//	Power / Speed = Force
//	Power / VolumeRate = Pressure
//	Pressure / Acceleration = AreaDensity
//	Pressure / AreaDensity = Acceleration
//	Speed / Acceleration = Time
//	Speed / Time = Acceleration
//	TimeArea / Time = Time
//	Volume / Area = Length
//	Volume / Length = Area
//	Volume / Time = VolumeRate
//	Volume / VolumeRate = Time
//	VolumeRate / Area = Speed
//	VolumeRate / Speed = Area

#endregion

using System;
using static JeezFoundation.Algorithm.Statics;

namespace JeezFoundation.Algorithm.Measurements
{
	#region Acceleration

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length/Time/Time")]
		public static object Acceleration<T>(T value, object[] units)
		{
			if (units.Length != 3)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Acceleration Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Acceleration Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Acceleration Factory.");
			}
			if (!(units[2] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Acceleration Factory.");
			}
			return new Acceleration<T>(value
				, (Length.Units)units[0]
				, (Time.Units)units[1]
				, (Time.Units)units[2]
				);
		}
	}

	/// <summary>Acceleration measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Acceleration<T>
	{
		internal T _measurement;
		internal Length.Units _LengthUnits1;
		internal Time.Units _TimeUnits2;
		internal Time.Units _TimeUnits3;

		#region Statics

		/// <summary>Converts a Acceleration measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="fromTimeUnits3">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <param name="toTimeUnits3">The desired units of the measurement.</param>
		/// <returns>The Acceleration measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Time.Units fromTimeUnits2
			, Time.Units fromTimeUnits3
			, Length.Units toLengthUnits1
			, Time.Units toTimeUnits2
			, Time.Units toTimeUnits3
			)
		{
			Acceleration<T> measurement = new Acceleration<T>(value
				, fromLengthUnits1
				, fromTimeUnits2
				, fromTimeUnits3
				);
			return measurement[
				 toLengthUnits1
				, toTimeUnits2
				, toTimeUnits3
				];
		}

		/// <summary>Converts a Acceleration measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Acceleration measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AccelerationBaseUnits from,
			MeasurementUnitsSyntaxTypes.AccelerationBaseUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, from._TimeUnits2
			, from._TimeUnits3
			, to._LengthUnits1
			, to._TimeUnits2
			, to._TimeUnits3
			);
		}

		/// <summary>Parses a Acceleration measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Acceleration<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Acceleration<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Acceleration with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Acceleration.</param>
		/// <param name="units">The units of the Acceleration.</param>
		public Acceleration(T measurement, MeasurementUnitsSyntaxTypes.AccelerationBaseUnits units) : this(measurement
			, units._LengthUnits1
			, units._TimeUnits2
			, units._TimeUnits3
			) { }


		/// <summary>Constructs an Acceleration with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Acceleration.</param>
		/// <param name="LengthUnits1">The units of the Acceleration.</param>
		/// <param name="TimeUnits2">The units of the Acceleration.</param>
		/// <param name="TimeUnits3">The units of the Acceleration.</param>
		public Acceleration(T measurement
			, Length.Units LengthUnits1
			, Time.Units TimeUnits2
			, Time.Units TimeUnits3
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
			_TimeUnits2 = TimeUnits2;
			_TimeUnits3 = TimeUnits3;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value, _TimeUnits2, _TimeUnits3];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_LengthUnits1, value, _TimeUnits3];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Time.Units TimeUnits3
		{
			get { return _TimeUnits3; }
			set
			{
				if (value != _TimeUnits3)
				{
					_measurement = this[_LengthUnits1, _TimeUnits2, value];
					_TimeUnits3 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AccelerationBaseUnits units]
		{
			get { return this[units._LengthUnits1, units._TimeUnits2, units._TimeUnits3]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <param name="TimeUnits3">The #3 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1, Time.Units TimeUnits2, Time.Units TimeUnits3]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				if (TimeUnits3 != _TimeUnits3)
				{
					measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//if (TimeUnits3 > _TimeUnits3)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits3][(int)TimeUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Acceleration measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Acceleration measurement.</param>
		public static implicit operator Acceleration<T>((T, MeasurementUnitsSyntaxTypes.AccelerationBaseUnits) valueTuple)
		{
			return new Acceleration<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Acceleration<T> MathBase(Acceleration<T> a, T b, Func<T, T, T> func)
		{
			return new Acceleration<T>(func(a._measurement, b)
				, a._LengthUnits1
				, a._TimeUnits2
				, a._TimeUnits3
			);
		}

		internal static Acceleration<T> MathBase(Acceleration<T> a, Acceleration<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[LengthUnits1, TimeUnits2, TimeUnits3];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			T C = func(A, B);
			return new Acceleration<T>(C, LengthUnits1, TimeUnits2, TimeUnits3);
		}

		internal static bool LogicBase(Acceleration<T> a, Acceleration<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[LengthUnits1, TimeUnits2, TimeUnits3];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Acceleration measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Acceleration<T> Add(Acceleration<T> a, Acceleration<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Acceleration measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Acceleration<T> operator +(Acceleration<T> a, Acceleration<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Acceleration measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Acceleration<T> Add(Acceleration<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Acceleration measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Acceleration<T> Subtract(Acceleration<T> a, Acceleration<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Acceleration measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Acceleration<T> operator -(Acceleration<T> a, Acceleration<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Acceleration measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Acceleration<T> Subtract(Acceleration<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
		/// <param name="a">The Acceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Acceleration<T> Multiply(Acceleration<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
		/// <param name="a">The Acceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Acceleration<T> Multiply(T b, Acceleration<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
		/// <param name="a">The Acceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Acceleration<T> operator *(Acceleration<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
		/// <param name="a">The Acceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Acceleration<T> operator *(T b, Acceleration<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Acceleration by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Acceleration<T> Add(T b)
		{
			return this * b;
		}

		#region Acceleration<T> * AreaDensity<T> = Pressure<T>

		/// <summary>Mulitplies Acceleration by AreaDensity resulting in Pressure.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public static Pressure<T> Multiply(Acceleration<T> a, AreaDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._TimeUnits2, a._TimeUnits3];
			T B = b[b._MassUnits1, LengthUnits1, b._LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new Pressure<T>(C
				, b._MassUnits1
				, b._LengthUnits3
				, a._TimeUnits2
				, a._TimeUnits3
				);
		}

		/// <summary>Mulitplies Acceleration by AreaDensity resulting in Pressure.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public static Pressure<T> operator *(Acceleration<T> a, AreaDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by AreaDensity resulting in Pressure.</summary>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public Pressure<T> Multiply(AreaDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Acceleration<T> * LinearMass<T> = Energy<T>

		/// <summary>Mulitplies Acceleration by LinearMass resulting in Energy.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The LinearMass to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Acceleration<T> a, LinearMass<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2, a._TimeUnits3];
			T B = b[b._MassUnits1, b._LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._LengthUnits2
				, a._TimeUnits2
				, a._TimeUnits3
				);
		}

		/// <summary>Mulitplies Acceleration by LinearMass resulting in Energy.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The LinearMass to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Acceleration<T> a, LinearMass<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by LinearMass resulting in Energy.</summary>
		/// <param name="b">The LinearMass to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(LinearMass<T> b)
		{
			return this * b;
		}

		#endregion

		#region Acceleration<T> * LinearMassFlow<T> = Power<T>

		/// <summary>Mulitplies Acceleration by LinearMassFlow resulting in Power.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(Acceleration<T> a, LinearMassFlow<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2, a._TimeUnits3];
			T B = b[b._MassUnits1, b._LengthUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._LengthUnits2
				, a._TimeUnits2
				, a._TimeUnits3
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies Acceleration by LinearMassFlow resulting in Power.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(Acceleration<T> a, LinearMassFlow<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by LinearMassFlow resulting in Power.</summary>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(LinearMassFlow<T> b)
		{
			return this * b;
		}

		#endregion

		#region Acceleration<T> * Mass<T> = Force<T>

		/// <summary>Mulitplies Acceleration by Mass resulting in Force.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(Acceleration<T> a, Mass<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2, a._TimeUnits3];
			T B = b[b._MassUnits1];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, a._TimeUnits2
				, a._TimeUnits3
				);
		}

		/// <summary>Mulitplies Acceleration by Mass resulting in Force.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(Acceleration<T> a, Mass<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by Mass resulting in Force.</summary>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(Mass<T> b)
		{
			return this * b;
		}

		#endregion

		#region Acceleration<T> * Time<T> = Speed<T>

		/// <summary>Mulitplies Acceleration by Time resulting in Speed.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public static Speed<T> Multiply(Acceleration<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._LengthUnits1, TimeUnits1, a._TimeUnits3];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Speed<T>(C
				, a._LengthUnits1
				, a._TimeUnits3
				);
		}

		/// <summary>Mulitplies Acceleration by Time resulting in Speed.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public static Speed<T> operator *(Acceleration<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by Time resulting in Speed.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public Speed<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#region Acceleration<T> * TimeArea<T> = Length<T>

		/// <summary>Mulitplies Acceleration by TimeArea resulting in Length.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> Multiply(Acceleration<T> a, TimeArea<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[a._LengthUnits1, TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Length<T>(C
				, a._LengthUnits1
				);
		}

		/// <summary>Mulitplies Acceleration by TimeArea resulting in Length.</summary>
		/// <param name="a">The Acceleration to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> operator *(Acceleration<T> a, TimeArea<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Acceleration by TimeArea resulting in Length.</summary>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public Length<T> Multiply(TimeArea<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Acceleration measurement by another Acceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Acceleration<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[LengthUnits1, TimeUnits2, TimeUnits3];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
		/// <param name="a">The Acceleration measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Acceleration<T> Divide(Acceleration<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
		/// <param name="a">The Acceleration measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Acceleration<T> operator /(Acceleration<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Acceleration measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Acceleration<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Acceleration measurement by another Acceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Acceleration<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Acceleration measurement by another Acceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Acceleration<T> a, Acceleration<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is less than another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Acceleration<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Acceleration<T> a, Acceleration<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is greater than another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Acceleration<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Acceleration<T> a, Acceleration<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is less than or equal to another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Acceleration<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Acceleration<T> a, Acceleration<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is greater than or equal to another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Acceleration<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Acceleration<T> a, Acceleration<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is equal to another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Acceleration<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Acceleration<T> a, Acceleration<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Acceleration<T> a, Acceleration<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Acceleration measurement is not equal to another Acceleration measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Acceleration<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Acceleration<T>)
			{
				return this == (Acceleration<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Acceleration measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1
				+ "/" +
				_TimeUnits2 + "/" + _TimeUnits3
				;
		}

		/// <summary>Base hashing function for Acceleration measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region AngularAcceleration

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Angle/Time/Time")]
		public static object AngularAcceleration<T>(T value, object[] units)
		{
			if (units.Length != 3)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularAcceleration Factory.");
			}
			if (!(units[0] is Angle.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularAcceleration Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularAcceleration Factory.");
			}
			if (!(units[2] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularAcceleration Factory.");
			}
			return new AngularAcceleration<T>(value
				, (Angle.Units)units[0]
				, (Time.Units)units[1]
				, (Time.Units)units[2]
				);
		}
	}

	/// <summary>AngularAcceleration measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct AngularAcceleration<T>
	{
		internal T _measurement;
		internal Angle.Units _AngleUnits1;
		internal Time.Units _TimeUnits2;
		internal Time.Units _TimeUnits3;

		#region Statics

		/// <summary>Converts a AngularAcceleration measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromAngleUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="fromTimeUnits3">The current units of the measurement.</param>
		/// <param name="toAngleUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <param name="toTimeUnits3">The desired units of the measurement.</param>
		/// <returns>The AngularAcceleration measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Angle.Units fromAngleUnits1
			, Time.Units fromTimeUnits2
			, Time.Units fromTimeUnits3
			, Angle.Units toAngleUnits1
			, Time.Units toTimeUnits2
			, Time.Units toTimeUnits3
			)
		{
			AngularAcceleration<T> measurement = new AngularAcceleration<T>(value
				, fromAngleUnits1
				, fromTimeUnits2
				, fromTimeUnits3
				);
			return measurement[
				 toAngleUnits1
				, toTimeUnits2
				, toTimeUnits3
				];
		}

		/// <summary>Converts a AngularAcceleration measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The AngularAcceleration measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AngularAccelerationBaseUnits from,
			MeasurementUnitsSyntaxTypes.AngularAccelerationBaseUnits to)
		{
			return Convert(value
			, from._AngleUnits1
			, from._TimeUnits2
			, from._TimeUnits3
			, to._AngleUnits1
			, to._TimeUnits2
			, to._TimeUnits3
			);
		}

		/// <summary>Parses a AngularAcceleration measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, AngularAcceleration<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, AngularAcceleration<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an AngularAcceleration with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AngularAcceleration.</param>
		/// <param name="units">The units of the AngularAcceleration.</param>
		public AngularAcceleration(T measurement, MeasurementUnitsSyntaxTypes.AngularAccelerationBaseUnits units) : this(measurement
			, units._AngleUnits1
			, units._TimeUnits2
			, units._TimeUnits3
			) { }


		/// <summary>Constructs an AngularAcceleration with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AngularAcceleration.</param>
		/// <param name="AngleUnits1">The units of the AngularAcceleration.</param>
		/// <param name="TimeUnits2">The units of the AngularAcceleration.</param>
		/// <param name="TimeUnits3">The units of the AngularAcceleration.</param>
		public AngularAcceleration(T measurement
			, Angle.Units AngleUnits1
			, Time.Units TimeUnits2
			, Time.Units TimeUnits3
			)
		{
			_measurement = measurement;
			_AngleUnits1 = AngleUnits1;
			_TimeUnits2 = TimeUnits2;
			_TimeUnits3 = TimeUnits3;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Angle.Units AngleUnits1
		{
			get { return _AngleUnits1; }
			set
			{
				if (value != _AngleUnits1)
				{
					_measurement = this[value, _TimeUnits2, _TimeUnits3];
					_AngleUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_AngleUnits1, value, _TimeUnits3];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Time.Units TimeUnits3
		{
			get { return _TimeUnits3; }
			set
			{
				if (value != _TimeUnits3)
				{
					_measurement = this[_AngleUnits1, _TimeUnits2, value];
					_TimeUnits3 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AngularAccelerationBaseUnits units]
		{
			get { return this[units._AngleUnits1, units._TimeUnits2, units._TimeUnits3]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="AngleUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <param name="TimeUnits3">The #3 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Angle.Units AngleUnits1, Time.Units TimeUnits2, Time.Units TimeUnits3]
		{
			get
			{
				T measurement = _measurement;
				if (AngleUnits1 != _AngleUnits1)
				{
					measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//if (AngleUnits1 < _AngleUnits1)
					//{
					//	measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Angle<T>.Table[(int)AngleUnits1][(int)_AngleUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				if (TimeUnits3 != _TimeUnits3)
				{
					measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//if (TimeUnits3 > _TimeUnits3)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits3][(int)TimeUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a AngularAcceleration measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a AngularAcceleration measurement.</param>
		public static implicit operator AngularAcceleration<T>((T, MeasurementUnitsSyntaxTypes.AngularAccelerationBaseUnits) valueTuple)
		{
			return new AngularAcceleration<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static AngularAcceleration<T> MathBase(AngularAcceleration<T> a, T b, Func<T, T, T> func)
		{
			return new AngularAcceleration<T>(func(a._measurement, b)
				, a._AngleUnits1
				, a._TimeUnits2
				, a._TimeUnits3
			);
		}

		internal static AngularAcceleration<T> MathBase(AngularAcceleration<T> a, AngularAcceleration<T> b, Func<T, T, T> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[AngleUnits1, TimeUnits2, TimeUnits3];
			T B = b[AngleUnits1, TimeUnits2, TimeUnits3];
			T C = func(A, B);
			return new AngularAcceleration<T>(C, AngleUnits1, TimeUnits2, TimeUnits3);
		}

		internal static bool LogicBase(AngularAcceleration<T> a, AngularAcceleration<T> b, Func<T, T, bool> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[AngleUnits1, TimeUnits2, TimeUnits3];
			T B = b[AngleUnits1, TimeUnits2, TimeUnits3];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two AngularAcceleration measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AngularAcceleration<T> Add(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two AngularAcceleration measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AngularAcceleration<T> operator +(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two AngularAcceleration measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public AngularAcceleration<T> Add(AngularAcceleration<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two AngularAcceleration measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AngularAcceleration<T> Subtract(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two AngularAcceleration measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AngularAcceleration<T> operator -(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two AngularAcceleration measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public AngularAcceleration<T> Subtract(AngularAcceleration<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
		/// <param name="a">The AngularAcceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularAcceleration<T> Multiply(AngularAcceleration<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
		/// <param name="a">The AngularAcceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularAcceleration<T> Multiply(T b, AngularAcceleration<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
		/// <param name="a">The AngularAcceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularAcceleration<T> operator *(AngularAcceleration<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
		/// <param name="a">The AngularAcceleration measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularAcceleration<T> operator *(T b, AngularAcceleration<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an AngularAcceleration by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public AngularAcceleration<T> Add(T b)
		{
			return this * b;
		}

		#region AngularAcceleration<T> * Time<T> = AngularSpeed<T>

		/// <summary>Mulitplies AngularAcceleration by Time resulting in AngularSpeed.</summary>
		/// <param name="a">The AngularAcceleration to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public static AngularSpeed<T> Multiply(AngularAcceleration<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._AngleUnits1, TimeUnits1, a._TimeUnits3];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new AngularSpeed<T>(C
				, a._AngleUnits1
				, a._TimeUnits3
				);
		}

		/// <summary>Mulitplies AngularAcceleration by Time resulting in AngularSpeed.</summary>
		/// <param name="a">The AngularAcceleration to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public static AngularSpeed<T> operator *(AngularAcceleration<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AngularAcceleration by Time resulting in AngularSpeed.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public AngularSpeed<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#region AngularAcceleration<T> * TimeArea<T> = Angle<T>

		/// <summary>Mulitplies AngularAcceleration by TimeArea resulting in Angle.</summary>
		/// <param name="a">The AngularAcceleration to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> Multiply(AngularAcceleration<T> a, TimeArea<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[a._AngleUnits1, TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Angle<T>(C
				, a._AngleUnits1
				);
		}

		/// <summary>Mulitplies AngularAcceleration by TimeArea resulting in Angle.</summary>
		/// <param name="a">The AngularAcceleration to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> operator *(AngularAcceleration<T> a, TimeArea<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AngularAcceleration by TimeArea resulting in Angle.</summary>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public Angle<T> Multiply(TimeArea<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an AngularAcceleration measurement by another AngularAcceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[AngleUnits1, TimeUnits2, TimeUnits3];
			T B = b[AngleUnits1, TimeUnits2, TimeUnits3];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
		/// <param name="a">The AngularAcceleration measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AngularAcceleration<T> Divide(AngularAcceleration<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
		/// <param name="a">The AngularAcceleration measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AngularAcceleration<T> operator /(AngularAcceleration<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this AngularAcceleration measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public AngularAcceleration<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an AngularAcceleration measurement by another AngularAcceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an AngularAcceleration measurement by another AngularAcceleration measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(AngularAcceleration<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is less than another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(AngularAcceleration<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is greater than another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(AngularAcceleration<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is less than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(AngularAcceleration<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is greater than or equal to another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(AngularAcceleration<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is equal to another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(AngularAcceleration<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(AngularAcceleration<T> a, AngularAcceleration<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an AngularAcceleration measurement is not equal to another AngularAcceleration measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(AngularAcceleration<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is AngularAcceleration<T>)
			{
				return this == (AngularAcceleration<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the AngularAcceleration measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_AngleUnits1
				+ "/" +
				_TimeUnits2 + "/" + _TimeUnits3
				;
		}

		/// <summary>Base hashing function for AngularAcceleration measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Angle

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Angle")]
		public static object Angle<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Angle Factory.");
			}
			if (!(units[0] is Angle.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Angle Factory.");
			}
			return new Angle<T>(value
				, (Angle.Units)units[0]
				);
		}
	}

	/// <summary>Angle measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Angle<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<Angle.Units, T>();
		internal T _measurement;
		internal Angle.Units _AngleUnits1;

		#region Statics

		/// <summary>Converts a Angle measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromAngleUnits1">The current units of the measurement.</param>
		/// <param name="toAngleUnits1">The desired units of the measurement.</param>
		/// <returns>The Angle measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Angle.Units fromAngleUnits1
			, Angle.Units toAngleUnits1
			)
		{
			Angle<T> measurement = new Angle<T>(value
				, fromAngleUnits1
				);
			return measurement[
				 toAngleUnits1
				];
		}

		/// <summary>Converts a Angle measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Angle measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AngleUnits from,
			MeasurementUnitsSyntaxTypes.AngleUnits to)
		{
			return Convert(value
			, from._AngleUnits1
			, to._AngleUnits1
			);
		}

		/// <summary>Parses a Angle measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Angle<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Angle<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Angle with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Angle.</param>
		/// <param name="units">The units of the Angle.</param>
		public Angle(T measurement, MeasurementUnitsSyntaxTypes.AngleUnits units) : this(measurement
			, units._AngleUnits1
			) { }


		/// <summary>Constructs an Angle with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Angle.</param>
		/// <param name="AngleUnits1">The units of the Angle.</param>
		public Angle(T measurement
			, Angle.Units AngleUnits1
			)
		{
			_measurement = measurement;
			_AngleUnits1 = AngleUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Angle.Units AngleUnits1
		{
			get { return _AngleUnits1; }
			set
			{
				if (value != _AngleUnits1)
				{
					_measurement = this[value];
					_AngleUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AngleUnits units]
		{
			get { return this[units._AngleUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="AngleUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Angle.Units AngleUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (AngleUnits1 != _AngleUnits1)
				{
					measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//if (AngleUnits1 < _AngleUnits1)
					//{
					//	measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Angle<T>.Table[(int)AngleUnits1][(int)_AngleUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Angle measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Angle measurement.</param>
		public static implicit operator Angle<T>((T, MeasurementUnitsSyntaxTypes.AngleUnits) valueTuple)
		{
			return new Angle<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Angle<T> MathBase(Angle<T> a, T b, Func<T, T, T> func)
		{
			return new Angle<T>(func(a._measurement, b)
				, a._AngleUnits1
			);
		}

		internal static Angle<T> MathBase(Angle<T> a, Angle<T> b, Func<T, T, T> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			T A = a[AngleUnits1];
			T B = b[AngleUnits1];
			T C = func(A, B);
			return new Angle<T>(C, AngleUnits1);
		}

		internal static bool LogicBase(Angle<T> a, Angle<T> b, Func<T, T, bool> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			T A = a[AngleUnits1];
			T B = b[AngleUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Angle measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Angle<T> Add(Angle<T> a, Angle<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Angle measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Angle<T> operator +(Angle<T> a, Angle<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Angle measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Angle<T> Add(Angle<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Angle measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Angle<T> Subtract(Angle<T> a, Angle<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Angle measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Angle<T> operator -(Angle<T> a, Angle<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Angle measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Angle<T> Subtract(Angle<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Angle by a scalar numeric value.</summary>
		/// <param name="a">The Angle measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Angle<T> Multiply(Angle<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Angle by a scalar numeric value.</summary>
		/// <param name="a">The Angle measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Angle<T> Multiply(T b, Angle<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Angle by a scalar numeric value.</summary>
		/// <param name="a">The Angle measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Angle<T> operator *(Angle<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Angle by a scalar numeric value.</summary>
		/// <param name="a">The Angle measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Angle<T> operator *(T b, Angle<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Angle by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Angle<T> Add(T b)
		{
			return this * b;
		}

		#endregion

		#region Divide

		/// <summary>Divides an Angle measurement by another Angle measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Angle<T> a, Angle<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			T A = a[AngleUnits1];
			T B = b[AngleUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
		/// <param name="a">The Angle measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Angle<T> Divide(Angle<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
		/// <param name="a">The Angle measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Angle<T> operator /(Angle<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Angle measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Angle<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Angle measurement by another Angle measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Angle<T> a, Angle<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Angle measurement by another Angle measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Angle<T> b)
		{
			return this / b;
		}


		#region Angle<T> / AngularAcceleration<T> = TimeArea<T>

		/// <summary>Divides Angle by AngularAcceleration resulting in TimeArea.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> Divide(Angle<T> a, AngularAcceleration<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;

			T A = a[AngleUnits1];
			T B = b[AngleUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Division(A, B);

			return new TimeArea<T>(C
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Divides Angle by AngularAcceleration resulting in TimeArea.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> operator /(Angle<T> a, AngularAcceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Angle by AngularAcceleration resulting in TimeArea.</summary>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public TimeArea<T> Divide(AngularAcceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Angle<T> / AngularSpeed<T> = Time<T>

		/// <summary>Divides Angle by AngularSpeed resulting in Time.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The AngularSpeed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Angle<T> a, AngularSpeed<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;

			T A = a[AngleUnits1];
			T B = b[AngleUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits2
				);
		}

		/// <summary>Divides Angle by AngularSpeed resulting in Time.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The AngularSpeed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Angle<T> a, AngularSpeed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Angle by AngularSpeed resulting in Time.</summary>
		/// <param name="b">The AngularSpeed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(AngularSpeed<T> b)
		{
			return this / b;
		}

		#endregion


		#region Angle<T> / Time<T> = AngularSpeed<T>

		/// <summary>Divides Angle by Time resulting in AngularSpeed.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularSpeed result of the division.</returns>
		public static AngularSpeed<T> Divide(Angle<T> a, Time<T> b)
		{

			T A = a[a._AngleUnits1];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new AngularSpeed<T>(C
				, a._AngleUnits1
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Angle by Time resulting in AngularSpeed.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularSpeed result of the division.</returns>
		public static AngularSpeed<T> operator /(Angle<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Angle by Time resulting in AngularSpeed.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularSpeed result of the division.</returns>
		public AngularSpeed<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region Angle<T> / TimeArea<T> = AngularAcceleration<T>

		/// <summary>Divides Angle by TimeArea resulting in AngularAcceleration.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public static AngularAcceleration<T> Divide(Angle<T> a, TimeArea<T> b)
		{

			T A = a[a._AngleUnits1];
			T B = b[b._TimeUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new AngularAcceleration<T>(C
				, a._AngleUnits1
				, b._TimeUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Divides Angle by TimeArea resulting in AngularAcceleration.</summary>
		/// <param name="a">The Angle to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public static AngularAcceleration<T> operator /(Angle<T> a, TimeArea<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Angle by TimeArea resulting in AngularAcceleration.</summary>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public AngularAcceleration<T> Divide(TimeArea<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Angle<T> a, Angle<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Angle measurement is less than another Angle measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Angle<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Angle<T> a, Angle<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Angle measurement is greater than another Angle measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Angle<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Angle<T> a, Angle<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Angle measurement is less than or equal to another Angle measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Angle<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Angle<T> a, Angle<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Angle measurement is greater than or equal to another Angle measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Angle<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Angle<T> a, Angle<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Angle measurement is equal to another Angle measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Angle<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Angle<T> a, Angle<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Angle<T> a, Angle<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Angle measurement is not equal to another Angle measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Angle<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Angle<T>)
			{
				return this == (Angle<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Angle measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_AngleUnits1
				
				;
		}

		/// <summary>Base hashing function for Angle measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region AngularSpeed

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Angle/Time")]
		public static object AngularSpeed<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularSpeed Factory.");
			}
			if (!(units[0] is Angle.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularSpeed Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AngularSpeed Factory.");
			}
			return new AngularSpeed<T>(value
				, (Angle.Units)units[0]
				, (Time.Units)units[1]
				);
		}
	}

	/// <summary>AngularSpeed measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct AngularSpeed<T>
	{
		internal T _measurement;
		internal Angle.Units _AngleUnits1;
		internal Time.Units _TimeUnits2;

		#region Statics

		/// <summary>Converts a AngularSpeed measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromAngleUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="toAngleUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <returns>The AngularSpeed measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Angle.Units fromAngleUnits1
			, Time.Units fromTimeUnits2
			, Angle.Units toAngleUnits1
			, Time.Units toTimeUnits2
			)
		{
			AngularSpeed<T> measurement = new AngularSpeed<T>(value
				, fromAngleUnits1
				, fromTimeUnits2
				);
			return measurement[
				 toAngleUnits1
				, toTimeUnits2
				];
		}

		/// <summary>Converts a AngularSpeed measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The AngularSpeed measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AngularSpeedBaseUnits from,
			MeasurementUnitsSyntaxTypes.AngularSpeedBaseUnits to)
		{
			return Convert(value
			, from._AngleUnits1
			, from._TimeUnits2
			, to._AngleUnits1
			, to._TimeUnits2
			);
		}

		/// <summary>Parses a AngularSpeed measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, AngularSpeed<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, AngularSpeed<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an AngularSpeed with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AngularSpeed.</param>
		/// <param name="units">The units of the AngularSpeed.</param>
		public AngularSpeed(T measurement, MeasurementUnitsSyntaxTypes.AngularSpeedBaseUnits units) : this(measurement
			, units._AngleUnits1
			, units._TimeUnits2
			) { }


		/// <summary>Constructs an AngularSpeed with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AngularSpeed.</param>
		/// <param name="AngleUnits1">The units of the AngularSpeed.</param>
		/// <param name="TimeUnits2">The units of the AngularSpeed.</param>
		public AngularSpeed(T measurement
			, Angle.Units AngleUnits1
			, Time.Units TimeUnits2
			)
		{
			_measurement = measurement;
			_AngleUnits1 = AngleUnits1;
			_TimeUnits2 = TimeUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Angle.Units AngleUnits1
		{
			get { return _AngleUnits1; }
			set
			{
				if (value != _AngleUnits1)
				{
					_measurement = this[value, _TimeUnits2];
					_AngleUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_AngleUnits1, value];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AngularSpeedBaseUnits units]
		{
			get { return this[units._AngleUnits1, units._TimeUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="AngleUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Angle.Units AngleUnits1, Time.Units TimeUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (AngleUnits1 != _AngleUnits1)
				{
					measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//if (AngleUnits1 < _AngleUnits1)
					//{
					//	measurement = Angle<T>.Table[(int)_AngleUnits1][(int)AngleUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Angle<T>.Table[(int)AngleUnits1][(int)_AngleUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a AngularSpeed measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a AngularSpeed measurement.</param>
		public static implicit operator AngularSpeed<T>((T, MeasurementUnitsSyntaxTypes.AngularSpeedBaseUnits) valueTuple)
		{
			return new AngularSpeed<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static AngularSpeed<T> MathBase(AngularSpeed<T> a, T b, Func<T, T, T> func)
		{
			return new AngularSpeed<T>(func(a._measurement, b)
				, a._AngleUnits1
				, a._TimeUnits2
			);
		}

		internal static AngularSpeed<T> MathBase(AngularSpeed<T> a, AngularSpeed<T> b, Func<T, T, T> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[AngleUnits1, TimeUnits2];
			T B = b[AngleUnits1, TimeUnits2];
			T C = func(A, B);
			return new AngularSpeed<T>(C, AngleUnits1, TimeUnits2);
		}

		internal static bool LogicBase(AngularSpeed<T> a, AngularSpeed<T> b, Func<T, T, bool> func)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[AngleUnits1, TimeUnits2];
			T B = b[AngleUnits1, TimeUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two AngularSpeed measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AngularSpeed<T> Add(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two AngularSpeed measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AngularSpeed<T> operator +(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two AngularSpeed measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public AngularSpeed<T> Add(AngularSpeed<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two AngularSpeed measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AngularSpeed<T> Subtract(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two AngularSpeed measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AngularSpeed<T> operator -(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two AngularSpeed measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public AngularSpeed<T> Subtract(AngularSpeed<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
		/// <param name="a">The AngularSpeed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularSpeed<T> Multiply(AngularSpeed<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
		/// <param name="a">The AngularSpeed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularSpeed<T> Multiply(T b, AngularSpeed<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
		/// <param name="a">The AngularSpeed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularSpeed<T> operator *(AngularSpeed<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
		/// <param name="a">The AngularSpeed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AngularSpeed<T> operator *(T b, AngularSpeed<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an AngularSpeed by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public AngularSpeed<T> Add(T b)
		{
			return this * b;
		}

		#region AngularSpeed<T> * Time<T> = Angle<T>

		/// <summary>Mulitplies AngularSpeed by Time resulting in Angle.</summary>
		/// <param name="a">The AngularSpeed to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> Multiply(AngularSpeed<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._AngleUnits1, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Angle<T>(C
				, a._AngleUnits1
				);
		}

		/// <summary>Mulitplies AngularSpeed by Time resulting in Angle.</summary>
		/// <param name="a">The AngularSpeed to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> operator *(AngularSpeed<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AngularSpeed by Time resulting in Angle.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public Angle<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an AngularSpeed measurement by another AngularSpeed measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[AngleUnits1, TimeUnits2];
			T B = b[AngleUnits1, TimeUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
		/// <param name="a">The AngularSpeed measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AngularSpeed<T> Divide(AngularSpeed<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
		/// <param name="a">The AngularSpeed measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AngularSpeed<T> operator /(AngularSpeed<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this AngularSpeed measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public AngularSpeed<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an AngularSpeed measurement by another AngularSpeed measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an AngularSpeed measurement by another AngularSpeed measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(AngularSpeed<T> b)
		{
			return this / b;
		}


		#region AngularSpeed<T> / AngularAcceleration<T> = Time<T>

		/// <summary>Divides AngularSpeed by AngularAcceleration resulting in Time.</summary>
		/// <param name="a">The AngularSpeed to be divided.</param>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(AngularSpeed<T> a, AngularAcceleration<T> b)
		{
			Angle.Units AngleUnits1 = a._AngleUnits1 <= b._AngleUnits1 ? a._AngleUnits1 : b._AngleUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;

			T A = a[AngleUnits1, TimeUnits2];
			T B = b[AngleUnits1, TimeUnits2, b._TimeUnits3];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits3
				);
		}

		/// <summary>Divides AngularSpeed by AngularAcceleration resulting in Time.</summary>
		/// <param name="a">The AngularSpeed to be divided.</param>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(AngularSpeed<T> a, AngularAcceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides AngularSpeed by AngularAcceleration resulting in Time.</summary>
		/// <param name="b">The AngularAcceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(AngularAcceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region AngularSpeed<T> / Time<T> = AngularAcceleration<T>

		/// <summary>Divides AngularSpeed by Time resulting in AngularAcceleration.</summary>
		/// <param name="a">The AngularSpeed to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public static AngularAcceleration<T> Divide(AngularSpeed<T> a, Time<T> b)
		{

			T A = a[a._AngleUnits1, a._TimeUnits2];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new AngularAcceleration<T>(C
				, a._AngleUnits1
				, a._TimeUnits2
				, b._TimeUnits1
				);
		}

		/// <summary>Divides AngularSpeed by Time resulting in AngularAcceleration.</summary>
		/// <param name="a">The AngularSpeed to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public static AngularAcceleration<T> operator /(AngularSpeed<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides AngularSpeed by Time resulting in AngularAcceleration.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The AngularAcceleration result of the division.</returns>
		public AngularAcceleration<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is less than another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(AngularSpeed<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is greater than another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(AngularSpeed<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is less than or equal to another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(AngularSpeed<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is greater than or equal to another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(AngularSpeed<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is equal to another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(AngularSpeed<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(AngularSpeed<T> a, AngularSpeed<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an AngularSpeed measurement is not equal to another AngularSpeed measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(AngularSpeed<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is AngularSpeed<T>)
			{
				return this == (AngularSpeed<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the AngularSpeed measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_AngleUnits1
				+ "/" +
				_TimeUnits2
				;
		}

		/// <summary>Base hashing function for AngularSpeed measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Area

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length*Length")]
		public static object Area<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Area Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Area Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Area Factory.");
			}
			return new Area<T>(value
				, (Length.Units)units[0]
				, (Length.Units)units[1]
				);
		}
	}

	/// <summary>Area measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Area<T>
	{
		internal T _measurement;
		internal Length.Units _LengthUnits1;
		internal Length.Units _LengthUnits2;

		#region Statics

		/// <summary>Converts a Area measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <returns>The Area measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Length.Units fromLengthUnits2
			, Length.Units toLengthUnits1
			, Length.Units toLengthUnits2
			)
		{
			Area<T> measurement = new Area<T>(value
				, fromLengthUnits1
				, fromLengthUnits2
				);
			return measurement[
				 toLengthUnits1
				, toLengthUnits2
				];
		}

		/// <summary>Converts a Area measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Area measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AreaBaseUnits from,
			MeasurementUnitsSyntaxTypes.AreaBaseUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, from._LengthUnits2
			, to._LengthUnits1
			, to._LengthUnits2
			);
		}

		/// <summary>Parses a Area measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Area<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Area<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Area with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Area.</param>
		/// <param name="units">The units of the Area.</param>
		public Area(T measurement, MeasurementUnitsSyntaxTypes.AreaBaseUnits units) : this(measurement
			, units._LengthUnits1
			, units._LengthUnits2
			) { }


		/// <summary>Constructs an Area with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Area.</param>
		/// <param name="LengthUnits1">The units of the Area.</param>
		/// <param name="LengthUnits2">The units of the Area.</param>
		public Area(T measurement
			, Length.Units LengthUnits1
			, Length.Units LengthUnits2
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
			_LengthUnits2 = LengthUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value, _LengthUnits2];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_LengthUnits1, value];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AreaBaseUnits units]
		{
			get { return this[units._LengthUnits1, units._LengthUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1, Length.Units LengthUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Area measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Area measurement.</param>
		public static implicit operator Area<T>((T, MeasurementUnitsSyntaxTypes.AreaBaseUnits) valueTuple)
		{
			return new Area<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Area<T> MathBase(Area<T> a, T b, Func<T, T, T> func)
		{
			return new Area<T>(func(a._measurement, b)
				, a._LengthUnits1
				, a._LengthUnits2
			);
		}

		internal static Area<T> MathBase(Area<T> a, Area<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2];
			T C = func(A, B);
			return new Area<T>(C, LengthUnits1, LengthUnits2);
		}

		internal static bool LogicBase(Area<T> a, Area<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Area measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Area<T> Add(Area<T> a, Area<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Area measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Area<T> operator +(Area<T> a, Area<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Area measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Area<T> Add(Area<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Area measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Area<T> Subtract(Area<T> a, Area<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Area measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Area<T> operator -(Area<T> a, Area<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Area measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Area<T> Subtract(Area<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Area by a scalar numeric value.</summary>
		/// <param name="a">The Area measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Area<T> Multiply(Area<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Area by a scalar numeric value.</summary>
		/// <param name="a">The Area measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Area<T> Multiply(T b, Area<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Area by a scalar numeric value.</summary>
		/// <param name="a">The Area measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Area<T> operator *(Area<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Area by a scalar numeric value.</summary>
		/// <param name="a">The Area measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Area<T> operator *(T b, Area<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Area by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Area<T> Add(T b)
		{
			return this * b;
		}

		#region Area<T> * AreaDensity<T> = Mass<T>

		/// <summary>Mulitplies Area by AreaDensity resulting in Mass.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(Area<T> a, AreaDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;

			T A = a[LengthUnits1, LengthUnits2];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, b._MassUnits1
				);
		}

		/// <summary>Mulitplies Area by AreaDensity resulting in Mass.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(Area<T> a, AreaDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by AreaDensity resulting in Mass.</summary>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(AreaDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Area<T> * Density<T> = LinearDensity<T>

		/// <summary>Mulitplies Area by Density resulting in LinearDensity.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(Area<T> a, Density<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;

			T A = a[LengthUnits1, LengthUnits2];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2, b._LengthUnits4];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, b._MassUnits1
				, b._LengthUnits4
				);
		}

		/// <summary>Mulitplies Area by Density resulting in LinearDensity.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(Area<T> a, Density<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by Density resulting in LinearDensity.</summary>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(Density<T> b)
		{
			return this * b;
		}

		#endregion

		#region Area<T> * Length<T> = Volume<T>

		/// <summary>Mulitplies Area by Length resulting in Volume.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> Multiply(Area<T> a, Length<T> b)
		{

			T A = a[a._LengthUnits1, a._LengthUnits2];
			T B = b[b._LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new Volume<T>(C
				, a._LengthUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				);
		}

		/// <summary>Mulitplies Area by Length resulting in Volume.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> operator *(Area<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by Length resulting in Volume.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public Volume<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region Area<T> * LinearDensity<T> = LinearMass<T>

		/// <summary>Mulitplies Area by LinearDensity resulting in LinearMass.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Area<T> a, LinearDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._LengthUnits2];
			T B = b[b._MassUnits1, LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, b._MassUnits1
				, a._LengthUnits2
				);
		}

		/// <summary>Mulitplies Area by LinearDensity resulting in LinearMass.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Area<T> a, LinearDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by LinearDensity resulting in LinearMass.</summary>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(LinearDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Area<T> * Pressure<T> = Force<T>

		/// <summary>Mulitplies Area by Pressure resulting in Force.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(Area<T> a, Pressure<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._LengthUnits2];
			T B = b[b._MassUnits1, LengthUnits1, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, b._MassUnits1
				, a._LengthUnits2
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Area by Pressure resulting in Force.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(Area<T> a, Pressure<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by Pressure resulting in Force.</summary>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(Pressure<T> b)
		{
			return this * b;
		}

		#endregion

		#region Area<T> * Speed<T> = VolumeRate<T>

		/// <summary>Mulitplies Area by Speed resulting in VolumeRate.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public static VolumeRate<T> Multiply(Area<T> a, Speed<T> b)
		{

			T A = a[a._LengthUnits1, a._LengthUnits2];
			T B = b[b._LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new VolumeRate<T>(C
				, a._LengthUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies Area by Speed resulting in VolumeRate.</summary>
		/// <param name="a">The Area to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public static VolumeRate<T> operator *(Area<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Area by Speed resulting in VolumeRate.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public VolumeRate<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Area measurement by another Area measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Area<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Area measurement by a numaric scalar value.</summary>
		/// <param name="a">The Area measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Area<T> Divide(Area<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Area measurement by a numaric scalar value.</summary>
		/// <param name="a">The Area measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Area<T> operator /(Area<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Area measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Area<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Area measurement by another Area measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Area<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Area measurement by another Area measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Area<T> b)
		{
			return this / b;
		}


		#region Area<T> / Length<T> = Length<T>

		/// <summary>Divides Area by Length resulting in Length.</summary>
		/// <param name="a">The Area to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(Area<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;

			T A = a[LengthUnits1, a._LengthUnits2];
			T B = b[LengthUnits1];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, a._LengthUnits2
				);
		}

		/// <summary>Divides Area by Length resulting in Length.</summary>
		/// <param name="a">The Area to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(Area<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Area by Length resulting in Length.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Area<T> a, Area<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Area measurement is less than another Area measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Area<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Area<T> a, Area<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Area measurement is greater than another Area measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Area<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Area<T> a, Area<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Area measurement is less than or equal to another Area measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Area<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Area<T> a, Area<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Area measurement is greater than or equal to another Area measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Area<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Area<T> a, Area<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Area measurement is equal to another Area measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Area<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Area<T> a, Area<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Area<T> a, Area<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Area measurement is not equal to another Area measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Area<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Area<T>)
			{
				return this == (Area<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Area measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1 + "*" + _LengthUnits2
				
				;
		}

		/// <summary>Base hashing function for Area measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region AreaDensity

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass/Length/Length")]
		public static object AreaDensity<T>(T value, object[] units)
		{
			if (units.Length != 3)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AreaDensity Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AreaDensity Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AreaDensity Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to AreaDensity Factory.");
			}
			return new AreaDensity<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				);
		}
	}

	/// <summary>AreaDensity measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct AreaDensity<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;

		#region Statics

		/// <summary>Converts a AreaDensity measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <returns>The AreaDensity measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			)
		{
			AreaDensity<T> measurement = new AreaDensity<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toLengthUnits3
				];
		}

		/// <summary>Converts a AreaDensity measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The AreaDensity measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.AreaDensityBaseUnits from,
			MeasurementUnitsSyntaxTypes.AreaDensityBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, to._MassUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			);
		}

		/// <summary>Parses a AreaDensity measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, AreaDensity<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, AreaDensity<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an AreaDensity with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AreaDensity.</param>
		/// <param name="units">The units of the AreaDensity.</param>
		public AreaDensity(T measurement, MeasurementUnitsSyntaxTypes.AreaDensityBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			) { }


		/// <summary>Constructs an AreaDensity with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the AreaDensity.</param>
		/// <param name="MassUnits1">The units of the AreaDensity.</param>
		/// <param name="LengthUnits2">The units of the AreaDensity.</param>
		/// <param name="LengthUnits3">The units of the AreaDensity.</param>
		public AreaDensity(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _LengthUnits3];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.AreaDensityBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._LengthUnits3]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//if (LengthUnits2 > _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//if (LengthUnits3 > _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a AreaDensity measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a AreaDensity measurement.</param>
		public static implicit operator AreaDensity<T>((T, MeasurementUnitsSyntaxTypes.AreaDensityBaseUnits) valueTuple)
		{
			return new AreaDensity<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static AreaDensity<T> MathBase(AreaDensity<T> a, T b, Func<T, T, T> func)
		{
			return new AreaDensity<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
			);
		}

		internal static AreaDensity<T> MathBase(AreaDensity<T> a, AreaDensity<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3];
			T C = func(A, B);
			return new AreaDensity<T>(C, MassUnits1, LengthUnits2, LengthUnits3);
		}

		internal static bool LogicBase(AreaDensity<T> a, AreaDensity<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two AreaDensity measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AreaDensity<T> Add(AreaDensity<T> a, AreaDensity<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two AreaDensity measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static AreaDensity<T> operator +(AreaDensity<T> a, AreaDensity<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two AreaDensity measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public AreaDensity<T> Add(AreaDensity<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two AreaDensity measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AreaDensity<T> Subtract(AreaDensity<T> a, AreaDensity<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two AreaDensity measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static AreaDensity<T> operator -(AreaDensity<T> a, AreaDensity<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two AreaDensity measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public AreaDensity<T> Subtract(AreaDensity<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
		/// <param name="a">The AreaDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AreaDensity<T> Multiply(AreaDensity<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
		/// <param name="a">The AreaDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AreaDensity<T> Multiply(T b, AreaDensity<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
		/// <param name="a">The AreaDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AreaDensity<T> operator *(AreaDensity<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
		/// <param name="a">The AreaDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static AreaDensity<T> operator *(T b, AreaDensity<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an AreaDensity by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public AreaDensity<T> Add(T b)
		{
			return this * b;
		}

		#region AreaDensity<T> * Acceleration<T> = Pressure<T>

		/// <summary>Mulitplies AreaDensity by Acceleration resulting in Pressure.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public static Pressure<T> Multiply(AreaDensity<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3];
			T B = b[LengthUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Pressure<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies AreaDensity by Acceleration resulting in Pressure.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public static Pressure<T> operator *(AreaDensity<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AreaDensity by Acceleration resulting in Pressure.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Pressure result of the multiplication.</returns>
		public Pressure<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region AreaDensity<T> * Area<T> = Mass<T>

		/// <summary>Mulitplies AreaDensity by Area resulting in Mass.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(AreaDensity<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Mulitplies AreaDensity by Area resulting in Mass.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(AreaDensity<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AreaDensity by Area resulting in Mass.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region AreaDensity<T> * Length<T> = LinearDensity<T>

		/// <summary>Mulitplies AreaDensity by Length resulting in LinearDensity.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(AreaDensity<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3];
			T B = b[LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				);
		}

		/// <summary>Mulitplies AreaDensity by Length resulting in LinearDensity.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(AreaDensity<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AreaDensity by Length resulting in LinearDensity.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region AreaDensity<T> * Volume<T> = LinearMass<T>

		/// <summary>Mulitplies AreaDensity by Volume resulting in LinearMass.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(AreaDensity<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2, b._LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, b._LengthUnits3
				);
		}

		/// <summary>Mulitplies AreaDensity by Volume resulting in LinearMass.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(AreaDensity<T> a, Volume<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AreaDensity by Volume resulting in LinearMass.</summary>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Volume<T> b)
		{
			return this * b;
		}

		#endregion

		#region AreaDensity<T> * VolumeRate<T> = LinearMassFlow<T>

		/// <summary>Mulitplies AreaDensity by VolumeRate resulting in LinearMassFlow.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(AreaDensity<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2];
			T B = b[LengthUnits1, LengthUnits2, b._LengthUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, b._LengthUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies AreaDensity by VolumeRate resulting in LinearMassFlow.</summary>
		/// <param name="a">The AreaDensity to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(AreaDensity<T> a, VolumeRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies AreaDensity by VolumeRate resulting in LinearMassFlow.</summary>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(VolumeRate<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an AreaDensity measurement by another AreaDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(AreaDensity<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
		/// <param name="a">The AreaDensity measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AreaDensity<T> Divide(AreaDensity<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
		/// <param name="a">The AreaDensity measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static AreaDensity<T> operator /(AreaDensity<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this AreaDensity measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public AreaDensity<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an AreaDensity measurement by another AreaDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(AreaDensity<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an AreaDensity measurement by another AreaDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(AreaDensity<T> b)
		{
			return this / b;
		}


		#region AreaDensity<T> / Density<T> = Length<T>

		/// <summary>Divides AreaDensity by Density resulting in Length.</summary>
		/// <param name="a">The AreaDensity to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(AreaDensity<T> a, Density<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;

			T A = a[MassUnits1, LengthUnits2, LengthUnits3];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, b._LengthUnits4];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, b._LengthUnits4
				);
		}

		/// <summary>Divides AreaDensity by Density resulting in Length.</summary>
		/// <param name="a">The AreaDensity to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(AreaDensity<T> a, Density<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides AreaDensity by Density resulting in Length.</summary>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(Density<T> b)
		{
			return this / b;
		}

		#endregion


		#region AreaDensity<T> / Length<T> = Density<T>

		/// <summary>Divides AreaDensity by Length resulting in Density.</summary>
		/// <param name="a">The AreaDensity to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> Divide(AreaDensity<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._LengthUnits3];
			T B = b[b._LengthUnits1];
			T C = Statics.Division(A, B);

			return new Density<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, b._LengthUnits1
				);
		}

		/// <summary>Divides AreaDensity by Length resulting in Density.</summary>
		/// <param name="a">The AreaDensity to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> operator /(AreaDensity<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides AreaDensity by Length resulting in Density.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public Density<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is less than another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(AreaDensity<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(AreaDensity<T> a, AreaDensity<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is greater than another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(AreaDensity<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is less than or equal to another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(AreaDensity<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(AreaDensity<T> a, AreaDensity<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is greater than or equal to another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(AreaDensity<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(AreaDensity<T> a, AreaDensity<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is equal to another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(AreaDensity<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(AreaDensity<T> a, AreaDensity<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(AreaDensity<T> a, AreaDensity<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an AreaDensity measurement is not equal to another AreaDensity measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(AreaDensity<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is AreaDensity<T>)
			{
				return this == (AreaDensity<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the AreaDensity measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				+ "/" +
				_LengthUnits2 + "/" + _LengthUnits3
				;
		}

		/// <summary>Base hashing function for AreaDensity measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Density

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass/Length/Length/Length")]
		public static object Density<T>(T value, object[] units)
		{
			if (units.Length != 4)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Density Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Density Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Density Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Density Factory.");
			}
			if (!(units[3] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Density Factory.");
			}
			return new Density<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				, (Length.Units)units[3]
				);
		}
	}

	/// <summary>Density measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Density<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;
		internal Length.Units _LengthUnits4;

		#region Statics

		/// <summary>Converts a Density measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="fromLengthUnits4">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <param name="toLengthUnits4">The desired units of the measurement.</param>
		/// <returns>The Density measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Length.Units fromLengthUnits4
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			, Length.Units toLengthUnits4
			)
		{
			Density<T> measurement = new Density<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				, fromLengthUnits4
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toLengthUnits3
				, toLengthUnits4
				];
		}

		/// <summary>Converts a Density measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Density measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.DensityBaseUnits from,
			MeasurementUnitsSyntaxTypes.DensityBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, from._LengthUnits4
			, to._MassUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			, to._LengthUnits4
			);
		}

		/// <summary>Parses a Density measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Density<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Density<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Density with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Density.</param>
		/// <param name="units">The units of the Density.</param>
		public Density(T measurement, MeasurementUnitsSyntaxTypes.DensityBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			, units._LengthUnits4
			) { }


		/// <summary>Constructs an Density with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Density.</param>
		/// <param name="MassUnits1">The units of the Density.</param>
		/// <param name="LengthUnits2">The units of the Density.</param>
		/// <param name="LengthUnits3">The units of the Density.</param>
		/// <param name="LengthUnits4">The units of the Density.</param>
		public Density(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			, Length.Units LengthUnits4
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
			_LengthUnits4 = LengthUnits4;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3, _LengthUnits4];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _LengthUnits3, _LengthUnits4];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value, _LengthUnits4];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Length.Units LengthUnits4
		{
			get { return _LengthUnits4; }
			set
			{
				if (value != _LengthUnits4)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, value];
					_LengthUnits4 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.DensityBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._LengthUnits3, units._LengthUnits4]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <param name="LengthUnits4">The #4 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Length.Units LengthUnits4]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//if (LengthUnits2 > _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//if (LengthUnits3 > _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				if (LengthUnits4 != _LengthUnits4)
				{
					measurement = Length<T>.Table[(int)LengthUnits4][(int)_LengthUnits4](measurement);
					//if (LengthUnits4 > _LengthUnits4)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits4][(int)LengthUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits4][(int)_LengthUnits4](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Density measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Density measurement.</param>
		public static implicit operator Density<T>((T, MeasurementUnitsSyntaxTypes.DensityBaseUnits) valueTuple)
		{
			return new Density<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Density<T> MathBase(Density<T> a, T b, Func<T, T, T> func)
		{
			return new Density<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._LengthUnits4
			);
		}

		internal static Density<T> MathBase(Density<T> a, Density<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Length.Units LengthUnits4 = a._LengthUnits4 <= b._LengthUnits4 ? a._LengthUnits4 : b._LengthUnits4;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			T C = func(A, B);
			return new Density<T>(C, MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4);
		}

		internal static bool LogicBase(Density<T> a, Density<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Length.Units LengthUnits4 = a._LengthUnits4 <= b._LengthUnits4 ? a._LengthUnits4 : b._LengthUnits4;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Density measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Density<T> Add(Density<T> a, Density<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Density measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Density<T> operator +(Density<T> a, Density<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Density measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Density<T> Add(Density<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Density measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Density<T> Subtract(Density<T> a, Density<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Density measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Density<T> operator -(Density<T> a, Density<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Density measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Density<T> Subtract(Density<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Density by a scalar numeric value.</summary>
		/// <param name="a">The Density measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Density<T> Multiply(Density<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Density by a scalar numeric value.</summary>
		/// <param name="a">The Density measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Density<T> Multiply(T b, Density<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Density by a scalar numeric value.</summary>
		/// <param name="a">The Density measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Density<T> operator *(Density<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Density by a scalar numeric value.</summary>
		/// <param name="a">The Density measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Density<T> operator *(T b, Density<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Density by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Density<T> Add(T b)
		{
			return this * b;
		}

		#region Density<T> * Area<T> = LinearDensity<T>

		/// <summary>Mulitplies Density by Area resulting in LinearDensity.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(Density<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2, a._LengthUnits4];
			T B = b[LengthUnits1, LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits4
				);
		}

		/// <summary>Mulitplies Density by Area resulting in LinearDensity.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(Density<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Density by Area resulting in LinearDensity.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region Density<T> * Length<T> = AreaDensity<T>

		/// <summary>Mulitplies Density by Length resulting in AreaDensity.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public static AreaDensity<T> Multiply(Density<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, a._LengthUnits4];
			T B = b[LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, a._LengthUnits4
				);
		}

		/// <summary>Mulitplies Density by Length resulting in AreaDensity.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public static AreaDensity<T> operator *(Density<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Density by Length resulting in AreaDensity.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public AreaDensity<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region Density<T> * Volume<T> = Mass<T>

		/// <summary>Mulitplies Density by Volume resulting in Mass.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(Density<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits4 <= b._LengthUnits3 ? a._LengthUnits4 : b._LengthUnits3;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Mulitplies Density by Volume resulting in Mass.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(Density<T> a, Volume<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Density by Volume resulting in Mass.</summary>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(Volume<T> b)
		{
			return this * b;
		}

		#endregion

		#region Density<T> * VolumeRate<T> = MassRate<T>

		/// <summary>Mulitplies Density by VolumeRate resulting in MassRate.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> Multiply(Density<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits4 <= b._LengthUnits3 ? a._LengthUnits4 : b._LengthUnits3;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new MassRate<T>(C
				, a._MassUnits1
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Density by VolumeRate resulting in MassRate.</summary>
		/// <param name="a">The Density to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> operator *(Density<T> a, VolumeRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Density by VolumeRate resulting in MassRate.</summary>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public MassRate<T> Multiply(VolumeRate<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Density measurement by another Density measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Density<T> a, Density<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Length.Units LengthUnits4 = a._LengthUnits4 <= b._LengthUnits4 ? a._LengthUnits4 : b._LengthUnits4;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, LengthUnits4];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Density measurement by a numaric scalar value.</summary>
		/// <param name="a">The Density measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Density<T> Divide(Density<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Density measurement by a numaric scalar value.</summary>
		/// <param name="a">The Density measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Density<T> operator /(Density<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Density measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Density<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Density measurement by another Density measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Density<T> a, Density<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Density measurement by another Density measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Density<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Density<T> a, Density<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Density measurement is less than another Density measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Density<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Density<T> a, Density<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Density measurement is greater than another Density measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Density<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Density<T> a, Density<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Density measurement is less than or equal to another Density measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Density<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Density<T> a, Density<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Density measurement is greater than or equal to another Density measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Density<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Density<T> a, Density<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Density measurement is equal to another Density measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Density<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Density<T> a, Density<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Density<T> a, Density<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Density measurement is not equal to another Density measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Density<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Density<T>)
			{
				return this == (Density<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Density measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				+ "/" +
				_LengthUnits2 + "/" + _LengthUnits3 + "/" + _LengthUnits4
				;
		}

		/// <summary>Base hashing function for Density measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region ElectricCharge

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("ElectricCharge")]
		public static object ElectricCharge<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to ElectricCharge Factory.");
			}
			if (!(units[0] is ElectricCharge.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to ElectricCharge Factory.");
			}
			return new ElectricCharge<T>(value
				, (ElectricCharge.Units)units[0]
				);
		}
	}

	/// <summary>ElectricCharge measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct ElectricCharge<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<ElectricCharge.Units, T>();
		internal T _measurement;
		internal ElectricCharge.Units _ElectricChargeUnits1;

		#region Statics

		/// <summary>Converts a ElectricCharge measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromElectricChargeUnits1">The current units of the measurement.</param>
		/// <param name="toElectricChargeUnits1">The desired units of the measurement.</param>
		/// <returns>The ElectricCharge measurement converted into the desired units.</returns>
		public static T Convert(T value
			, ElectricCharge.Units fromElectricChargeUnits1
			, ElectricCharge.Units toElectricChargeUnits1
			)
		{
			ElectricCharge<T> measurement = new ElectricCharge<T>(value
				, fromElectricChargeUnits1
				);
			return measurement[
				 toElectricChargeUnits1
				];
		}

		/// <summary>Converts a ElectricCharge measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The ElectricCharge measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.ElectricChargeUnits from,
			MeasurementUnitsSyntaxTypes.ElectricChargeUnits to)
		{
			return Convert(value
			, from._ElectricChargeUnits1
			, to._ElectricChargeUnits1
			);
		}

		/// <summary>Parses a ElectricCharge measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, ElectricCharge<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, ElectricCharge<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an ElectricCharge with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the ElectricCharge.</param>
		/// <param name="units">The units of the ElectricCharge.</param>
		public ElectricCharge(T measurement, MeasurementUnitsSyntaxTypes.ElectricChargeUnits units) : this(measurement
			, units._ElectricChargeUnits1
			) { }


		/// <summary>Constructs an ElectricCharge with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the ElectricCharge.</param>
		/// <param name="ElectricChargeUnits1">The units of the ElectricCharge.</param>
		public ElectricCharge(T measurement
			, ElectricCharge.Units ElectricChargeUnits1
			)
		{
			_measurement = measurement;
			_ElectricChargeUnits1 = ElectricChargeUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public ElectricCharge.Units ElectricChargeUnits1
		{
			get { return _ElectricChargeUnits1; }
			set
			{
				if (value != _ElectricChargeUnits1)
				{
					_measurement = this[value];
					_ElectricChargeUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.ElectricChargeUnits units]
		{
			get { return this[units._ElectricChargeUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="ElectricChargeUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[ElectricCharge.Units ElectricChargeUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (ElectricChargeUnits1 != _ElectricChargeUnits1)
				{
					measurement = ElectricCharge<T>.Table[(int)_ElectricChargeUnits1][(int)ElectricChargeUnits1](measurement);
					//if (ElectricChargeUnits1 < _ElectricChargeUnits1)
					//{
					//	measurement = ElectricCharge<T>.Table[(int)_ElectricChargeUnits1][(int)ElectricChargeUnits1](measurement);
					//}
					//else
					//{
					//	measurement = ElectricCharge<T>.Table[(int)ElectricChargeUnits1][(int)_ElectricChargeUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a ElectricCharge measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a ElectricCharge measurement.</param>
		public static implicit operator ElectricCharge<T>((T, MeasurementUnitsSyntaxTypes.ElectricChargeUnits) valueTuple)
		{
			return new ElectricCharge<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static ElectricCharge<T> MathBase(ElectricCharge<T> a, T b, Func<T, T, T> func)
		{
			return new ElectricCharge<T>(func(a._measurement, b)
				, a._ElectricChargeUnits1
			);
		}

		internal static ElectricCharge<T> MathBase(ElectricCharge<T> a, ElectricCharge<T> b, Func<T, T, T> func)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			T A = a[ElectricChargeUnits1];
			T B = b[ElectricChargeUnits1];
			T C = func(A, B);
			return new ElectricCharge<T>(C, ElectricChargeUnits1);
		}

		internal static bool LogicBase(ElectricCharge<T> a, ElectricCharge<T> b, Func<T, T, bool> func)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			T A = a[ElectricChargeUnits1];
			T B = b[ElectricChargeUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two ElectricCharge measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static ElectricCharge<T> Add(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two ElectricCharge measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static ElectricCharge<T> operator +(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two ElectricCharge measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public ElectricCharge<T> Add(ElectricCharge<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two ElectricCharge measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static ElectricCharge<T> Subtract(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two ElectricCharge measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static ElectricCharge<T> operator -(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two ElectricCharge measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public ElectricCharge<T> Subtract(ElectricCharge<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCharge measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCharge<T> Multiply(ElectricCharge<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCharge measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCharge<T> Multiply(T b, ElectricCharge<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCharge measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCharge<T> operator *(ElectricCharge<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCharge measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCharge<T> operator *(T b, ElectricCharge<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an ElectricCharge by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public ElectricCharge<T> Add(T b)
		{
			return this * b;
		}

		#endregion

		#region Divide

		/// <summary>Divides an ElectricCharge measurement by another ElectricCharge measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			T A = a[ElectricChargeUnits1];
			T B = b[ElectricChargeUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
		/// <param name="a">The ElectricCharge measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static ElectricCharge<T> Divide(ElectricCharge<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
		/// <param name="a">The ElectricCharge measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static ElectricCharge<T> operator /(ElectricCharge<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this ElectricCharge measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public ElectricCharge<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an ElectricCharge measurement by another ElectricCharge measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an ElectricCharge measurement by another ElectricCharge measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(ElectricCharge<T> b)
		{
			return this / b;
		}


		#region ElectricCharge<T> / ElectricCurrent<T> = Time<T>

		/// <summary>Divides ElectricCharge by ElectricCurrent resulting in Time.</summary>
		/// <param name="a">The ElectricCharge to be divided.</param>
		/// <param name="b">The ElectricCurrent to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(ElectricCharge<T> a, ElectricCurrent<T> b)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;

			T A = a[ElectricChargeUnits1];
			T B = b[ElectricChargeUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits2
				);
		}

		/// <summary>Divides ElectricCharge by ElectricCurrent resulting in Time.</summary>
		/// <param name="a">The ElectricCharge to be divided.</param>
		/// <param name="b">The ElectricCurrent to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(ElectricCharge<T> a, ElectricCurrent<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides ElectricCharge by ElectricCurrent resulting in Time.</summary>
		/// <param name="b">The ElectricCurrent to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(ElectricCurrent<T> b)
		{
			return this / b;
		}

		#endregion


		#region ElectricCharge<T> / Time<T> = ElectricCurrent<T>

		/// <summary>Divides ElectricCharge by Time resulting in ElectricCurrent.</summary>
		/// <param name="a">The ElectricCharge to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The ElectricCurrent result of the division.</returns>
		public static ElectricCurrent<T> Divide(ElectricCharge<T> a, Time<T> b)
		{

			T A = a[a._ElectricChargeUnits1];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new ElectricCurrent<T>(C
				, a._ElectricChargeUnits1
				, b._TimeUnits1
				);
		}

		/// <summary>Divides ElectricCharge by Time resulting in ElectricCurrent.</summary>
		/// <param name="a">The ElectricCharge to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The ElectricCurrent result of the division.</returns>
		public static ElectricCurrent<T> operator /(ElectricCharge<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides ElectricCharge by Time resulting in ElectricCurrent.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The ElectricCurrent result of the division.</returns>
		public ElectricCurrent<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is less than another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(ElectricCharge<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is greater than another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(ElectricCharge<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is less than or equal to another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(ElectricCharge<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is greater than or equal to another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(ElectricCharge<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is equal to another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(ElectricCharge<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(ElectricCharge<T> a, ElectricCharge<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an ElectricCharge measurement is not equal to another ElectricCharge measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(ElectricCharge<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is ElectricCharge<T>)
			{
				return this == (ElectricCharge<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the ElectricCharge measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_ElectricChargeUnits1
				
				;
		}

		/// <summary>Base hashing function for ElectricCharge measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region ElectricCurrent

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("ElectricCharge/Time")]
		public static object ElectricCurrent<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to ElectricCurrent Factory.");
			}
			if (!(units[0] is ElectricCharge.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to ElectricCurrent Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to ElectricCurrent Factory.");
			}
			return new ElectricCurrent<T>(value
				, (ElectricCharge.Units)units[0]
				, (Time.Units)units[1]
				);
		}
	}

	/// <summary>ElectricCurrent measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct ElectricCurrent<T>
	{
		internal T _measurement;
		internal ElectricCharge.Units _ElectricChargeUnits1;
		internal Time.Units _TimeUnits2;

		#region Statics

		/// <summary>Converts a ElectricCurrent measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromElectricChargeUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="toElectricChargeUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <returns>The ElectricCurrent measurement converted into the desired units.</returns>
		public static T Convert(T value
			, ElectricCharge.Units fromElectricChargeUnits1
			, Time.Units fromTimeUnits2
			, ElectricCharge.Units toElectricChargeUnits1
			, Time.Units toTimeUnits2
			)
		{
			ElectricCurrent<T> measurement = new ElectricCurrent<T>(value
				, fromElectricChargeUnits1
				, fromTimeUnits2
				);
			return measurement[
				 toElectricChargeUnits1
				, toTimeUnits2
				];
		}

		/// <summary>Converts a ElectricCurrent measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The ElectricCurrent measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.ElectricCurrentBaseUnits from,
			MeasurementUnitsSyntaxTypes.ElectricCurrentBaseUnits to)
		{
			return Convert(value
			, from._ElectricChargeUnits1
			, from._TimeUnits2
			, to._ElectricChargeUnits1
			, to._TimeUnits2
			);
		}

		/// <summary>Parses a ElectricCurrent measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, ElectricCurrent<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, ElectricCurrent<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an ElectricCurrent with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the ElectricCurrent.</param>
		/// <param name="units">The units of the ElectricCurrent.</param>
		public ElectricCurrent(T measurement, MeasurementUnitsSyntaxTypes.ElectricCurrentBaseUnits units) : this(measurement
			, units._ElectricChargeUnits1
			, units._TimeUnits2
			) { }


		/// <summary>Constructs an ElectricCurrent with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the ElectricCurrent.</param>
		/// <param name="ElectricChargeUnits1">The units of the ElectricCurrent.</param>
		/// <param name="TimeUnits2">The units of the ElectricCurrent.</param>
		public ElectricCurrent(T measurement
			, ElectricCharge.Units ElectricChargeUnits1
			, Time.Units TimeUnits2
			)
		{
			_measurement = measurement;
			_ElectricChargeUnits1 = ElectricChargeUnits1;
			_TimeUnits2 = TimeUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public ElectricCharge.Units ElectricChargeUnits1
		{
			get { return _ElectricChargeUnits1; }
			set
			{
				if (value != _ElectricChargeUnits1)
				{
					_measurement = this[value, _TimeUnits2];
					_ElectricChargeUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_ElectricChargeUnits1, value];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.ElectricCurrentBaseUnits units]
		{
			get { return this[units._ElectricChargeUnits1, units._TimeUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="ElectricChargeUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[ElectricCharge.Units ElectricChargeUnits1, Time.Units TimeUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (ElectricChargeUnits1 != _ElectricChargeUnits1)
				{
					measurement = ElectricCharge<T>.Table[(int)_ElectricChargeUnits1][(int)ElectricChargeUnits1](measurement);
					//if (ElectricChargeUnits1 < _ElectricChargeUnits1)
					//{
					//	measurement = ElectricCharge<T>.Table[(int)_ElectricChargeUnits1][(int)ElectricChargeUnits1](measurement);
					//}
					//else
					//{
					//	measurement = ElectricCharge<T>.Table[(int)ElectricChargeUnits1][(int)_ElectricChargeUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a ElectricCurrent measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a ElectricCurrent measurement.</param>
		public static implicit operator ElectricCurrent<T>((T, MeasurementUnitsSyntaxTypes.ElectricCurrentBaseUnits) valueTuple)
		{
			return new ElectricCurrent<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static ElectricCurrent<T> MathBase(ElectricCurrent<T> a, T b, Func<T, T, T> func)
		{
			return new ElectricCurrent<T>(func(a._measurement, b)
				, a._ElectricChargeUnits1
				, a._TimeUnits2
			);
		}

		internal static ElectricCurrent<T> MathBase(ElectricCurrent<T> a, ElectricCurrent<T> b, Func<T, T, T> func)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[ElectricChargeUnits1, TimeUnits2];
			T B = b[ElectricChargeUnits1, TimeUnits2];
			T C = func(A, B);
			return new ElectricCurrent<T>(C, ElectricChargeUnits1, TimeUnits2);
		}

		internal static bool LogicBase(ElectricCurrent<T> a, ElectricCurrent<T> b, Func<T, T, bool> func)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[ElectricChargeUnits1, TimeUnits2];
			T B = b[ElectricChargeUnits1, TimeUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two ElectricCurrent measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static ElectricCurrent<T> Add(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two ElectricCurrent measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static ElectricCurrent<T> operator +(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two ElectricCurrent measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public ElectricCurrent<T> Add(ElectricCurrent<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two ElectricCurrent measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static ElectricCurrent<T> Subtract(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two ElectricCurrent measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static ElectricCurrent<T> operator -(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two ElectricCurrent measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public ElectricCurrent<T> Subtract(ElectricCurrent<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCurrent measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCurrent<T> Multiply(ElectricCurrent<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCurrent measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCurrent<T> Multiply(T b, ElectricCurrent<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCurrent measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCurrent<T> operator *(ElectricCurrent<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
		/// <param name="a">The ElectricCurrent measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static ElectricCurrent<T> operator *(T b, ElectricCurrent<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an ElectricCurrent by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public ElectricCurrent<T> Add(T b)
		{
			return this * b;
		}

		#region ElectricCurrent<T> * Time<T> = ElectricCharge<T>

		/// <summary>Mulitplies ElectricCurrent by Time resulting in ElectricCharge.</summary>
		/// <param name="a">The ElectricCurrent to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public static ElectricCharge<T> Multiply(ElectricCurrent<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._ElectricChargeUnits1, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new ElectricCharge<T>(C
				, a._ElectricChargeUnits1
				);
		}

		/// <summary>Mulitplies ElectricCurrent by Time resulting in ElectricCharge.</summary>
		/// <param name="a">The ElectricCurrent to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public static ElectricCharge<T> operator *(ElectricCurrent<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies ElectricCurrent by Time resulting in ElectricCharge.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public ElectricCharge<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an ElectricCurrent measurement by another ElectricCurrent measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			ElectricCharge.Units ElectricChargeUnits1 = a._ElectricChargeUnits1 <= b._ElectricChargeUnits1 ? a._ElectricChargeUnits1 : b._ElectricChargeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[ElectricChargeUnits1, TimeUnits2];
			T B = b[ElectricChargeUnits1, TimeUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
		/// <param name="a">The ElectricCurrent measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static ElectricCurrent<T> Divide(ElectricCurrent<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
		/// <param name="a">The ElectricCurrent measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static ElectricCurrent<T> operator /(ElectricCurrent<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this ElectricCurrent measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public ElectricCurrent<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an ElectricCurrent measurement by another ElectricCurrent measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an ElectricCurrent measurement by another ElectricCurrent measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(ElectricCurrent<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is less than another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(ElectricCurrent<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is greater than another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(ElectricCurrent<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is less than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(ElectricCurrent<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is greater than or equal to another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(ElectricCurrent<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is equal to another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(ElectricCurrent<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(ElectricCurrent<T> a, ElectricCurrent<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an ElectricCurrent measurement is not equal to another ElectricCurrent measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(ElectricCurrent<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is ElectricCurrent<T>)
			{
				return this == (ElectricCurrent<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the ElectricCurrent measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_ElectricChargeUnits1
				+ "/" +
				_TimeUnits2
				;
		}

		/// <summary>Base hashing function for ElectricCurrent measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Energy

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass*Length*Length/Time/Time")]
		public static object Energy<T>(T value, object[] units)
		{
			if (units.Length != 5)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			if (!(units[3] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			if (!(units[4] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Energy Factory.");
			}
			return new Energy<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				, (Time.Units)units[3]
				, (Time.Units)units[4]
				);
		}
	}

	/// <summary>Energy measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Energy<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;
		internal Time.Units _TimeUnits4;
		internal Time.Units _TimeUnits5;

		#region Statics

		/// <summary>Converts a Energy measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="fromTimeUnits4">The current units of the measurement.</param>
		/// <param name="fromTimeUnits5">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <param name="toTimeUnits4">The desired units of the measurement.</param>
		/// <param name="toTimeUnits5">The desired units of the measurement.</param>
		/// <returns>The Energy measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Time.Units fromTimeUnits4
			, Time.Units fromTimeUnits5
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			, Time.Units toTimeUnits4
			, Time.Units toTimeUnits5
			)
		{
			Energy<T> measurement = new Energy<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				, fromTimeUnits4
				, fromTimeUnits5
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toLengthUnits3
				, toTimeUnits4
				, toTimeUnits5
				];
		}

		/// <summary>Converts a Energy measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Energy measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.EnergyBaseUnits from,
			MeasurementUnitsSyntaxTypes.EnergyBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, from._TimeUnits4
			, from._TimeUnits5
			, to._MassUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			, to._TimeUnits4
			, to._TimeUnits5
			);
		}

		/// <summary>Parses a Energy measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Energy<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Energy<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Energy with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Energy.</param>
		/// <param name="units">The units of the Energy.</param>
		public Energy(T measurement, MeasurementUnitsSyntaxTypes.EnergyBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			, units._TimeUnits4
			, units._TimeUnits5
			) { }


		/// <summary>Constructs an Energy with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Energy.</param>
		/// <param name="MassUnits1">The units of the Energy.</param>
		/// <param name="LengthUnits2">The units of the Energy.</param>
		/// <param name="LengthUnits3">The units of the Energy.</param>
		/// <param name="TimeUnits4">The units of the Energy.</param>
		/// <param name="TimeUnits5">The units of the Energy.</param>
		public Energy(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			, Time.Units TimeUnits4
			, Time.Units TimeUnits5
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
			_TimeUnits4 = TimeUnits4;
			_TimeUnits5 = TimeUnits5;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3, _TimeUnits4, _TimeUnits5];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _LengthUnits3, _TimeUnits4, _TimeUnits5];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value, _TimeUnits4, _TimeUnits5];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Time.Units TimeUnits4
		{
			get { return _TimeUnits4; }
			set
			{
				if (value != _TimeUnits4)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, value, _TimeUnits5];
					_TimeUnits4 = value;
				}
			}
		}

		/// <summary>The #5 component of this measurements units.</summary>
		public Time.Units TimeUnits5
		{
			get { return _TimeUnits5; }
			set
			{
				if (value != _TimeUnits5)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, _TimeUnits4, value];
					_TimeUnits5 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.EnergyBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._LengthUnits3, units._TimeUnits4, units._TimeUnits5]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <param name="TimeUnits4">The #4 component of this measurements units.</param>
		/// <param name="TimeUnits5">The #5 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4, Time.Units TimeUnits5]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//if (LengthUnits3 < _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				if (TimeUnits4 != _TimeUnits4)
				{
					measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//if (TimeUnits4 > _TimeUnits4)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits4][(int)TimeUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//}
				}
				if (TimeUnits5 != _TimeUnits5)
				{
					measurement = Time<T>.Table[(int)TimeUnits5][(int)_TimeUnits5](measurement);
					//if (TimeUnits5 > _TimeUnits5)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits5][(int)TimeUnits5](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits5][(int)_TimeUnits5](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Energy measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Energy measurement.</param>
		public static implicit operator Energy<T>((T, MeasurementUnitsSyntaxTypes.EnergyBaseUnits) valueTuple)
		{
			return new Energy<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Energy<T> MathBase(Energy<T> a, T b, Func<T, T, T> func)
		{
			return new Energy<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
			);
		}

		internal static Energy<T> MathBase(Energy<T> a, Energy<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			T C = func(A, B);
			return new Energy<T>(C, MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5);
		}

		internal static bool LogicBase(Energy<T> a, Energy<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Energy measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Energy<T> Add(Energy<T> a, Energy<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Energy measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Energy<T> operator +(Energy<T> a, Energy<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Energy measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Energy<T> Add(Energy<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Energy measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Energy<T> Subtract(Energy<T> a, Energy<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Energy measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Energy<T> operator -(Energy<T> a, Energy<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Energy measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Energy<T> Subtract(Energy<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Energy by a scalar numeric value.</summary>
		/// <param name="a">The Energy measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Energy<T> Multiply(Energy<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Energy by a scalar numeric value.</summary>
		/// <param name="a">The Energy measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Energy<T> Multiply(T b, Energy<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Energy by a scalar numeric value.</summary>
		/// <param name="a">The Energy measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Energy<T> operator *(Energy<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Energy by a scalar numeric value.</summary>
		/// <param name="a">The Energy measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Energy<T> operator *(T b, Energy<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Energy by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Energy<T> Add(T b)
		{
			return this * b;
		}

		#endregion

		#region Divide

		/// <summary>Divides an Energy measurement by another Energy measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Energy<T> a, Energy<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Energy measurement by a numaric scalar value.</summary>
		/// <param name="a">The Energy measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Energy<T> Divide(Energy<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Energy measurement by a numaric scalar value.</summary>
		/// <param name="a">The Energy measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Energy<T> operator /(Energy<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Energy measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Energy<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Energy measurement by another Energy measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Energy<T> a, Energy<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Energy measurement by another Energy measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Energy<T> b)
		{
			return this / b;
		}


		#region Energy<T> / Acceleration<T> = LinearMass<T>

		/// <summary>Divides Energy by Acceleration resulting in LinearMass.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMass result of the division.</returns>
		public static LinearMass<T> Divide(Energy<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits5 <= b._TimeUnits3 ? a._TimeUnits5 : b._TimeUnits3;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, TimeUnits2, TimeUnits3];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				);
		}

		/// <summary>Divides Energy by Acceleration resulting in LinearMass.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMass result of the division.</returns>
		public static LinearMass<T> operator /(Energy<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Acceleration resulting in LinearMass.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMass result of the division.</returns>
		public LinearMass<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Force<T> = Length<T>

		/// <summary>Divides Energy by Force resulting in Length.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(Energy<T> a, Force<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits5 <= b._TimeUnits4 ? a._TimeUnits5 : b._TimeUnits4;

			T A = a[MassUnits1, LengthUnits2, a._LengthUnits3, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, a._LengthUnits3
				);
		}

		/// <summary>Divides Energy by Force resulting in Length.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(Energy<T> a, Force<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Force resulting in Length.</summary>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(Force<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Length<T> = Force<T>

		/// <summary>Divides Energy by Length resulting in Force.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> Divide(Energy<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, a._TimeUnits4, a._TimeUnits5];
			T B = b[LengthUnits1];
			T C = Statics.Division(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
				);
		}

		/// <summary>Divides Energy by Length resulting in Force.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> operator /(Energy<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Length resulting in Force.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public Force<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / LinearMass<T> = Acceleration<T>

		/// <summary>Divides Energy by LinearMass resulting in Acceleration.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The LinearMass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Energy<T> a, LinearMass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2, a._LengthUnits3, a._TimeUnits4, a._TimeUnits5];
			T B = b[MassUnits1, LengthUnits2];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, a._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
				);
		}

		/// <summary>Divides Energy by LinearMass resulting in Acceleration.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The LinearMass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Energy<T> a, LinearMass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by LinearMass resulting in Acceleration.</summary>
		/// <param name="b">The LinearMass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(LinearMass<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / LinearMassFlow<T> = Speed<T>

		/// <summary>Divides Energy by LinearMassFlow resulting in Speed.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(Energy<T> a, LinearMassFlow<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;

			T A = a[MassUnits1, LengthUnits2, a._LengthUnits3, TimeUnits3, a._TimeUnits5];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits3
				, a._TimeUnits5
				);
		}

		/// <summary>Divides Energy by LinearMassFlow resulting in Speed.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(Energy<T> a, LinearMassFlow<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by LinearMassFlow resulting in Speed.</summary>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(LinearMassFlow<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Power<T> = Time<T>

		/// <summary>Divides Energy by Power resulting in Time.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Power to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Energy<T> a, Power<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;

			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, b._TimeUnits6];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits6
				);
		}

		/// <summary>Divides Energy by Power resulting in Time.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Power to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Energy<T> a, Power<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Power resulting in Time.</summary>
		/// <param name="b">The Power to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(Power<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Pressure<T> = Volume<T>

		/// <summary>Divides Energy by Pressure resulting in Volume.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> Divide(Energy<T> a, Pressure<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;
			Time.Units TimeUnits3 = a._TimeUnits5 <= b._TimeUnits4 ? a._TimeUnits5 : b._TimeUnits4;

			T A = a[MassUnits1, a._LengthUnits2, a._LengthUnits3, TimeUnits2, TimeUnits3];
			T B = b[MassUnits1, b._LengthUnits2, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Volume<T>(C
				, a._LengthUnits2
				, a._LengthUnits3
				, b._LengthUnits2
				);
		}

		/// <summary>Divides Energy by Pressure resulting in Volume.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> operator /(Energy<T> a, Pressure<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Pressure resulting in Volume.</summary>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public Volume<T> Divide(Pressure<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Speed<T> = LinearMassFlow<T>

		/// <summary>Divides Energy by Speed resulting in LinearMassFlow.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> Divide(Energy<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, TimeUnits2, a._TimeUnits5];
			T B = b[LengthUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, a._TimeUnits5
				);
		}

		/// <summary>Divides Energy by Speed resulting in LinearMassFlow.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> operator /(Energy<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Speed resulting in LinearMassFlow.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public LinearMassFlow<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Time<T> = Power<T>

		/// <summary>Divides Energy by Time resulting in Power.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Power result of the division.</returns>
		public static Power<T> Divide(Energy<T> a, Time<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._LengthUnits3, a._TimeUnits4, a._TimeUnits5];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new Power<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Energy by Time resulting in Power.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Power result of the division.</returns>
		public static Power<T> operator /(Energy<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Time resulting in Power.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Power result of the division.</returns>
		public Power<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region Energy<T> / Volume<T> = Pressure<T>

		/// <summary>Divides Energy by Volume resulting in Pressure.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> Divide(Energy<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2, a._TimeUnits4, a._TimeUnits5];
			T B = b[LengthUnits1, LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Pressure<T>(C
				, a._MassUnits1
				, b._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
				);
		}

		/// <summary>Divides Energy by Volume resulting in Pressure.</summary>
		/// <param name="a">The Energy to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> operator /(Energy<T> a, Volume<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Energy by Volume resulting in Pressure.</summary>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public Pressure<T> Divide(Volume<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Energy measurement is less than another Energy measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Energy measurement is less than another Energy measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Energy<T> a, Energy<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Energy measurement is less than another Energy measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Energy<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Energy measurement is greater than another Energy measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Energy measurement is greater than another Energy measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Energy<T> a, Energy<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Energy measurement is greater than another Energy measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Energy<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Energy measurement is less than or equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Energy measurement is less than or equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Energy<T> a, Energy<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Energy measurement is less than or equal to another Energy measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Energy<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Energy measurement is greater than or equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Energy measurement is greater than or equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Energy<T> a, Energy<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Energy measurement is greater than or equal to another Energy measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Energy<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Energy measurement is equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Energy measurement is equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Energy<T> a, Energy<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Energy measurement is equal to another Energy measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Energy<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Energy measurement is not equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Energy<T> a, Energy<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Energy measurement is not equal to another Energy measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Energy<T> a, Energy<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Energy measurement is not equal to another Energy measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Energy<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Energy<T>)
			{
				return this == (Energy<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Energy measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1 + "*" + _LengthUnits2 + "*" + _LengthUnits3
				+ "/" +
				_TimeUnits4 + "/" + _TimeUnits5
				;
		}

		/// <summary>Base hashing function for Energy measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Force

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass*Length/Time/Time")]
		public static object Force<T>(T value, object[] units)
		{
			if (units.Length != 4)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Force Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Force Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Force Factory.");
			}
			if (!(units[2] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Force Factory.");
			}
			if (!(units[3] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Force Factory.");
			}
			return new Force<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Time.Units)units[2]
				, (Time.Units)units[3]
				);
		}
	}

	/// <summary>Force measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Force<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Time.Units _TimeUnits3;
		internal Time.Units _TimeUnits4;

		#region Statics

		/// <summary>Converts a Force measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromTimeUnits3">The current units of the measurement.</param>
		/// <param name="fromTimeUnits4">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toTimeUnits3">The desired units of the measurement.</param>
		/// <param name="toTimeUnits4">The desired units of the measurement.</param>
		/// <returns>The Force measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Time.Units fromTimeUnits3
			, Time.Units fromTimeUnits4
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Time.Units toTimeUnits3
			, Time.Units toTimeUnits4
			)
		{
			Force<T> measurement = new Force<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromTimeUnits3
				, fromTimeUnits4
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toTimeUnits3
				, toTimeUnits4
				];
		}

		/// <summary>Converts a Force measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Force measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.ForceBaseUnits from,
			MeasurementUnitsSyntaxTypes.ForceBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._TimeUnits3
			, from._TimeUnits4
			, to._MassUnits1
			, to._LengthUnits2
			, to._TimeUnits3
			, to._TimeUnits4
			);
		}

		/// <summary>Parses a Force measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Force<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Force<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Force with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Force.</param>
		/// <param name="units">The units of the Force.</param>
		public Force(T measurement, MeasurementUnitsSyntaxTypes.ForceBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._TimeUnits3
			, units._TimeUnits4
			) { }


		/// <summary>Constructs an Force with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Force.</param>
		/// <param name="MassUnits1">The units of the Force.</param>
		/// <param name="LengthUnits2">The units of the Force.</param>
		/// <param name="TimeUnits3">The units of the Force.</param>
		/// <param name="TimeUnits4">The units of the Force.</param>
		public Force(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Time.Units TimeUnits3
			, Time.Units TimeUnits4
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_TimeUnits3 = TimeUnits3;
			_TimeUnits4 = TimeUnits4;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _TimeUnits3, _TimeUnits4];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _TimeUnits3, _TimeUnits4];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Time.Units TimeUnits3
		{
			get { return _TimeUnits3; }
			set
			{
				if (value != _TimeUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value, _TimeUnits4];
					_TimeUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Time.Units TimeUnits4
		{
			get { return _TimeUnits4; }
			set
			{
				if (value != _TimeUnits4)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _TimeUnits3, value];
					_TimeUnits4 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.ForceBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._TimeUnits3, units._TimeUnits4]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="TimeUnits3">The #3 component of this measurements units.</param>
		/// <param name="TimeUnits4">The #4 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3, Time.Units TimeUnits4]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (TimeUnits3 != _TimeUnits3)
				{
					measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//if (TimeUnits3 > _TimeUnits3)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits3][(int)TimeUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//}
				}
				if (TimeUnits4 != _TimeUnits4)
				{
					measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//if (TimeUnits4 > _TimeUnits4)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits4][(int)TimeUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Force measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Force measurement.</param>
		public static implicit operator Force<T>((T, MeasurementUnitsSyntaxTypes.ForceBaseUnits) valueTuple)
		{
			return new Force<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Force<T> MathBase(Force<T> a, T b, Func<T, T, T> func)
		{
			return new Force<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._TimeUnits3
				, a._TimeUnits4
			);
		}

		internal static Force<T> MathBase(Force<T> a, Force<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T C = func(A, B);
			return new Force<T>(C, MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4);
		}

		internal static bool LogicBase(Force<T> a, Force<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Force measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Force<T> Add(Force<T> a, Force<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Force measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Force<T> operator +(Force<T> a, Force<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Force measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Force<T> Add(Force<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Force measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Force<T> Subtract(Force<T> a, Force<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Force measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Force<T> operator -(Force<T> a, Force<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Force measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Force<T> Subtract(Force<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Force by a scalar numeric value.</summary>
		/// <param name="a">The Force measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Force<T> Multiply(Force<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Force by a scalar numeric value.</summary>
		/// <param name="a">The Force measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Force<T> Multiply(T b, Force<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Force by a scalar numeric value.</summary>
		/// <param name="a">The Force measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Force<T> operator *(Force<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Force by a scalar numeric value.</summary>
		/// <param name="a">The Force measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Force<T> operator *(T b, Force<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Force by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Force<T> Add(T b)
		{
			return this * b;
		}

		#region Force<T> * Length<T> = Energy<T>

		/// <summary>Mulitplies Force by Length resulting in Energy.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Force<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._TimeUnits3, a._TimeUnits4];
			T B = b[b._LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies Force by Length resulting in Energy.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Force<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Force by Length resulting in Energy.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region Force<T> * Speed<T> = Power<T>

		/// <summary>Mulitplies Force by Speed resulting in Power.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(Force<T> a, Speed<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._TimeUnits3, a._TimeUnits4];
			T B = b[b._LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, a._TimeUnits3
				, a._TimeUnits4
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies Force by Speed resulting in Power.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(Force<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Force by Speed resulting in Power.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#region Force<T> * Time<T> = LinearMassFlow<T>

		/// <summary>Mulitplies Force by Time resulting in LinearMassFlow.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(Force<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits3 <= b._TimeUnits1 ? a._TimeUnits3 : b._TimeUnits1;

			T A = a[a._MassUnits1, a._LengthUnits2, TimeUnits1, a._TimeUnits4];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies Force by Time resulting in LinearMassFlow.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(Force<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Force by Time resulting in LinearMassFlow.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#region Force<T> * TimeArea<T> = LinearMass<T>

		/// <summary>Mulitplies Force by TimeArea resulting in LinearMass.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Force<T> a, TimeArea<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits3 <= b._TimeUnits1 ? a._TimeUnits3 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;

			T A = a[a._MassUnits1, a._LengthUnits2, TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				);
		}

		/// <summary>Mulitplies Force by TimeArea resulting in LinearMass.</summary>
		/// <param name="a">The Force to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Force<T> a, TimeArea<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Force by TimeArea resulting in LinearMass.</summary>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(TimeArea<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Force measurement by another Force measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Force<T> a, Force<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Force measurement by a numaric scalar value.</summary>
		/// <param name="a">The Force measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Force<T> Divide(Force<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Force measurement by a numaric scalar value.</summary>
		/// <param name="a">The Force measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Force<T> operator /(Force<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Force measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Force<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Force measurement by another Force measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Force<T> a, Force<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Force measurement by another Force measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Force<T> b)
		{
			return this / b;
		}


		#region Force<T> / Acceleration<T> = Mass<T>

		/// <summary>Divides Force by Acceleration resulting in Mass.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> Divide(Force<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;

			T A = a[a._MassUnits1, LengthUnits1, TimeUnits2, TimeUnits3];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Divides Force by Acceleration resulting in Mass.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> operator /(Force<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by Acceleration resulting in Mass.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public Mass<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Force<T> / Area<T> = Pressure<T>

		/// <summary>Divides Force by Area resulting in Pressure.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> Divide(Force<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._TimeUnits3, a._TimeUnits4];
			T B = b[LengthUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new Pressure<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Divides Force by Area resulting in Pressure.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> operator /(Force<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by Area resulting in Pressure.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public Pressure<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region Force<T> / Mass<T> = Acceleration<T>

		/// <summary>Divides Force by Mass resulting in Acceleration.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Force<T> a, Mass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2, a._TimeUnits3, a._TimeUnits4];
			T B = b[MassUnits1];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, a._LengthUnits2
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Divides Force by Mass resulting in Acceleration.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Force<T> a, Mass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by Mass resulting in Acceleration.</summary>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(Mass<T> b)
		{
			return this / b;
		}

		#endregion


		#region Force<T> / MassRate<T> = Speed<T>

		/// <summary>Divides Force by MassRate resulting in Speed.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(Force<T> a, MassRate<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[MassUnits1, a._LengthUnits2, TimeUnits2, a._TimeUnits4];
			T B = b[MassUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits2
				, a._TimeUnits4
				);
		}

		/// <summary>Divides Force by MassRate resulting in Speed.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(Force<T> a, MassRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by MassRate resulting in Speed.</summary>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(MassRate<T> b)
		{
			return this / b;
		}

		#endregion


		#region Force<T> / Pressure<T> = Area<T>

		/// <summary>Divides Force by Pressure resulting in Area.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(Force<T> a, Pressure<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;

			T A = a[MassUnits1, a._LengthUnits2, TimeUnits2, TimeUnits3];
			T B = b[MassUnits1, b._LengthUnits2, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, a._LengthUnits2
				, b._LengthUnits2
				);
		}

		/// <summary>Divides Force by Pressure resulting in Area.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(Force<T> a, Pressure<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by Pressure resulting in Area.</summary>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(Pressure<T> b)
		{
			return this / b;
		}

		#endregion


		#region Force<T> / Speed<T> = MassRate<T>

		/// <summary>Divides Force by Speed resulting in MassRate.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> Divide(Force<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[a._MassUnits1, LengthUnits1, TimeUnits2, a._TimeUnits4];
			T B = b[LengthUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new MassRate<T>(C
				, a._MassUnits1
				, a._TimeUnits4
				);
		}

		/// <summary>Divides Force by Speed resulting in MassRate.</summary>
		/// <param name="a">The Force to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> operator /(Force<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Force by Speed resulting in MassRate.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public MassRate<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Force<T> a, Force<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Force measurement is less than another Force measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Force<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Force<T> a, Force<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Force measurement is greater than another Force measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Force<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Force<T> a, Force<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Force measurement is less than or equal to another Force measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Force<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Force<T> a, Force<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Force measurement is greater than or equal to another Force measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Force<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Force<T> a, Force<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Force measurement is equal to another Force measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Force<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Force<T> a, Force<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Force<T> a, Force<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Force measurement is not equal to another Force measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Force<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Force<T>)
			{
				return this == (Force<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Force measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1 + "*" + _LengthUnits2
				+ "/" +
				_TimeUnits3 + "/" + _TimeUnits4
				;
		}

		/// <summary>Base hashing function for Force measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Length

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length")]
		public static object Length<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Length Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Length Factory.");
			}
			return new Length<T>(value
				, (Length.Units)units[0]
				);
		}
	}

	/// <summary>Length measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Length<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<Length.Units, T>();
		internal T _measurement;
		internal Length.Units _LengthUnits1;

		#region Statics

		/// <summary>Converts a Length measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <returns>The Length measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Length.Units toLengthUnits1
			)
		{
			Length<T> measurement = new Length<T>(value
				, fromLengthUnits1
				);
			return measurement[
				 toLengthUnits1
				];
		}

		/// <summary>Converts a Length measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Length measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.LengthUnits from,
			MeasurementUnitsSyntaxTypes.LengthUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, to._LengthUnits1
			);
		}

		/// <summary>Parses a Length measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Length<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Length<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Length with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Length.</param>
		/// <param name="units">The units of the Length.</param>
		public Length(T measurement, MeasurementUnitsSyntaxTypes.LengthUnits units) : this(measurement
			, units._LengthUnits1
			) { }


		/// <summary>Constructs an Length with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Length.</param>
		/// <param name="LengthUnits1">The units of the Length.</param>
		public Length(T measurement
			, Length.Units LengthUnits1
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.LengthUnits units]
		{
			get { return this[units._LengthUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Length measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Length measurement.</param>
		public static implicit operator Length<T>((T, MeasurementUnitsSyntaxTypes.LengthUnits) valueTuple)
		{
			return new Length<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Length<T> MathBase(Length<T> a, T b, Func<T, T, T> func)
		{
			return new Length<T>(func(a._measurement, b)
				, a._LengthUnits1
			);
		}

		internal static Length<T> MathBase(Length<T> a, Length<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			T A = a[LengthUnits1];
			T B = b[LengthUnits1];
			T C = func(A, B);
			return new Length<T>(C, LengthUnits1);
		}

		internal static bool LogicBase(Length<T> a, Length<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			T A = a[LengthUnits1];
			T B = b[LengthUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Length measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Length<T> Add(Length<T> a, Length<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Length measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Length<T> operator +(Length<T> a, Length<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Length measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Length<T> Add(Length<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Length measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Length<T> Subtract(Length<T> a, Length<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Length measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Length<T> operator -(Length<T> a, Length<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Length measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Length<T> Subtract(Length<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Length by a scalar numeric value.</summary>
		/// <param name="a">The Length measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Length<T> Multiply(Length<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Length by a scalar numeric value.</summary>
		/// <param name="a">The Length measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Length<T> Multiply(T b, Length<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Length by a scalar numeric value.</summary>
		/// <param name="a">The Length measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Length<T> operator *(Length<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Length by a scalar numeric value.</summary>
		/// <param name="a">The Length measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Length<T> operator *(T b, Length<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Length by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Length<T> Add(T b)
		{
			return this * b;
		}

		#region Length<T> * Area<T> = Volume<T>

		/// <summary>Mulitplies Length by Area resulting in Volume.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> Multiply(Length<T> a, Area<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._LengthUnits1, b._LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new Volume<T>(C
				, a._LengthUnits1
				, b._LengthUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Mulitplies Length by Area resulting in Volume.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> operator *(Length<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by Area resulting in Volume.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public Volume<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * AreaDensity<T> = LinearDensity<T>

		/// <summary>Mulitplies Length by AreaDensity resulting in LinearDensity.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(Length<T> a, AreaDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1];
			T B = b[b._MassUnits1, LengthUnits1, b._LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, b._MassUnits1
				, b._LengthUnits3
				);
		}

		/// <summary>Mulitplies Length by AreaDensity resulting in LinearDensity.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(Length<T> a, AreaDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by AreaDensity resulting in LinearDensity.</summary>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(AreaDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * Density<T> = AreaDensity<T>

		/// <summary>Mulitplies Length by Density resulting in AreaDensity.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public static AreaDensity<T> Multiply(Length<T> a, Density<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1];
			T B = b[b._MassUnits1, LengthUnits1, b._LengthUnits3, b._LengthUnits4];
			T C = Statics.Multiplication(A, B);

			return new AreaDensity<T>(C
				, b._MassUnits1
				, b._LengthUnits3
				, b._LengthUnits4
				);
		}

		/// <summary>Mulitplies Length by Density resulting in AreaDensity.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public static AreaDensity<T> operator *(Length<T> a, Density<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by Density resulting in AreaDensity.</summary>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The AreaDensity result of the multiplication.</returns>
		public AreaDensity<T> Multiply(Density<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * Force<T> = Energy<T>

		/// <summary>Mulitplies Length by Force resulting in Energy.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Length<T> a, Force<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._MassUnits1, b._LengthUnits2, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._LengthUnits2
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Length by Force resulting in Energy.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Length<T> a, Force<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by Force resulting in Energy.</summary>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Force<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * Length<T> = Area<T>

		/// <summary>Mulitplies Length by Length resulting in Area.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Area result of the multiplication.</returns>
		public static Area<T> Multiply(Length<T> a, Length<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new Area<T>(C
				, a._LengthUnits1
				, b._LengthUnits1
				);
		}

		/// <summary>Mulitplies Length by Length resulting in Area.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Area result of the multiplication.</returns>
		public static Area<T> operator *(Length<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by Length resulting in Area.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Area result of the multiplication.</returns>
		public Area<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * LinearDensity<T> = Mass<T>

		/// <summary>Mulitplies Length by LinearDensity resulting in Mass.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(Length<T> a, LinearDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1];
			T B = b[b._MassUnits1, LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, b._MassUnits1
				);
		}

		/// <summary>Mulitplies Length by LinearDensity resulting in Mass.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(Length<T> a, LinearDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by LinearDensity resulting in Mass.</summary>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(LinearDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * Mass<T> = LinearMass<T>

		/// <summary>Mulitplies Length by Mass resulting in LinearMass.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Length<T> a, Mass<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._MassUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				);
		}

		/// <summary>Mulitplies Length by Mass resulting in LinearMass.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Length<T> a, Mass<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by Mass resulting in LinearMass.</summary>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Mass<T> b)
		{
			return this * b;
		}

		#endregion

		#region Length<T> * MassRate<T> = LinearMassFlow<T>

		/// <summary>Mulitplies Length by MassRate resulting in LinearMassFlow.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(Length<T> a, MassRate<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._MassUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies Length by MassRate resulting in LinearMassFlow.</summary>
		/// <param name="a">The Length to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(Length<T> a, MassRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Length by MassRate resulting in LinearMassFlow.</summary>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(MassRate<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Length measurement by another Length measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Length<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			T A = a[LengthUnits1];
			T B = b[LengthUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Length measurement by a numaric scalar value.</summary>
		/// <param name="a">The Length measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Length<T> Divide(Length<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Length measurement by a numaric scalar value.</summary>
		/// <param name="a">The Length measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Length<T> operator /(Length<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Length measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Length<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Length measurement by another Length measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Length<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Length measurement by another Length measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Length<T> b)
		{
			return this / b;
		}


		#region Length<T> / Acceleration<T> = TimeArea<T>

		/// <summary>Divides Length by Acceleration resulting in TimeArea.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> Divide(Length<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;

			T A = a[LengthUnits1];
			T B = b[LengthUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Division(A, B);

			return new TimeArea<T>(C
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Divides Length by Acceleration resulting in TimeArea.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> operator /(Length<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Length by Acceleration resulting in TimeArea.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public TimeArea<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Length<T> / Speed<T> = Time<T>

		/// <summary>Divides Length by Speed resulting in Time.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Length<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;

			T A = a[LengthUnits1];
			T B = b[LengthUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits2
				);
		}

		/// <summary>Divides Length by Speed resulting in Time.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Length<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Length by Speed resulting in Time.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion


		#region Length<T> / Time<T> = Speed<T>

		/// <summary>Divides Length by Time resulting in Speed.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(Length<T> a, Time<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits1
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Length by Time resulting in Speed.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(Length<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Length by Time resulting in Speed.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region Length<T> / TimeArea<T> = Acceleration<T>

		/// <summary>Divides Length by TimeArea resulting in Acceleration.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Length<T> a, TimeArea<T> b)
		{

			T A = a[a._LengthUnits1];
			T B = b[b._TimeUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, a._LengthUnits1
				, b._TimeUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Divides Length by TimeArea resulting in Acceleration.</summary>
		/// <param name="a">The Length to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Length<T> a, TimeArea<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Length by TimeArea resulting in Acceleration.</summary>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(TimeArea<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Length<T> a, Length<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Length measurement is less than another Length measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Length<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Length<T> a, Length<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Length measurement is greater than another Length measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Length<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Length<T> a, Length<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Length measurement is less than or equal to another Length measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Length<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Length<T> a, Length<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Length measurement is greater than or equal to another Length measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Length<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Length<T> a, Length<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Length measurement is equal to another Length measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Length<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Length<T> a, Length<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Length<T> a, Length<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Length measurement is not equal to another Length measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Length<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Length<T>)
			{
				return this == (Length<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Length measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1
				
				;
		}

		/// <summary>Base hashing function for Length measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region LinearDensity

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass/Length")]
		public static object LinearDensity<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearDensity Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearDensity Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearDensity Factory.");
			}
			return new LinearDensity<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				);
		}
	}

	/// <summary>LinearDensity measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct LinearDensity<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;

		#region Statics

		/// <summary>Converts a LinearDensity measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <returns>The LinearDensity measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			)
		{
			LinearDensity<T> measurement = new LinearDensity<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				];
		}

		/// <summary>Converts a LinearDensity measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The LinearDensity measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.LinearDensityBaseUnits from,
			MeasurementUnitsSyntaxTypes.LinearDensityBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, to._MassUnits1
			, to._LengthUnits2
			);
		}

		/// <summary>Parses a LinearDensity measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, LinearDensity<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, LinearDensity<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an LinearDensity with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearDensity.</param>
		/// <param name="units">The units of the LinearDensity.</param>
		public LinearDensity(T measurement, MeasurementUnitsSyntaxTypes.LinearDensityBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			) { }


		/// <summary>Constructs an LinearDensity with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearDensity.</param>
		/// <param name="MassUnits1">The units of the LinearDensity.</param>
		/// <param name="LengthUnits2">The units of the LinearDensity.</param>
		public LinearDensity(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.LinearDensityBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//if (LengthUnits2 > _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a LinearDensity measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a LinearDensity measurement.</param>
		public static implicit operator LinearDensity<T>((T, MeasurementUnitsSyntaxTypes.LinearDensityBaseUnits) valueTuple)
		{
			return new LinearDensity<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static LinearDensity<T> MathBase(LinearDensity<T> a, T b, Func<T, T, T> func)
		{
			return new LinearDensity<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
			);
		}

		internal static LinearDensity<T> MathBase(LinearDensity<T> a, LinearDensity<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			T C = func(A, B);
			return new LinearDensity<T>(C, MassUnits1, LengthUnits2);
		}

		internal static bool LogicBase(LinearDensity<T> a, LinearDensity<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two LinearDensity measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearDensity<T> Add(LinearDensity<T> a, LinearDensity<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two LinearDensity measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearDensity<T> operator +(LinearDensity<T> a, LinearDensity<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two LinearDensity measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public LinearDensity<T> Add(LinearDensity<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two LinearDensity measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearDensity<T> Subtract(LinearDensity<T> a, LinearDensity<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two LinearDensity measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearDensity<T> operator -(LinearDensity<T> a, LinearDensity<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two LinearDensity measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public LinearDensity<T> Subtract(LinearDensity<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
		/// <param name="a">The LinearDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(LinearDensity<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
		/// <param name="a">The LinearDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(T b, LinearDensity<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
		/// <param name="a">The LinearDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearDensity<T> operator *(LinearDensity<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
		/// <param name="a">The LinearDensity measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearDensity<T> operator *(T b, LinearDensity<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an LinearDensity by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public LinearDensity<T> Add(T b)
		{
			return this * b;
		}

		#region LinearDensity<T> * Area<T> = LinearMass<T>

		/// <summary>Mulitplies LinearDensity by Area resulting in LinearMass.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(LinearDensity<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1, b._LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Mulitplies LinearDensity by Area resulting in LinearMass.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(LinearDensity<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearDensity by Area resulting in LinearMass.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region LinearDensity<T> * Length<T> = Mass<T>

		/// <summary>Mulitplies LinearDensity by Length resulting in Mass.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(LinearDensity<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Mulitplies LinearDensity by Length resulting in Mass.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(LinearDensity<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearDensity by Length resulting in Mass.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region LinearDensity<T> * Speed<T> = MassRate<T>

		/// <summary>Mulitplies LinearDensity by Speed resulting in MassRate.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> Multiply(LinearDensity<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new MassRate<T>(C
				, a._MassUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies LinearDensity by Speed resulting in MassRate.</summary>
		/// <param name="a">The LinearDensity to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> operator *(LinearDensity<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearDensity by Speed resulting in MassRate.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public MassRate<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an LinearDensity measurement by another LinearDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(LinearDensity<T> a, LinearDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearDensity measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearDensity<T> Divide(LinearDensity<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearDensity measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearDensity<T> operator /(LinearDensity<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this LinearDensity measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public LinearDensity<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an LinearDensity measurement by another LinearDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(LinearDensity<T> a, LinearDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an LinearDensity measurement by another LinearDensity measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(LinearDensity<T> b)
		{
			return this / b;
		}


		#region LinearDensity<T> / Area<T> = Density<T>

		/// <summary>Divides LinearDensity by Area resulting in Density.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> Divide(LinearDensity<T> a, Area<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._LengthUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new Density<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Divides LinearDensity by Area resulting in Density.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> operator /(LinearDensity<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by Area resulting in Density.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public Density<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearDensity<T> / AreaDensity<T> = Length<T>

		/// <summary>Divides LinearDensity by AreaDensity resulting in Length.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(LinearDensity<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, b._LengthUnits3
				);
		}

		/// <summary>Divides LinearDensity by AreaDensity resulting in Length.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(LinearDensity<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by AreaDensity resulting in Length.</summary>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(AreaDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearDensity<T> / Density<T> = Area<T>

		/// <summary>Divides LinearDensity by Density resulting in Area.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(LinearDensity<T> a, Density<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2, b._LengthUnits3, b._LengthUnits4];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, b._LengthUnits3
				, b._LengthUnits4
				);
		}

		/// <summary>Divides LinearDensity by Density resulting in Area.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(LinearDensity<T> a, Density<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by Density resulting in Area.</summary>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(Density<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearDensity<T> / Length<T> = AreaDensity<T>

		/// <summary>Divides LinearDensity by Length resulting in AreaDensity.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> Divide(LinearDensity<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._LengthUnits1];
			T C = Statics.Division(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				);
		}

		/// <summary>Divides LinearDensity by Length resulting in AreaDensity.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> operator /(LinearDensity<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by Length resulting in AreaDensity.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public AreaDensity<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearDensity<T> / Pressure<T> = TimeArea<T>

		/// <summary>Divides LinearDensity by Pressure resulting in TimeArea.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> Divide(LinearDensity<T> a, Pressure<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Division(A, B);

			return new TimeArea<T>(C
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Divides LinearDensity by Pressure resulting in TimeArea.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> operator /(LinearDensity<T> a, Pressure<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by Pressure resulting in TimeArea.</summary>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public TimeArea<T> Divide(Pressure<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearDensity<T> / TimeArea<T> = Pressure<T>

		/// <summary>Divides LinearDensity by TimeArea resulting in Pressure.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> Divide(LinearDensity<T> a, TimeArea<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._TimeUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Pressure<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._TimeUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Divides LinearDensity by TimeArea resulting in Pressure.</summary>
		/// <param name="a">The LinearDensity to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> operator /(LinearDensity<T> a, TimeArea<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearDensity by TimeArea resulting in Pressure.</summary>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public Pressure<T> Divide(TimeArea<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is less than another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(LinearDensity<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(LinearDensity<T> a, LinearDensity<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is greater than another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(LinearDensity<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is less than or equal to another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(LinearDensity<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(LinearDensity<T> a, LinearDensity<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is greater than or equal to another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(LinearDensity<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(LinearDensity<T> a, LinearDensity<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is equal to another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(LinearDensity<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(LinearDensity<T> a, LinearDensity<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(LinearDensity<T> a, LinearDensity<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an LinearDensity measurement is not equal to another LinearDensity measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(LinearDensity<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is LinearDensity<T>)
			{
				return this == (LinearDensity<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the LinearDensity measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				+ "/" +
				_LengthUnits2
				;
		}

		/// <summary>Base hashing function for LinearDensity measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region LinearMass

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass*Length")]
		public static object LinearMass<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMass Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMass Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMass Factory.");
			}
			return new LinearMass<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				);
		}
	}

	/// <summary>LinearMass measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct LinearMass<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;

		#region Statics

		/// <summary>Converts a LinearMass measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <returns>The LinearMass measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			)
		{
			LinearMass<T> measurement = new LinearMass<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				];
		}

		/// <summary>Converts a LinearMass measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The LinearMass measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.LinearMassBaseUnits from,
			MeasurementUnitsSyntaxTypes.LinearMassBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, to._MassUnits1
			, to._LengthUnits2
			);
		}

		/// <summary>Parses a LinearMass measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, LinearMass<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, LinearMass<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an LinearMass with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearMass.</param>
		/// <param name="units">The units of the LinearMass.</param>
		public LinearMass(T measurement, MeasurementUnitsSyntaxTypes.LinearMassBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			) { }


		/// <summary>Constructs an LinearMass with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearMass.</param>
		/// <param name="MassUnits1">The units of the LinearMass.</param>
		/// <param name="LengthUnits2">The units of the LinearMass.</param>
		public LinearMass(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.LinearMassBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a LinearMass measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a LinearMass measurement.</param>
		public static implicit operator LinearMass<T>((T, MeasurementUnitsSyntaxTypes.LinearMassBaseUnits) valueTuple)
		{
			return new LinearMass<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static LinearMass<T> MathBase(LinearMass<T> a, T b, Func<T, T, T> func)
		{
			return new LinearMass<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
			);
		}

		internal static LinearMass<T> MathBase(LinearMass<T> a, LinearMass<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			T C = func(A, B);
			return new LinearMass<T>(C, MassUnits1, LengthUnits2);
		}

		internal static bool LogicBase(LinearMass<T> a, LinearMass<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two LinearMass measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearMass<T> Add(LinearMass<T> a, LinearMass<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two LinearMass measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearMass<T> operator +(LinearMass<T> a, LinearMass<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two LinearMass measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public LinearMass<T> Add(LinearMass<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two LinearMass measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearMass<T> Subtract(LinearMass<T> a, LinearMass<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two LinearMass measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearMass<T> operator -(LinearMass<T> a, LinearMass<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two LinearMass measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public LinearMass<T> Subtract(LinearMass<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
		/// <param name="a">The LinearMass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMass<T> Multiply(LinearMass<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
		/// <param name="a">The LinearMass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMass<T> Multiply(T b, LinearMass<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
		/// <param name="a">The LinearMass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMass<T> operator *(LinearMass<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
		/// <param name="a">The LinearMass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMass<T> operator *(T b, LinearMass<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an LinearMass by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public LinearMass<T> Add(T b)
		{
			return this * b;
		}

		#region LinearMass<T> * Acceleration<T> = Energy<T>

		/// <summary>Mulitplies LinearMass by Acceleration resulting in Energy.</summary>
		/// <param name="a">The LinearMass to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(LinearMass<T> a, Acceleration<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._LengthUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies LinearMass by Acceleration resulting in Energy.</summary>
		/// <param name="a">The LinearMass to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(LinearMass<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearMass by Acceleration resulting in Energy.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an LinearMass measurement by another LinearMass measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(LinearMass<T> a, LinearMass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearMass measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearMass<T> Divide(LinearMass<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearMass measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearMass<T> operator /(LinearMass<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this LinearMass measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public LinearMass<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an LinearMass measurement by another LinearMass measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(LinearMass<T> a, LinearMass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an LinearMass measurement by another LinearMass measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(LinearMass<T> b)
		{
			return this / b;
		}


		#region LinearMass<T> / Area<T> = LinearDensity<T>

		/// <summary>Divides LinearMass by Area resulting in LinearDensity.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> Divide(LinearMass<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Divides LinearMass by Area resulting in LinearDensity.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> operator /(LinearMass<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Area resulting in LinearDensity.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public LinearDensity<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / AreaDensity<T> = Volume<T>

		/// <summary>Divides LinearMass by AreaDensity resulting in Volume.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> Divide(LinearMass<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2];
			T B = b[MassUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Volume<T>(C
				, a._LengthUnits2
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides LinearMass by AreaDensity resulting in Volume.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> operator /(LinearMass<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by AreaDensity resulting in Volume.</summary>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public Volume<T> Divide(AreaDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / Force<T> = TimeArea<T>

		/// <summary>Divides LinearMass by Force resulting in TimeArea.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> Divide(LinearMass<T> a, Force<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Division(A, B);

			return new TimeArea<T>(C
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Divides LinearMass by Force resulting in TimeArea.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public static TimeArea<T> operator /(LinearMass<T> a, Force<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Force resulting in TimeArea.</summary>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The TimeArea result of the division.</returns>
		public TimeArea<T> Divide(Force<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / Length<T> = Mass<T>

		/// <summary>Divides LinearMass by Length resulting in Mass.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> Divide(LinearMass<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1];
			T C = Statics.Division(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Divides LinearMass by Length resulting in Mass.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> operator /(LinearMass<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Length resulting in Mass.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public Mass<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / LinearDensity<T> = Area<T>

		/// <summary>Divides LinearMass by LinearDensity resulting in Area.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(LinearMass<T> a, LinearDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2];
			T B = b[MassUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, a._LengthUnits2
				, b._LengthUnits2
				);
		}

		/// <summary>Divides LinearMass by LinearDensity resulting in Area.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(LinearMass<T> a, LinearDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by LinearDensity resulting in Area.</summary>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(LinearDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / LinearMassFlow<T> = Time<T>

		/// <summary>Divides LinearMass by LinearMassFlow resulting in Time.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(LinearMass<T> a, LinearMassFlow<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2];
			T B = b[MassUnits1, LengthUnits2, b._TimeUnits3];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits3
				);
		}

		/// <summary>Divides LinearMass by LinearMassFlow resulting in Time.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(LinearMass<T> a, LinearMassFlow<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by LinearMassFlow resulting in Time.</summary>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(LinearMassFlow<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / Mass<T> = Length<T>

		/// <summary>Divides LinearMass by Mass resulting in Length.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(LinearMass<T> a, Mass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2];
			T B = b[MassUnits1];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, a._LengthUnits2
				);
		}

		/// <summary>Divides LinearMass by Mass resulting in Length.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(LinearMass<T> a, Mass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Mass resulting in Length.</summary>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(Mass<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / Time<T> = LinearMassFlow<T>

		/// <summary>Divides LinearMass by Time resulting in LinearMassFlow.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> Divide(LinearMass<T> a, Time<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._TimeUnits1
				);
		}

		/// <summary>Divides LinearMass by Time resulting in LinearMassFlow.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> operator /(LinearMass<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Time resulting in LinearMassFlow.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public LinearMassFlow<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / TimeArea<T> = Force<T>

		/// <summary>Divides LinearMass by TimeArea resulting in Force.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> Divide(LinearMass<T> a, TimeArea<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2];
			T B = b[b._TimeUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._TimeUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Divides LinearMass by TimeArea resulting in Force.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> operator /(LinearMass<T> a, TimeArea<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by TimeArea resulting in Force.</summary>
		/// <param name="b">The TimeArea to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public Force<T> Divide(TimeArea<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMass<T> / Volume<T> = AreaDensity<T>

		/// <summary>Divides LinearMass by Volume resulting in AreaDensity.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> Divide(LinearMass<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1];
			T B = b[LengthUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides LinearMass by Volume resulting in AreaDensity.</summary>
		/// <param name="a">The LinearMass to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> operator /(LinearMass<T> a, Volume<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMass by Volume resulting in AreaDensity.</summary>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public AreaDensity<T> Divide(Volume<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(LinearMass<T> a, LinearMass<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is less than another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(LinearMass<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(LinearMass<T> a, LinearMass<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is greater than another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(LinearMass<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(LinearMass<T> a, LinearMass<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is less than or equal to another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(LinearMass<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(LinearMass<T> a, LinearMass<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is greater than or equal to another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(LinearMass<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(LinearMass<T> a, LinearMass<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is equal to another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(LinearMass<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(LinearMass<T> a, LinearMass<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(LinearMass<T> a, LinearMass<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an LinearMass measurement is not equal to another LinearMass measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(LinearMass<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is LinearMass<T>)
			{
				return this == (LinearMass<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the LinearMass measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1 + "*" + _LengthUnits2
				
				;
		}

		/// <summary>Base hashing function for LinearMass measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region LinearMassFlow

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass*Length/Time")]
		public static object LinearMassFlow<T>(T value, object[] units)
		{
			if (units.Length != 3)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMassFlow Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMassFlow Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMassFlow Factory.");
			}
			if (!(units[2] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to LinearMassFlow Factory.");
			}
			return new LinearMassFlow<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Time.Units)units[2]
				);
		}
	}

	/// <summary>LinearMassFlow measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct LinearMassFlow<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Time.Units _TimeUnits3;

		#region Statics

		/// <summary>Converts a LinearMassFlow measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromTimeUnits3">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toTimeUnits3">The desired units of the measurement.</param>
		/// <returns>The LinearMassFlow measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Time.Units fromTimeUnits3
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Time.Units toTimeUnits3
			)
		{
			LinearMassFlow<T> measurement = new LinearMassFlow<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromTimeUnits3
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toTimeUnits3
				];
		}

		/// <summary>Converts a LinearMassFlow measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The LinearMassFlow measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.LinearMassFlowBaseUnits from,
			MeasurementUnitsSyntaxTypes.LinearMassFlowBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._TimeUnits3
			, to._MassUnits1
			, to._LengthUnits2
			, to._TimeUnits3
			);
		}

		/// <summary>Parses a LinearMassFlow measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, LinearMassFlow<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, LinearMassFlow<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an LinearMassFlow with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearMassFlow.</param>
		/// <param name="units">The units of the LinearMassFlow.</param>
		public LinearMassFlow(T measurement, MeasurementUnitsSyntaxTypes.LinearMassFlowBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._TimeUnits3
			) { }


		/// <summary>Constructs an LinearMassFlow with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the LinearMassFlow.</param>
		/// <param name="MassUnits1">The units of the LinearMassFlow.</param>
		/// <param name="LengthUnits2">The units of the LinearMassFlow.</param>
		/// <param name="TimeUnits3">The units of the LinearMassFlow.</param>
		public LinearMassFlow(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Time.Units TimeUnits3
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_TimeUnits3 = TimeUnits3;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _TimeUnits3];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _TimeUnits3];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Time.Units TimeUnits3
		{
			get { return _TimeUnits3; }
			set
			{
				if (value != _TimeUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value];
					_TimeUnits3 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.LinearMassFlowBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._TimeUnits3]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="TimeUnits3">The #3 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (TimeUnits3 != _TimeUnits3)
				{
					measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//if (TimeUnits3 > _TimeUnits3)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits3][(int)TimeUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a LinearMassFlow measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a LinearMassFlow measurement.</param>
		public static implicit operator LinearMassFlow<T>((T, MeasurementUnitsSyntaxTypes.LinearMassFlowBaseUnits) valueTuple)
		{
			return new LinearMassFlow<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static LinearMassFlow<T> MathBase(LinearMassFlow<T> a, T b, Func<T, T, T> func)
		{
			return new LinearMassFlow<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._TimeUnits3
			);
		}

		internal static LinearMassFlow<T> MathBase(LinearMassFlow<T> a, LinearMassFlow<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3];
			T C = func(A, B);
			return new LinearMassFlow<T>(C, MassUnits1, LengthUnits2, TimeUnits3);
		}

		internal static bool LogicBase(LinearMassFlow<T> a, LinearMassFlow<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two LinearMassFlow measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearMassFlow<T> Add(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two LinearMassFlow measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static LinearMassFlow<T> operator +(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two LinearMassFlow measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public LinearMassFlow<T> Add(LinearMassFlow<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two LinearMassFlow measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearMassFlow<T> Subtract(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two LinearMassFlow measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static LinearMassFlow<T> operator -(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two LinearMassFlow measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public LinearMassFlow<T> Subtract(LinearMassFlow<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
		/// <param name="a">The LinearMassFlow measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(LinearMassFlow<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
		/// <param name="a">The LinearMassFlow measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(T b, LinearMassFlow<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
		/// <param name="a">The LinearMassFlow measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(LinearMassFlow<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
		/// <param name="a">The LinearMassFlow measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(T b, LinearMassFlow<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an LinearMassFlow by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public LinearMassFlow<T> Add(T b)
		{
			return this * b;
		}

		#region LinearMassFlow<T> * Acceleration<T> = Power<T>

		/// <summary>Mulitplies LinearMassFlow by Acceleration resulting in Power.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(LinearMassFlow<T> a, Acceleration<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._TimeUnits3];
			T B = b[b._LengthUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, a._TimeUnits3
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies LinearMassFlow by Acceleration resulting in Power.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(LinearMassFlow<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearMassFlow by Acceleration resulting in Power.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region LinearMassFlow<T> * Speed<T> = Energy<T>

		/// <summary>Mulitplies LinearMassFlow by Speed resulting in Energy.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(LinearMassFlow<T> a, Speed<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._TimeUnits3];
			T B = b[b._LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				, a._TimeUnits3
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies LinearMassFlow by Speed resulting in Energy.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(LinearMassFlow<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearMassFlow by Speed resulting in Energy.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#region LinearMassFlow<T> * Time<T> = LinearMass<T>

		/// <summary>Mulitplies LinearMassFlow by Time resulting in LinearMass.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(LinearMassFlow<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits3 <= b._TimeUnits1 ? a._TimeUnits3 : b._TimeUnits1;

			T A = a[a._MassUnits1, a._LengthUnits2, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				);
		}

		/// <summary>Mulitplies LinearMassFlow by Time resulting in LinearMass.</summary>
		/// <param name="a">The LinearMassFlow to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(LinearMassFlow<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies LinearMassFlow by Time resulting in LinearMass.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an LinearMassFlow measurement by another LinearMassFlow measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearMassFlow measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearMassFlow<T> Divide(LinearMassFlow<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
		/// <param name="a">The LinearMassFlow measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static LinearMassFlow<T> operator /(LinearMassFlow<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this LinearMassFlow measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public LinearMassFlow<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an LinearMassFlow measurement by another LinearMassFlow measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an LinearMassFlow measurement by another LinearMassFlow measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(LinearMassFlow<T> b)
		{
			return this / b;
		}


		#region LinearMassFlow<T> / AreaDensity<T> = VolumeRate<T>

		/// <summary>Divides LinearMassFlow by AreaDensity resulting in VolumeRate.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> Divide(LinearMassFlow<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2, a._TimeUnits3];
			T B = b[MassUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new VolumeRate<T>(C
				, a._LengthUnits2
				, b._LengthUnits2
				, b._LengthUnits3
				, a._TimeUnits3
				);
		}

		/// <summary>Divides LinearMassFlow by AreaDensity resulting in VolumeRate.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> operator /(LinearMassFlow<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by AreaDensity resulting in VolumeRate.</summary>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public VolumeRate<T> Divide(AreaDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / Force<T> = Time<T>

		/// <summary>Divides LinearMassFlow by Force resulting in Time.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(LinearMassFlow<T> a, Force<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;

			T A = a[MassUnits1, LengthUnits2, TimeUnits3];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, b._TimeUnits4];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits4
				);
		}

		/// <summary>Divides LinearMassFlow by Force resulting in Time.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(LinearMassFlow<T> a, Force<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by Force resulting in Time.</summary>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(Force<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / Length<T> = MassRate<T>

		/// <summary>Divides LinearMassFlow by Length resulting in MassRate.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> Divide(LinearMassFlow<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._TimeUnits3];
			T B = b[LengthUnits1];
			T C = Statics.Division(A, B);

			return new MassRate<T>(C
				, a._MassUnits1
				, a._TimeUnits3
				);
		}

		/// <summary>Divides LinearMassFlow by Length resulting in MassRate.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> operator /(LinearMassFlow<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by Length resulting in MassRate.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public MassRate<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / Mass<T> = Speed<T>

		/// <summary>Divides LinearMassFlow by Mass resulting in Speed.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(LinearMassFlow<T> a, Mass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._LengthUnits2, a._TimeUnits3];
			T B = b[MassUnits1];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits2
				, a._TimeUnits3
				);
		}

		/// <summary>Divides LinearMassFlow by Mass resulting in Speed.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(LinearMassFlow<T> a, Mass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by Mass resulting in Speed.</summary>
		/// <param name="b">The Mass to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(Mass<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / MassRate<T> = Length<T>

		/// <summary>Divides LinearMassFlow by MassRate resulting in Length.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(LinearMassFlow<T> a, MassRate<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[MassUnits1, a._LengthUnits2, TimeUnits2];
			T B = b[MassUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, a._LengthUnits2
				);
		}

		/// <summary>Divides LinearMassFlow by MassRate resulting in Length.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(LinearMassFlow<T> a, MassRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by MassRate resulting in Length.</summary>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(MassRate<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / Speed<T> = Mass<T>

		/// <summary>Divides LinearMassFlow by Speed resulting in Mass.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> Divide(LinearMassFlow<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;

			T A = a[a._MassUnits1, LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Divides LinearMassFlow by Speed resulting in Mass.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public static Mass<T> operator /(LinearMassFlow<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by Speed resulting in Mass.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Mass result of the division.</returns>
		public Mass<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / Time<T> = Force<T>

		/// <summary>Divides LinearMassFlow by Time resulting in Force.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> Divide(LinearMassFlow<T> a, Time<T> b)
		{

			T A = a[a._MassUnits1, a._LengthUnits2, a._TimeUnits3];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, a._TimeUnits3
				, b._TimeUnits1
				);
		}

		/// <summary>Divides LinearMassFlow by Time resulting in Force.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> operator /(LinearMassFlow<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by Time resulting in Force.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public Force<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region LinearMassFlow<T> / VolumeRate<T> = AreaDensity<T>

		/// <summary>Divides LinearMassFlow by VolumeRate resulting in AreaDensity.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> Divide(LinearMassFlow<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits3 <= b._TimeUnits4 ? a._TimeUnits3 : b._TimeUnits4;

			T A = a[a._MassUnits1, LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, b._LengthUnits2, b._LengthUnits3, TimeUnits2];
			T C = Statics.Division(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides LinearMassFlow by VolumeRate resulting in AreaDensity.</summary>
		/// <param name="a">The LinearMassFlow to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> operator /(LinearMassFlow<T> a, VolumeRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides LinearMassFlow by VolumeRate resulting in AreaDensity.</summary>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public AreaDensity<T> Divide(VolumeRate<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is less than another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(LinearMassFlow<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is greater than another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(LinearMassFlow<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is less than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(LinearMassFlow<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is greater than or equal to another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(LinearMassFlow<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is equal to another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(LinearMassFlow<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(LinearMassFlow<T> a, LinearMassFlow<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an LinearMassFlow measurement is not equal to another LinearMassFlow measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(LinearMassFlow<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is LinearMassFlow<T>)
			{
				return this == (LinearMassFlow<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the LinearMassFlow measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1 + "*" + _LengthUnits2
				+ "/" +
				_TimeUnits3
				;
		}

		/// <summary>Base hashing function for LinearMassFlow measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Mass

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass")]
		public static object Mass<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Mass Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Mass Factory.");
			}
			return new Mass<T>(value
				, (Mass.Units)units[0]
				);
		}
	}

	/// <summary>Mass measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Mass<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<Mass.Units, T>();
		internal T _measurement;
		internal Mass.Units _MassUnits1;

		#region Statics

		/// <summary>Converts a Mass measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <returns>The Mass measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Mass.Units toMassUnits1
			)
		{
			Mass<T> measurement = new Mass<T>(value
				, fromMassUnits1
				);
			return measurement[
				 toMassUnits1
				];
		}

		/// <summary>Converts a Mass measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Mass measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.MassUnits from,
			MeasurementUnitsSyntaxTypes.MassUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, to._MassUnits1
			);
		}

		/// <summary>Parses a Mass measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Mass<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Mass<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Mass with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Mass.</param>
		/// <param name="units">The units of the Mass.</param>
		public Mass(T measurement, MeasurementUnitsSyntaxTypes.MassUnits units) : this(measurement
			, units._MassUnits1
			) { }


		/// <summary>Constructs an Mass with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Mass.</param>
		/// <param name="MassUnits1">The units of the Mass.</param>
		public Mass(T measurement
			, Mass.Units MassUnits1
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.MassUnits units]
		{
			get { return this[units._MassUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Mass measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Mass measurement.</param>
		public static implicit operator Mass<T>((T, MeasurementUnitsSyntaxTypes.MassUnits) valueTuple)
		{
			return new Mass<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Mass<T> MathBase(Mass<T> a, T b, Func<T, T, T> func)
		{
			return new Mass<T>(func(a._measurement, b)
				, a._MassUnits1
			);
		}

		internal static Mass<T> MathBase(Mass<T> a, Mass<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			T A = a[MassUnits1];
			T B = b[MassUnits1];
			T C = func(A, B);
			return new Mass<T>(C, MassUnits1);
		}

		internal static bool LogicBase(Mass<T> a, Mass<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			T A = a[MassUnits1];
			T B = b[MassUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Mass measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Mass<T> Add(Mass<T> a, Mass<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Mass measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Mass<T> operator +(Mass<T> a, Mass<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Mass measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Mass<T> Add(Mass<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Mass measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Mass<T> Subtract(Mass<T> a, Mass<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Mass measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Mass<T> operator -(Mass<T> a, Mass<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Mass measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Mass<T> Subtract(Mass<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Mass by a scalar numeric value.</summary>
		/// <param name="a">The Mass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Mass<T> Multiply(Mass<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Mass by a scalar numeric value.</summary>
		/// <param name="a">The Mass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Mass<T> Multiply(T b, Mass<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Mass by a scalar numeric value.</summary>
		/// <param name="a">The Mass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Mass<T> operator *(Mass<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Mass by a scalar numeric value.</summary>
		/// <param name="a">The Mass measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Mass<T> operator *(T b, Mass<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Mass by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Mass<T> Add(T b)
		{
			return this * b;
		}

		#region Mass<T> * Acceleration<T> = Force<T>

		/// <summary>Mulitplies Mass by Acceleration resulting in Force.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(Mass<T> a, Acceleration<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1, b._TimeUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, b._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies Mass by Acceleration resulting in Force.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(Mass<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Mass by Acceleration resulting in Force.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region Mass<T> * Length<T> = LinearMass<T>

		/// <summary>Mulitplies Mass by Length resulting in LinearMass.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Mass<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				);
		}

		/// <summary>Mulitplies Mass by Length resulting in LinearMass.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Mass<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Mass by Length resulting in LinearMass.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region Mass<T> * Speed<T> = LinearMassFlow<T>

		/// <summary>Mulitplies Mass by Speed resulting in LinearMassFlow.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(Mass<T> a, Speed<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies Mass by Speed resulting in LinearMassFlow.</summary>
		/// <param name="a">The Mass to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(Mass<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Mass by Speed resulting in LinearMassFlow.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Mass measurement by another Mass measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Mass<T> a, Mass<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			T A = a[MassUnits1];
			T B = b[MassUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
		/// <param name="a">The Mass measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Mass<T> Divide(Mass<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
		/// <param name="a">The Mass measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Mass<T> operator /(Mass<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Mass measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Mass<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Mass measurement by another Mass measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Mass<T> a, Mass<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Mass measurement by another Mass measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Mass<T> b)
		{
			return this / b;
		}


		#region Mass<T> / Area<T> = AreaDensity<T>

		/// <summary>Divides Mass by Area resulting in AreaDensity.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> Divide(Mass<T> a, Area<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Divides Mass by Area resulting in AreaDensity.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> operator /(Mass<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by Area resulting in AreaDensity.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public AreaDensity<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / AreaDensity<T> = Area<T>

		/// <summary>Divides Mass by AreaDensity resulting in Area.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(Mass<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1];
			T B = b[MassUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides Mass by AreaDensity resulting in Area.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(Mass<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by AreaDensity resulting in Area.</summary>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(AreaDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / Density<T> = Volume<T>

		/// <summary>Divides Mass by Density resulting in Volume.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> Divide(Mass<T> a, Density<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1];
			T B = b[MassUnits1, b._LengthUnits2, b._LengthUnits3, b._LengthUnits4];
			T C = Statics.Division(A, B);

			return new Volume<T>(C
				, b._LengthUnits2
				, b._LengthUnits3
				, b._LengthUnits4
				);
		}

		/// <summary>Divides Mass by Density resulting in Volume.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public static Volume<T> operator /(Mass<T> a, Density<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by Density resulting in Volume.</summary>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The Volume result of the division.</returns>
		public Volume<T> Divide(Density<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / Length<T> = LinearDensity<T>

		/// <summary>Divides Mass by Length resulting in LinearDensity.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> Divide(Mass<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1];
			T C = Statics.Division(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				);
		}

		/// <summary>Divides Mass by Length resulting in LinearDensity.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> operator /(Mass<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by Length resulting in LinearDensity.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public LinearDensity<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / LinearDensity<T> = Length<T>

		/// <summary>Divides Mass by LinearDensity resulting in Length.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(Mass<T> a, LinearDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1];
			T B = b[MassUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, b._LengthUnits2
				);
		}

		/// <summary>Divides Mass by LinearDensity resulting in Length.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(Mass<T> a, LinearDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by LinearDensity resulting in Length.</summary>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(LinearDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / MassRate<T> = Time<T>

		/// <summary>Divides Mass by MassRate resulting in Time.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Mass<T> a, MassRate<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1];
			T B = b[MassUnits1, b._TimeUnits2];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits2
				);
		}

		/// <summary>Divides Mass by MassRate resulting in Time.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Mass<T> a, MassRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by MassRate resulting in Time.</summary>
		/// <param name="b">The MassRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(MassRate<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / Time<T> = MassRate<T>

		/// <summary>Divides Mass by Time resulting in MassRate.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> Divide(Mass<T> a, Time<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new MassRate<T>(C
				, a._MassUnits1
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Mass by Time resulting in MassRate.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public static MassRate<T> operator /(Mass<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by Time resulting in MassRate.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The MassRate result of the division.</returns>
		public MassRate<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region Mass<T> / Volume<T> = Density<T>

		/// <summary>Divides Mass by Volume resulting in Density.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> Divide(Mass<T> a, Volume<T> b)
		{

			T A = a[a._MassUnits1];
			T B = b[b._LengthUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Density<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides Mass by Volume resulting in Density.</summary>
		/// <param name="a">The Mass to be divided.</param>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> operator /(Mass<T> a, Volume<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Mass by Volume resulting in Density.</summary>
		/// <param name="b">The Volume to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public Density<T> Divide(Volume<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Mass<T> a, Mass<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Mass measurement is less than another Mass measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Mass<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Mass<T> a, Mass<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Mass measurement is greater than another Mass measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Mass<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Mass<T> a, Mass<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Mass measurement is less than or equal to another Mass measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Mass<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Mass<T> a, Mass<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Mass measurement is greater than or equal to another Mass measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Mass<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Mass<T> a, Mass<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Mass measurement is equal to another Mass measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Mass<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Mass<T> a, Mass<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Mass<T> a, Mass<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Mass measurement is not equal to another Mass measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Mass<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Mass<T>)
			{
				return this == (Mass<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Mass measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				
				;
		}

		/// <summary>Base hashing function for Mass measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region MassRate

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass/Time")]
		public static object MassRate<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to MassRate Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to MassRate Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to MassRate Factory.");
			}
			return new MassRate<T>(value
				, (Mass.Units)units[0]
				, (Time.Units)units[1]
				);
		}
	}

	/// <summary>MassRate measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct MassRate<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Time.Units _TimeUnits2;

		#region Statics

		/// <summary>Converts a MassRate measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <returns>The MassRate measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Time.Units fromTimeUnits2
			, Mass.Units toMassUnits1
			, Time.Units toTimeUnits2
			)
		{
			MassRate<T> measurement = new MassRate<T>(value
				, fromMassUnits1
				, fromTimeUnits2
				);
			return measurement[
				 toMassUnits1
				, toTimeUnits2
				];
		}

		/// <summary>Converts a MassRate measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The MassRate measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.MassRateBaseUnits from,
			MeasurementUnitsSyntaxTypes.MassRateBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._TimeUnits2
			, to._MassUnits1
			, to._TimeUnits2
			);
		}

		/// <summary>Parses a MassRate measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, MassRate<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, MassRate<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an MassRate with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the MassRate.</param>
		/// <param name="units">The units of the MassRate.</param>
		public MassRate(T measurement, MeasurementUnitsSyntaxTypes.MassRateBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._TimeUnits2
			) { }


		/// <summary>Constructs an MassRate with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the MassRate.</param>
		/// <param name="MassUnits1">The units of the MassRate.</param>
		/// <param name="TimeUnits2">The units of the MassRate.</param>
		public MassRate(T measurement
			, Mass.Units MassUnits1
			, Time.Units TimeUnits2
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_TimeUnits2 = TimeUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _TimeUnits2];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_MassUnits1, value];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.MassRateBaseUnits units]
		{
			get { return this[units._MassUnits1, units._TimeUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Time.Units TimeUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a MassRate measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a MassRate measurement.</param>
		public static implicit operator MassRate<T>((T, MeasurementUnitsSyntaxTypes.MassRateBaseUnits) valueTuple)
		{
			return new MassRate<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static MassRate<T> MathBase(MassRate<T> a, T b, Func<T, T, T> func)
		{
			return new MassRate<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._TimeUnits2
			);
		}

		internal static MassRate<T> MathBase(MassRate<T> a, MassRate<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[MassUnits1, TimeUnits2];
			T B = b[MassUnits1, TimeUnits2];
			T C = func(A, B);
			return new MassRate<T>(C, MassUnits1, TimeUnits2);
		}

		internal static bool LogicBase(MassRate<T> a, MassRate<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[MassUnits1, TimeUnits2];
			T B = b[MassUnits1, TimeUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two MassRate measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static MassRate<T> Add(MassRate<T> a, MassRate<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two MassRate measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static MassRate<T> operator +(MassRate<T> a, MassRate<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two MassRate measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public MassRate<T> Add(MassRate<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two MassRate measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static MassRate<T> Subtract(MassRate<T> a, MassRate<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two MassRate measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static MassRate<T> operator -(MassRate<T> a, MassRate<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two MassRate measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public MassRate<T> Subtract(MassRate<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an MassRate by a scalar numeric value.</summary>
		/// <param name="a">The MassRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static MassRate<T> Multiply(MassRate<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an MassRate by a scalar numeric value.</summary>
		/// <param name="a">The MassRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static MassRate<T> Multiply(T b, MassRate<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an MassRate by a scalar numeric value.</summary>
		/// <param name="a">The MassRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static MassRate<T> operator *(MassRate<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an MassRate by a scalar numeric value.</summary>
		/// <param name="a">The MassRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static MassRate<T> operator *(T b, MassRate<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an MassRate by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public MassRate<T> Add(T b)
		{
			return this * b;
		}

		#region MassRate<T> * Length<T> = LinearMassFlow<T>

		/// <summary>Mulitplies MassRate by Length resulting in LinearMassFlow.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(MassRate<T> a, Length<T> b)
		{

			T A = a[a._MassUnits1, a._TimeUnits2];
			T B = b[b._LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, a._TimeUnits2
				);
		}

		/// <summary>Mulitplies MassRate by Length resulting in LinearMassFlow.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(MassRate<T> a, Length<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies MassRate by Length resulting in LinearMassFlow.</summary>
		/// <param name="b">The Length to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(Length<T> b)
		{
			return this * b;
		}

		#endregion

		#region MassRate<T> * Speed<T> = Force<T>

		/// <summary>Mulitplies MassRate by Speed resulting in Force.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(MassRate<T> a, Speed<T> b)
		{

			T A = a[a._MassUnits1, a._TimeUnits2];
			T B = b[b._LengthUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, a._TimeUnits2
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies MassRate by Speed resulting in Force.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(MassRate<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies MassRate by Speed resulting in Force.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#region MassRate<T> * Time<T> = Mass<T>

		/// <summary>Mulitplies MassRate by Time resulting in Mass.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(MassRate<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._MassUnits1, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, a._MassUnits1
				);
		}

		/// <summary>Mulitplies MassRate by Time resulting in Mass.</summary>
		/// <param name="a">The MassRate to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(MassRate<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies MassRate by Time resulting in Mass.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an MassRate measurement by another MassRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(MassRate<T> a, MassRate<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[MassUnits1, TimeUnits2];
			T B = b[MassUnits1, TimeUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this MassRate measurement by a numaric scalar value.</summary>
		/// <param name="a">The MassRate measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static MassRate<T> Divide(MassRate<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this MassRate measurement by a numaric scalar value.</summary>
		/// <param name="a">The MassRate measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static MassRate<T> operator /(MassRate<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this MassRate measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public MassRate<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an MassRate measurement by another MassRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(MassRate<T> a, MassRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an MassRate measurement by another MassRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(MassRate<T> b)
		{
			return this / b;
		}


		#region MassRate<T> / Density<T> = VolumeRate<T>

		/// <summary>Divides MassRate by Density resulting in VolumeRate.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> Divide(MassRate<T> a, Density<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._TimeUnits2];
			T B = b[MassUnits1, b._LengthUnits2, b._LengthUnits3, b._LengthUnits4];
			T C = Statics.Division(A, B);

			return new VolumeRate<T>(C
				, b._LengthUnits2
				, b._LengthUnits3
				, b._LengthUnits4
				, a._TimeUnits2
				);
		}

		/// <summary>Divides MassRate by Density resulting in VolumeRate.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> operator /(MassRate<T> a, Density<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides MassRate by Density resulting in VolumeRate.</summary>
		/// <param name="b">The Density to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public VolumeRate<T> Divide(Density<T> b)
		{
			return this / b;
		}

		#endregion


		#region MassRate<T> / LinearDensity<T> = Speed<T>

		/// <summary>Divides MassRate by LinearDensity resulting in Speed.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(MassRate<T> a, LinearDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;

			T A = a[MassUnits1, a._TimeUnits2];
			T B = b[MassUnits1, b._LengthUnits2];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, b._LengthUnits2
				, a._TimeUnits2
				);
		}

		/// <summary>Divides MassRate by LinearDensity resulting in Speed.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(MassRate<T> a, LinearDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides MassRate by LinearDensity resulting in Speed.</summary>
		/// <param name="b">The LinearDensity to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(LinearDensity<T> b)
		{
			return this / b;
		}

		#endregion


		#region MassRate<T> / Speed<T> = LinearDensity<T>

		/// <summary>Divides MassRate by Speed resulting in LinearDensity.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> Divide(MassRate<T> a, Speed<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;

			T A = a[a._MassUnits1, TimeUnits1];
			T B = b[b._LengthUnits1, TimeUnits1];
			T C = Statics.Division(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				);
		}

		/// <summary>Divides MassRate by Speed resulting in LinearDensity.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public static LinearDensity<T> operator /(MassRate<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides MassRate by Speed resulting in LinearDensity.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The LinearDensity result of the division.</returns>
		public LinearDensity<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion


		#region MassRate<T> / VolumeRate<T> = Density<T>

		/// <summary>Divides MassRate by VolumeRate resulting in Density.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> Divide(MassRate<T> a, VolumeRate<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits4 ? a._TimeUnits2 : b._TimeUnits4;

			T A = a[a._MassUnits1, TimeUnits1];
			T B = b[b._LengthUnits1, b._LengthUnits2, b._LengthUnits3, TimeUnits1];
			T C = Statics.Division(A, B);

			return new Density<T>(C
				, a._MassUnits1
				, b._LengthUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Divides MassRate by VolumeRate resulting in Density.</summary>
		/// <param name="a">The MassRate to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public static Density<T> operator /(MassRate<T> a, VolumeRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides MassRate by VolumeRate resulting in Density.</summary>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Density result of the division.</returns>
		public Density<T> Divide(VolumeRate<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an MassRate measurement is less than another MassRate measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an MassRate measurement is less than another MassRate measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(MassRate<T> a, MassRate<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an MassRate measurement is less than another MassRate measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(MassRate<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an MassRate measurement is greater than another MassRate measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an MassRate measurement is greater than another MassRate measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(MassRate<T> a, MassRate<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an MassRate measurement is greater than another MassRate measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(MassRate<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an MassRate measurement is less than or equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an MassRate measurement is less than or equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(MassRate<T> a, MassRate<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an MassRate measurement is less than or equal to another MassRate measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(MassRate<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an MassRate measurement is greater than or equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an MassRate measurement is greater than or equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(MassRate<T> a, MassRate<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an MassRate measurement is greater than or equal to another MassRate measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(MassRate<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an MassRate measurement is equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an MassRate measurement is equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(MassRate<T> a, MassRate<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an MassRate measurement is equal to another MassRate measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(MassRate<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an MassRate measurement is not equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(MassRate<T> a, MassRate<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an MassRate measurement is not equal to another MassRate measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(MassRate<T> a, MassRate<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an MassRate measurement is not equal to another MassRate measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(MassRate<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is MassRate<T>)
			{
				return this == (MassRate<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the MassRate measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				+ "/" +
				_TimeUnits2
				;
		}

		/// <summary>Base hashing function for MassRate measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Power

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass*Length*Length/Time/Time/Time")]
		public static object Power<T>(T value, object[] units)
		{
			if (units.Length != 6)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[3] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[4] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			if (!(units[5] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Power Factory.");
			}
			return new Power<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				, (Time.Units)units[3]
				, (Time.Units)units[4]
				, (Time.Units)units[5]
				);
		}
	}

	/// <summary>Power measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Power<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;
		internal Time.Units _TimeUnits4;
		internal Time.Units _TimeUnits5;
		internal Time.Units _TimeUnits6;

		#region Statics

		/// <summary>Converts a Power measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="fromTimeUnits4">The current units of the measurement.</param>
		/// <param name="fromTimeUnits5">The current units of the measurement.</param>
		/// <param name="fromTimeUnits6">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <param name="toTimeUnits4">The desired units of the measurement.</param>
		/// <param name="toTimeUnits5">The desired units of the measurement.</param>
		/// <param name="toTimeUnits6">The desired units of the measurement.</param>
		/// <returns>The Power measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Time.Units fromTimeUnits4
			, Time.Units fromTimeUnits5
			, Time.Units fromTimeUnits6
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			, Time.Units toTimeUnits4
			, Time.Units toTimeUnits5
			, Time.Units toTimeUnits6
			)
		{
			Power<T> measurement = new Power<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				, fromTimeUnits4
				, fromTimeUnits5
				, fromTimeUnits6
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toLengthUnits3
				, toTimeUnits4
				, toTimeUnits5
				, toTimeUnits6
				];
		}

		/// <summary>Converts a Power measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Power measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.PowerBaseUnits from,
			MeasurementUnitsSyntaxTypes.PowerBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, from._TimeUnits4
			, from._TimeUnits5
			, from._TimeUnits6
			, to._MassUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			, to._TimeUnits4
			, to._TimeUnits5
			, to._TimeUnits6
			);
		}

		/// <summary>Parses a Power measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Power<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Power<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Power with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Power.</param>
		/// <param name="units">The units of the Power.</param>
		public Power(T measurement, MeasurementUnitsSyntaxTypes.PowerBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			, units._TimeUnits4
			, units._TimeUnits5
			, units._TimeUnits6
			) { }


		/// <summary>Constructs an Power with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Power.</param>
		/// <param name="MassUnits1">The units of the Power.</param>
		/// <param name="LengthUnits2">The units of the Power.</param>
		/// <param name="LengthUnits3">The units of the Power.</param>
		/// <param name="TimeUnits4">The units of the Power.</param>
		/// <param name="TimeUnits5">The units of the Power.</param>
		/// <param name="TimeUnits6">The units of the Power.</param>
		public Power(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			, Time.Units TimeUnits4
			, Time.Units TimeUnits5
			, Time.Units TimeUnits6
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
			_TimeUnits4 = TimeUnits4;
			_TimeUnits5 = TimeUnits5;
			_TimeUnits6 = TimeUnits6;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3, _TimeUnits4, _TimeUnits5, _TimeUnits6];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _LengthUnits3, _TimeUnits4, _TimeUnits5, _TimeUnits6];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value, _TimeUnits4, _TimeUnits5, _TimeUnits6];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Time.Units TimeUnits4
		{
			get { return _TimeUnits4; }
			set
			{
				if (value != _TimeUnits4)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, value, _TimeUnits5, _TimeUnits6];
					_TimeUnits4 = value;
				}
			}
		}

		/// <summary>The #5 component of this measurements units.</summary>
		public Time.Units TimeUnits5
		{
			get { return _TimeUnits5; }
			set
			{
				if (value != _TimeUnits5)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, _TimeUnits4, value, _TimeUnits6];
					_TimeUnits5 = value;
				}
			}
		}

		/// <summary>The #6 component of this measurements units.</summary>
		public Time.Units TimeUnits6
		{
			get { return _TimeUnits6; }
			set
			{
				if (value != _TimeUnits6)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _LengthUnits3, _TimeUnits4, _TimeUnits5, value];
					_TimeUnits6 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.PowerBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._LengthUnits3, units._TimeUnits4, units._TimeUnits5, units._TimeUnits6]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <param name="TimeUnits4">The #4 component of this measurements units.</param>
		/// <param name="TimeUnits5">The #5 component of this measurements units.</param>
		/// <param name="TimeUnits6">The #6 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4, Time.Units TimeUnits5, Time.Units TimeUnits6]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//if (LengthUnits3 < _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				if (TimeUnits4 != _TimeUnits4)
				{
					measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//if (TimeUnits4 > _TimeUnits4)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits4][(int)TimeUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//}
				}
				if (TimeUnits5 != _TimeUnits5)
				{
					measurement = Time<T>.Table[(int)TimeUnits5][(int)_TimeUnits5](measurement);
					//if (TimeUnits5 > _TimeUnits5)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits5][(int)TimeUnits5](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits5][(int)_TimeUnits5](measurement);
					//}
				}
				if (TimeUnits6 != _TimeUnits6)
				{
					measurement = Time<T>.Table[(int)TimeUnits6][(int)_TimeUnits6](measurement);
					//if (TimeUnits6 > _TimeUnits6)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits6][(int)TimeUnits6](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits6][(int)_TimeUnits6](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Power measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Power measurement.</param>
		public static implicit operator Power<T>((T, MeasurementUnitsSyntaxTypes.PowerBaseUnits) valueTuple)
		{
			return new Power<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Power<T> MathBase(Power<T> a, T b, Func<T, T, T> func)
		{
			return new Power<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits4
				, a._TimeUnits5
				, a._TimeUnits6
			);
		}

		internal static Power<T> MathBase(Power<T> a, Power<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			Time.Units TimeUnits6 = a._TimeUnits6 <= b._TimeUnits6 ? a._TimeUnits6 : b._TimeUnits6;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			T C = func(A, B);
			return new Power<T>(C, MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6);
		}

		internal static bool LogicBase(Power<T> a, Power<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			Time.Units TimeUnits6 = a._TimeUnits6 <= b._TimeUnits6 ? a._TimeUnits6 : b._TimeUnits6;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Power measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Power<T> Add(Power<T> a, Power<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Power measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Power<T> operator +(Power<T> a, Power<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Power measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Power<T> Add(Power<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Power measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Power<T> Subtract(Power<T> a, Power<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Power measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Power<T> operator -(Power<T> a, Power<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Power measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Power<T> Subtract(Power<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Power by a scalar numeric value.</summary>
		/// <param name="a">The Power measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Power<T> Multiply(Power<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Power by a scalar numeric value.</summary>
		/// <param name="a">The Power measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Power<T> Multiply(T b, Power<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Power by a scalar numeric value.</summary>
		/// <param name="a">The Power measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Power<T> operator *(Power<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Power by a scalar numeric value.</summary>
		/// <param name="a">The Power measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Power<T> operator *(T b, Power<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Power by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Power<T> Add(T b)
		{
			return this * b;
		}

		#region Power<T> * Time<T> = Energy<T>

		/// <summary>Mulitplies Power by Time resulting in Energy.</summary>
		/// <param name="a">The Power to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Power<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits4 <= b._TimeUnits1 ? a._TimeUnits4 : b._TimeUnits1;

			T A = a[a._MassUnits1, a._LengthUnits2, a._LengthUnits3, TimeUnits1, a._TimeUnits5, a._TimeUnits6];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits5
				, a._TimeUnits6
				);
		}

		/// <summary>Mulitplies Power by Time resulting in Energy.</summary>
		/// <param name="a">The Power to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Power<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Power by Time resulting in Energy.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Power measurement by another Power measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Power<T> a, Power<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			Time.Units TimeUnits5 = a._TimeUnits5 <= b._TimeUnits5 ? a._TimeUnits5 : b._TimeUnits5;
			Time.Units TimeUnits6 = a._TimeUnits6 <= b._TimeUnits6 ? a._TimeUnits6 : b._TimeUnits6;
			T A = a[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			T B = b[MassUnits1, LengthUnits2, LengthUnits3, TimeUnits4, TimeUnits5, TimeUnits6];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Power measurement by a numaric scalar value.</summary>
		/// <param name="a">The Power measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Power<T> Divide(Power<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Power measurement by a numaric scalar value.</summary>
		/// <param name="a">The Power measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Power<T> operator /(Power<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Power measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Power<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Power measurement by another Power measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Power<T> a, Power<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Power measurement by another Power measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Power<T> b)
		{
			return this / b;
		}


		#region Power<T> / Acceleration<T> = LinearMassFlow<T>

		/// <summary>Divides Power by Acceleration resulting in LinearMassFlow.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> Divide(Power<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;
			Time.Units TimeUnits3 = a._TimeUnits5 <= b._TimeUnits3 ? a._TimeUnits5 : b._TimeUnits3;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, TimeUnits2, TimeUnits3, a._TimeUnits6];
			T B = b[LengthUnits1, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new LinearMassFlow<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by Acceleration resulting in LinearMassFlow.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public static LinearMassFlow<T> operator /(Power<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by Acceleration resulting in LinearMassFlow.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The LinearMassFlow result of the division.</returns>
		public LinearMassFlow<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Power<T> / Force<T> = Speed<T>

		/// <summary>Divides Power by Force resulting in Speed.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(Power<T> a, Force<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits5 <= b._TimeUnits4 ? a._TimeUnits5 : b._TimeUnits4;

			T A = a[MassUnits1, LengthUnits2, a._LengthUnits3, TimeUnits3, TimeUnits4, a._TimeUnits6];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits3
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by Force resulting in Speed.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(Power<T> a, Force<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by Force resulting in Speed.</summary>
		/// <param name="b">The Force to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(Force<T> b)
		{
			return this / b;
		}

		#endregion


		#region Power<T> / LinearMassFlow<T> = Acceleration<T>

		/// <summary>Divides Power by LinearMassFlow resulting in Acceleration.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Power<T> a, LinearMassFlow<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;

			T A = a[MassUnits1, LengthUnits2, a._LengthUnits3, TimeUnits3, a._TimeUnits5, a._TimeUnits6];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, a._LengthUnits3
				, a._TimeUnits5
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by LinearMassFlow resulting in Acceleration.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Power<T> a, LinearMassFlow<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by LinearMassFlow resulting in Acceleration.</summary>
		/// <param name="b">The LinearMassFlow to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(LinearMassFlow<T> b)
		{
			return this / b;
		}

		#endregion


		#region Power<T> / Pressure<T> = VolumeRate<T>

		/// <summary>Divides Power by Pressure resulting in VolumeRate.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> Divide(Power<T> a, Pressure<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;
			Time.Units TimeUnits3 = a._TimeUnits5 <= b._TimeUnits4 ? a._TimeUnits5 : b._TimeUnits4;

			T A = a[MassUnits1, a._LengthUnits2, a._LengthUnits3, TimeUnits2, TimeUnits3, a._TimeUnits6];
			T B = b[MassUnits1, b._LengthUnits2, TimeUnits2, TimeUnits3];
			T C = Statics.Division(A, B);

			return new VolumeRate<T>(C
				, a._LengthUnits2
				, a._LengthUnits3
				, b._LengthUnits2
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by Pressure resulting in VolumeRate.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> operator /(Power<T> a, Pressure<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by Pressure resulting in VolumeRate.</summary>
		/// <param name="b">The Pressure to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public VolumeRate<T> Divide(Pressure<T> b)
		{
			return this / b;
		}

		#endregion


		#region Power<T> / Speed<T> = Force<T>

		/// <summary>Divides Power by Speed resulting in Force.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> Divide(Power<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;

			T A = a[a._MassUnits1, LengthUnits1, a._LengthUnits3, TimeUnits2, a._TimeUnits5, a._TimeUnits6];
			T B = b[LengthUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, a._LengthUnits3
				, a._TimeUnits5
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by Speed resulting in Force.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public static Force<T> operator /(Power<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by Speed resulting in Force.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Force result of the division.</returns>
		public Force<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion


		#region Power<T> / VolumeRate<T> = Pressure<T>

		/// <summary>Divides Power by VolumeRate resulting in Pressure.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> Divide(Power<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits3 <= b._LengthUnits2 ? a._LengthUnits3 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;

			T A = a[a._MassUnits1, LengthUnits1, LengthUnits2, TimeUnits3, a._TimeUnits5, a._TimeUnits6];
			T B = b[LengthUnits1, LengthUnits2, b._LengthUnits3, TimeUnits3];
			T C = Statics.Division(A, B);

			return new Pressure<T>(C
				, a._MassUnits1
				, b._LengthUnits3
				, a._TimeUnits5
				, a._TimeUnits6
				);
		}

		/// <summary>Divides Power by VolumeRate resulting in Pressure.</summary>
		/// <param name="a">The Power to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public static Pressure<T> operator /(Power<T> a, VolumeRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Power by VolumeRate resulting in Pressure.</summary>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Pressure result of the division.</returns>
		public Pressure<T> Divide(VolumeRate<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Power measurement is less than another Power measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Power measurement is less than another Power measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Power<T> a, Power<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Power measurement is less than another Power measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Power<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Power measurement is greater than another Power measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Power measurement is greater than another Power measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Power<T> a, Power<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Power measurement is greater than another Power measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Power<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Power measurement is less than or equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Power measurement is less than or equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Power<T> a, Power<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Power measurement is less than or equal to another Power measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Power<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Power measurement is greater than or equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Power measurement is greater than or equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Power<T> a, Power<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Power measurement is greater than or equal to another Power measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Power<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Power measurement is equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Power measurement is equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Power<T> a, Power<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Power measurement is equal to another Power measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Power<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Power measurement is not equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Power<T> a, Power<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Power measurement is not equal to another Power measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Power<T> a, Power<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Power measurement is not equal to another Power measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Power<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Power<T>)
			{
				return this == (Power<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Power measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1 + "*" + _LengthUnits2 + "*" + _LengthUnits3
				+ "/" +
				_TimeUnits4 + "/" + _TimeUnits5 + "/" + _TimeUnits6
				;
		}

		/// <summary>Base hashing function for Power measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Pressure

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Mass/Length/Time/Time")]
		public static object Pressure<T>(T value, object[] units)
		{
			if (units.Length != 4)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Pressure Factory.");
			}
			if (!(units[0] is Mass.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Pressure Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Pressure Factory.");
			}
			if (!(units[2] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Pressure Factory.");
			}
			if (!(units[3] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Pressure Factory.");
			}
			return new Pressure<T>(value
				, (Mass.Units)units[0]
				, (Length.Units)units[1]
				, (Time.Units)units[2]
				, (Time.Units)units[3]
				);
		}
	}

	/// <summary>Pressure measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Pressure<T>
	{
		internal T _measurement;
		internal Mass.Units _MassUnits1;
		internal Length.Units _LengthUnits2;
		internal Time.Units _TimeUnits3;
		internal Time.Units _TimeUnits4;

		#region Statics

		/// <summary>Converts a Pressure measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromMassUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromTimeUnits3">The current units of the measurement.</param>
		/// <param name="fromTimeUnits4">The current units of the measurement.</param>
		/// <param name="toMassUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toTimeUnits3">The desired units of the measurement.</param>
		/// <param name="toTimeUnits4">The desired units of the measurement.</param>
		/// <returns>The Pressure measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Mass.Units fromMassUnits1
			, Length.Units fromLengthUnits2
			, Time.Units fromTimeUnits3
			, Time.Units fromTimeUnits4
			, Mass.Units toMassUnits1
			, Length.Units toLengthUnits2
			, Time.Units toTimeUnits3
			, Time.Units toTimeUnits4
			)
		{
			Pressure<T> measurement = new Pressure<T>(value
				, fromMassUnits1
				, fromLengthUnits2
				, fromTimeUnits3
				, fromTimeUnits4
				);
			return measurement[
				 toMassUnits1
				, toLengthUnits2
				, toTimeUnits3
				, toTimeUnits4
				];
		}

		/// <summary>Converts a Pressure measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Pressure measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.PressureBaseUnits from,
			MeasurementUnitsSyntaxTypes.PressureBaseUnits to)
		{
			return Convert(value
			, from._MassUnits1
			, from._LengthUnits2
			, from._TimeUnits3
			, from._TimeUnits4
			, to._MassUnits1
			, to._LengthUnits2
			, to._TimeUnits3
			, to._TimeUnits4
			);
		}

		/// <summary>Parses a Pressure measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Pressure<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Pressure<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Pressure with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Pressure.</param>
		/// <param name="units">The units of the Pressure.</param>
		public Pressure(T measurement, MeasurementUnitsSyntaxTypes.PressureBaseUnits units) : this(measurement
			, units._MassUnits1
			, units._LengthUnits2
			, units._TimeUnits3
			, units._TimeUnits4
			) { }


		/// <summary>Constructs an Pressure with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Pressure.</param>
		/// <param name="MassUnits1">The units of the Pressure.</param>
		/// <param name="LengthUnits2">The units of the Pressure.</param>
		/// <param name="TimeUnits3">The units of the Pressure.</param>
		/// <param name="TimeUnits4">The units of the Pressure.</param>
		public Pressure(T measurement
			, Mass.Units MassUnits1
			, Length.Units LengthUnits2
			, Time.Units TimeUnits3
			, Time.Units TimeUnits4
			)
		{
			_measurement = measurement;
			_MassUnits1 = MassUnits1;
			_LengthUnits2 = LengthUnits2;
			_TimeUnits3 = TimeUnits3;
			_TimeUnits4 = TimeUnits4;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Mass.Units MassUnits1
		{
			get { return _MassUnits1; }
			set
			{
				if (value != _MassUnits1)
				{
					_measurement = this[value, _LengthUnits2, _TimeUnits3, _TimeUnits4];
					_MassUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_MassUnits1, value, _TimeUnits3, _TimeUnits4];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Time.Units TimeUnits3
		{
			get { return _TimeUnits3; }
			set
			{
				if (value != _TimeUnits3)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, value, _TimeUnits4];
					_TimeUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Time.Units TimeUnits4
		{
			get { return _TimeUnits4; }
			set
			{
				if (value != _TimeUnits4)
				{
					_measurement = this[_MassUnits1, _LengthUnits2, _TimeUnits3, value];
					_TimeUnits4 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.PressureBaseUnits units]
		{
			get { return this[units._MassUnits1, units._LengthUnits2, units._TimeUnits3, units._TimeUnits4]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="MassUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="TimeUnits3">The #3 component of this measurements units.</param>
		/// <param name="TimeUnits4">The #4 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3, Time.Units TimeUnits4]
		{
			get
			{
				T measurement = _measurement;
				if (MassUnits1 != _MassUnits1)
				{
					measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//if (MassUnits1 < _MassUnits1)
					//{
					//	measurement = Mass<T>.Table[(int)_MassUnits1][(int)MassUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Mass<T>.Table[(int)MassUnits1][(int)_MassUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//if (LengthUnits2 > _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (TimeUnits3 != _TimeUnits3)
				{
					measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//if (TimeUnits3 > _TimeUnits3)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits3][(int)TimeUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits3][(int)_TimeUnits3](measurement);
					//}
				}
				if (TimeUnits4 != _TimeUnits4)
				{
					measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//if (TimeUnits4 > _TimeUnits4)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits4][(int)TimeUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Pressure measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Pressure measurement.</param>
		public static implicit operator Pressure<T>((T, MeasurementUnitsSyntaxTypes.PressureBaseUnits) valueTuple)
		{
			return new Pressure<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Pressure<T> MathBase(Pressure<T> a, T b, Func<T, T, T> func)
		{
			return new Pressure<T>(func(a._measurement, b)
				, a._MassUnits1
				, a._LengthUnits2
				, a._TimeUnits3
				, a._TimeUnits4
			);
		}

		internal static Pressure<T> MathBase(Pressure<T> a, Pressure<T> b, Func<T, T, T> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T C = func(A, B);
			return new Pressure<T>(C, MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4);
		}

		internal static bool LogicBase(Pressure<T> a, Pressure<T> b, Func<T, T, bool> func)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Pressure measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Pressure<T> Add(Pressure<T> a, Pressure<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Pressure measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Pressure<T> operator +(Pressure<T> a, Pressure<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Pressure measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Pressure<T> Add(Pressure<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Pressure measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Pressure<T> Subtract(Pressure<T> a, Pressure<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Pressure measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Pressure<T> operator -(Pressure<T> a, Pressure<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Pressure measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Pressure<T> Subtract(Pressure<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Pressure by a scalar numeric value.</summary>
		/// <param name="a">The Pressure measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Pressure<T> Multiply(Pressure<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Pressure by a scalar numeric value.</summary>
		/// <param name="a">The Pressure measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Pressure<T> Multiply(T b, Pressure<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Pressure by a scalar numeric value.</summary>
		/// <param name="a">The Pressure measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Pressure<T> operator *(Pressure<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Pressure by a scalar numeric value.</summary>
		/// <param name="a">The Pressure measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Pressure<T> operator *(T b, Pressure<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Pressure by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Pressure<T> Add(T b)
		{
			return this * b;
		}

		#region Pressure<T> * Area<T> = Force<T>

		/// <summary>Mulitplies Pressure by Area resulting in Force.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(Pressure<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._TimeUnits3, a._TimeUnits4];
			T B = b[LengthUnits1, b._LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies Pressure by Area resulting in Force.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(Pressure<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Pressure by Area resulting in Force.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region Pressure<T> * TimeArea<T> = LinearDensity<T>

		/// <summary>Mulitplies Pressure by TimeArea resulting in LinearDensity.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(Pressure<T> a, TimeArea<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits3 <= b._TimeUnits1 ? a._TimeUnits3 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;

			T A = a[a._MassUnits1, a._LengthUnits2, TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				);
		}

		/// <summary>Mulitplies Pressure by TimeArea resulting in LinearDensity.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(Pressure<T> a, TimeArea<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Pressure by TimeArea resulting in LinearDensity.</summary>
		/// <param name="b">The TimeArea to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(TimeArea<T> b)
		{
			return this * b;
		}

		#endregion

		#region Pressure<T> * Volume<T> = Energy<T>

		/// <summary>Mulitplies Pressure by Volume resulting in Energy.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Pressure<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._TimeUnits3, a._TimeUnits4];
			T B = b[LengthUnits1, b._LengthUnits2, b._LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies Pressure by Volume resulting in Energy.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Pressure<T> a, Volume<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Pressure by Volume resulting in Energy.</summary>
		/// <param name="b">The Volume to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Volume<T> b)
		{
			return this * b;
		}

		#endregion

		#region Pressure<T> * VolumeRate<T> = Power<T>

		/// <summary>Mulitplies Pressure by VolumeRate resulting in Power.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(Pressure<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits2 <= b._LengthUnits1 ? a._LengthUnits2 : b._LengthUnits1;

			T A = a[a._MassUnits1, LengthUnits1, a._TimeUnits3, a._TimeUnits4];
			T B = b[LengthUnits1, b._LengthUnits2, b._LengthUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, a._MassUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				, a._TimeUnits3
				, a._TimeUnits4
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Pressure by VolumeRate resulting in Power.</summary>
		/// <param name="a">The Pressure to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(Pressure<T> a, VolumeRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Pressure by VolumeRate resulting in Power.</summary>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(VolumeRate<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Pressure measurement by another Pressure measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Pressure<T> a, Pressure<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Time.Units TimeUnits3 = a._TimeUnits3 <= b._TimeUnits3 ? a._TimeUnits3 : b._TimeUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, TimeUnits3, TimeUnits4];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Pressure measurement by a numaric scalar value.</summary>
		/// <param name="a">The Pressure measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Pressure<T> Divide(Pressure<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Pressure measurement by a numaric scalar value.</summary>
		/// <param name="a">The Pressure measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Pressure<T> operator /(Pressure<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Pressure measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Pressure<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Pressure measurement by another Pressure measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Pressure<T> a, Pressure<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Pressure measurement by another Pressure measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Pressure<T> b)
		{
			return this / b;
		}


		#region Pressure<T> / Acceleration<T> = AreaDensity<T>

		/// <summary>Divides Pressure by Acceleration resulting in AreaDensity.</summary>
		/// <param name="a">The Pressure to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> Divide(Pressure<T> a, Acceleration<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits3 <= b._TimeUnits2 ? a._TimeUnits3 : b._TimeUnits2;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits3 ? a._TimeUnits4 : b._TimeUnits3;

			T A = a[a._MassUnits1, a._LengthUnits2, TimeUnits1, TimeUnits2];
			T B = b[b._LengthUnits1, TimeUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new AreaDensity<T>(C
				, a._MassUnits1
				, a._LengthUnits2
				, b._LengthUnits1
				);
		}

		/// <summary>Divides Pressure by Acceleration resulting in AreaDensity.</summary>
		/// <param name="a">The Pressure to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public static AreaDensity<T> operator /(Pressure<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Pressure by Acceleration resulting in AreaDensity.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The AreaDensity result of the division.</returns>
		public AreaDensity<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Pressure<T> / AreaDensity<T> = Acceleration<T>

		/// <summary>Divides Pressure by AreaDensity resulting in Acceleration.</summary>
		/// <param name="a">The Pressure to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Pressure<T> a, AreaDensity<T> b)
		{
			Mass.Units MassUnits1 = a._MassUnits1 <= b._MassUnits1 ? a._MassUnits1 : b._MassUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[MassUnits1, LengthUnits2, a._TimeUnits3, a._TimeUnits4];
			T B = b[MassUnits1, LengthUnits2, b._LengthUnits3];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, b._LengthUnits3
				, a._TimeUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Divides Pressure by AreaDensity resulting in Acceleration.</summary>
		/// <param name="a">The Pressure to be divided.</param>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Pressure<T> a, AreaDensity<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Pressure by AreaDensity resulting in Acceleration.</summary>
		/// <param name="b">The AreaDensity to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(AreaDensity<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Pressure measurement is less than another Pressure measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Pressure measurement is less than another Pressure measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Pressure<T> a, Pressure<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Pressure measurement is less than another Pressure measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Pressure<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Pressure measurement is greater than another Pressure measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Pressure measurement is greater than another Pressure measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Pressure<T> a, Pressure<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Pressure measurement is greater than another Pressure measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Pressure<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Pressure measurement is less than or equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Pressure measurement is less than or equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Pressure<T> a, Pressure<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Pressure measurement is less than or equal to another Pressure measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Pressure<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Pressure measurement is greater than or equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Pressure measurement is greater than or equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Pressure<T> a, Pressure<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Pressure measurement is greater than or equal to another Pressure measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Pressure<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Pressure measurement is equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Pressure measurement is equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Pressure<T> a, Pressure<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Pressure measurement is equal to another Pressure measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Pressure<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Pressure measurement is not equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Pressure<T> a, Pressure<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Pressure measurement is not equal to another Pressure measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Pressure<T> a, Pressure<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Pressure measurement is not equal to another Pressure measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Pressure<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Pressure<T>)
			{
				return this == (Pressure<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Pressure measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_MassUnits1
				+ "/" +
				_LengthUnits2 + "/" + _TimeUnits3 + "/" + _TimeUnits4
				;
		}

		/// <summary>Base hashing function for Pressure measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Speed

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length/Time")]
		public static object Speed<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Speed Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Speed Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Speed Factory.");
			}
			return new Speed<T>(value
				, (Length.Units)units[0]
				, (Time.Units)units[1]
				);
		}
	}

	/// <summary>Speed measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Speed<T>
	{
		internal T _measurement;
		internal Length.Units _LengthUnits1;
		internal Time.Units _TimeUnits2;

		#region Statics

		/// <summary>Converts a Speed measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <returns>The Speed measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Time.Units fromTimeUnits2
			, Length.Units toLengthUnits1
			, Time.Units toTimeUnits2
			)
		{
			Speed<T> measurement = new Speed<T>(value
				, fromLengthUnits1
				, fromTimeUnits2
				);
			return measurement[
				 toLengthUnits1
				, toTimeUnits2
				];
		}

		/// <summary>Converts a Speed measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Speed measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.SpeedBaseUnits from,
			MeasurementUnitsSyntaxTypes.SpeedBaseUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, from._TimeUnits2
			, to._LengthUnits1
			, to._TimeUnits2
			);
		}

		/// <summary>Parses a Speed measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Speed<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Speed<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Speed with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Speed.</param>
		/// <param name="units">The units of the Speed.</param>
		public Speed(T measurement, MeasurementUnitsSyntaxTypes.SpeedBaseUnits units) : this(measurement
			, units._LengthUnits1
			, units._TimeUnits2
			) { }


		/// <summary>Constructs an Speed with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Speed.</param>
		/// <param name="LengthUnits1">The units of the Speed.</param>
		/// <param name="TimeUnits2">The units of the Speed.</param>
		public Speed(T measurement
			, Length.Units LengthUnits1
			, Time.Units TimeUnits2
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
			_TimeUnits2 = TimeUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value, _TimeUnits2];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_LengthUnits1, value];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.SpeedBaseUnits units]
		{
			get { return this[units._LengthUnits1, units._TimeUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1, Time.Units TimeUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//if (TimeUnits2 > _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Speed measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Speed measurement.</param>
		public static implicit operator Speed<T>((T, MeasurementUnitsSyntaxTypes.SpeedBaseUnits) valueTuple)
		{
			return new Speed<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Speed<T> MathBase(Speed<T> a, T b, Func<T, T, T> func)
		{
			return new Speed<T>(func(a._measurement, b)
				, a._LengthUnits1
				, a._TimeUnits2
			);
		}

		internal static Speed<T> MathBase(Speed<T> a, Speed<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2];
			T C = func(A, B);
			return new Speed<T>(C, LengthUnits1, TimeUnits2);
		}

		internal static bool LogicBase(Speed<T> a, Speed<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Speed measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Speed<T> Add(Speed<T> a, Speed<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Speed measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Speed<T> operator +(Speed<T> a, Speed<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Speed measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Speed<T> Add(Speed<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Speed measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Speed<T> Subtract(Speed<T> a, Speed<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Speed measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Speed<T> operator -(Speed<T> a, Speed<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Speed measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Speed<T> Subtract(Speed<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Speed by a scalar numeric value.</summary>
		/// <param name="a">The Speed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Speed<T> Multiply(Speed<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Speed by a scalar numeric value.</summary>
		/// <param name="a">The Speed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Speed<T> Multiply(T b, Speed<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Speed by a scalar numeric value.</summary>
		/// <param name="a">The Speed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Speed<T> operator *(Speed<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Speed by a scalar numeric value.</summary>
		/// <param name="a">The Speed measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Speed<T> operator *(T b, Speed<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Speed by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Speed<T> Add(T b)
		{
			return this * b;
		}

		#region Speed<T> * Area<T> = VolumeRate<T>

		/// <summary>Mulitplies Speed by Area resulting in VolumeRate.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public static VolumeRate<T> Multiply(Speed<T> a, Area<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._LengthUnits1, b._LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new VolumeRate<T>(C
				, a._LengthUnits1
				, b._LengthUnits1
				, b._LengthUnits2
				, a._TimeUnits2
				);
		}

		/// <summary>Mulitplies Speed by Area resulting in VolumeRate.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public static VolumeRate<T> operator *(Speed<T> a, Area<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by Area resulting in VolumeRate.</summary>
		/// <param name="b">The Area to multiply by.</param>
		/// <returns>The VolumeRate result of the multiplication.</returns>
		public VolumeRate<T> Multiply(Area<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * Force<T> = Power<T>

		/// <summary>Mulitplies Speed by Force resulting in Power.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(Speed<T> a, Force<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._MassUnits1, b._LengthUnits2, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._LengthUnits2
				, a._TimeUnits2
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Speed by Force resulting in Power.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(Speed<T> a, Force<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by Force resulting in Power.</summary>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(Force<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * LinearDensity<T> = MassRate<T>

		/// <summary>Mulitplies Speed by LinearDensity resulting in MassRate.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> Multiply(Speed<T> a, LinearDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._TimeUnits2];
			T B = b[b._MassUnits1, LengthUnits1];
			T C = Statics.Multiplication(A, B);

			return new MassRate<T>(C
				, b._MassUnits1
				, a._TimeUnits2
				);
		}

		/// <summary>Mulitplies Speed by LinearDensity resulting in MassRate.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> operator *(Speed<T> a, LinearDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by LinearDensity resulting in MassRate.</summary>
		/// <param name="b">The LinearDensity to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public MassRate<T> Multiply(LinearDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * LinearMassFlow<T> = Energy<T>

		/// <summary>Mulitplies Speed by LinearMassFlow resulting in Energy.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Speed<T> a, LinearMassFlow<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._MassUnits1, b._LengthUnits2, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, b._LengthUnits2
				, a._TimeUnits2
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies Speed by LinearMassFlow resulting in Energy.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Speed<T> a, LinearMassFlow<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by LinearMassFlow resulting in Energy.</summary>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(LinearMassFlow<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * Mass<T> = LinearMassFlow<T>

		/// <summary>Mulitplies Speed by Mass resulting in LinearMassFlow.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(Speed<T> a, Mass<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._MassUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, a._TimeUnits2
				);
		}

		/// <summary>Mulitplies Speed by Mass resulting in LinearMassFlow.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(Speed<T> a, Mass<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by Mass resulting in LinearMassFlow.</summary>
		/// <param name="b">The Mass to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(Mass<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * MassRate<T> = Force<T>

		/// <summary>Mulitplies Speed by MassRate resulting in Force.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> Multiply(Speed<T> a, MassRate<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._MassUnits1, b._TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Force<T>(C
				, b._MassUnits1
				, a._LengthUnits1
				, a._TimeUnits2
				, b._TimeUnits2
				);
		}

		/// <summary>Mulitplies Speed by MassRate resulting in Force.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public static Force<T> operator *(Speed<T> a, MassRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by MassRate resulting in Force.</summary>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Force result of the multiplication.</returns>
		public Force<T> Multiply(MassRate<T> b)
		{
			return this * b;
		}

		#endregion

		#region Speed<T> * Time<T> = Length<T>

		/// <summary>Mulitplies Speed by Time resulting in Length.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> Multiply(Speed<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits2 <= b._TimeUnits1 ? a._TimeUnits2 : b._TimeUnits1;

			T A = a[a._LengthUnits1, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Length<T>(C
				, a._LengthUnits1
				);
		}

		/// <summary>Mulitplies Speed by Time resulting in Length.</summary>
		/// <param name="a">The Speed to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> operator *(Speed<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Speed by Time resulting in Length.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public Length<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Speed measurement by another Speed measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Speed<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
		/// <param name="a">The Speed measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Speed<T> Divide(Speed<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
		/// <param name="a">The Speed measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Speed<T> operator /(Speed<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Speed measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Speed<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Speed measurement by another Speed measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Speed<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Speed measurement by another Speed measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Speed<T> b)
		{
			return this / b;
		}


		#region Speed<T> / Acceleration<T> = Time<T>

		/// <summary>Divides Speed by Acceleration resulting in Time.</summary>
		/// <param name="a">The Speed to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Speed<T> a, Acceleration<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;

			T A = a[LengthUnits1, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2, b._TimeUnits3];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits3
				);
		}

		/// <summary>Divides Speed by Acceleration resulting in Time.</summary>
		/// <param name="a">The Speed to be divided.</param>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Speed<T> a, Acceleration<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Speed by Acceleration resulting in Time.</summary>
		/// <param name="b">The Acceleration to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(Acceleration<T> b)
		{
			return this / b;
		}

		#endregion


		#region Speed<T> / Time<T> = Acceleration<T>

		/// <summary>Divides Speed by Time resulting in Acceleration.</summary>
		/// <param name="a">The Speed to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> Divide(Speed<T> a, Time<T> b)
		{

			T A = a[a._LengthUnits1, a._TimeUnits2];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new Acceleration<T>(C
				, a._LengthUnits1
				, a._TimeUnits2
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Speed by Time resulting in Acceleration.</summary>
		/// <param name="a">The Speed to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public static Acceleration<T> operator /(Speed<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Speed by Time resulting in Acceleration.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Acceleration result of the division.</returns>
		public Acceleration<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Speed<T> a, Speed<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Speed measurement is less than another Speed measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Speed<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Speed<T> a, Speed<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Speed measurement is greater than another Speed measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Speed<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Speed<T> a, Speed<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Speed measurement is less than or equal to another Speed measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Speed<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Speed<T> a, Speed<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Speed measurement is greater than or equal to another Speed measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Speed<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Speed<T> a, Speed<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Speed measurement is equal to another Speed measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Speed<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Speed<T> a, Speed<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Speed<T> a, Speed<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Speed measurement is not equal to another Speed measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Speed<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Speed<T>)
			{
				return this == (Speed<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Speed measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1
				+ "/" +
				_TimeUnits2
				;
		}

		/// <summary>Base hashing function for Speed measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Tempurature

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Tempurature")]
		public static object Tempurature<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Tempurature Factory.");
			}
			if (!(units[0] is Tempurature.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Tempurature Factory.");
			}
			return new Tempurature<T>(value
				, (Tempurature.Units)units[0]
				);
		}
	}

	/// <summary>Tempurature measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Tempurature<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<Tempurature.Units, T>();
		internal T _measurement;
		internal Tempurature.Units _TempuratureUnits1;

		#region Statics

		/// <summary>Converts a Tempurature measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromTempuratureUnits1">The current units of the measurement.</param>
		/// <param name="toTempuratureUnits1">The desired units of the measurement.</param>
		/// <returns>The Tempurature measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Tempurature.Units fromTempuratureUnits1
			, Tempurature.Units toTempuratureUnits1
			)
		{
			Tempurature<T> measurement = new Tempurature<T>(value
				, fromTempuratureUnits1
				);
			return measurement[
				 toTempuratureUnits1
				];
		}

		/// <summary>Converts a Tempurature measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Tempurature measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.TempuratureUnits from,
			MeasurementUnitsSyntaxTypes.TempuratureUnits to)
		{
			return Convert(value
			, from._TempuratureUnits1
			, to._TempuratureUnits1
			);
		}

		/// <summary>Parses a Tempurature measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Tempurature<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Tempurature<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Tempurature with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Tempurature.</param>
		/// <param name="units">The units of the Tempurature.</param>
		public Tempurature(T measurement, MeasurementUnitsSyntaxTypes.TempuratureUnits units) : this(measurement
			, units._TempuratureUnits1
			) { }


		/// <summary>Constructs an Tempurature with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Tempurature.</param>
		/// <param name="TempuratureUnits1">The units of the Tempurature.</param>
		public Tempurature(T measurement
			, Tempurature.Units TempuratureUnits1
			)
		{
			_measurement = measurement;
			_TempuratureUnits1 = TempuratureUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Tempurature.Units TempuratureUnits1
		{
			get { return _TempuratureUnits1; }
			set
			{
				if (value != _TempuratureUnits1)
				{
					_measurement = this[value];
					_TempuratureUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.TempuratureUnits units]
		{
			get { return this[units._TempuratureUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="TempuratureUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Tempurature.Units TempuratureUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (TempuratureUnits1 != _TempuratureUnits1)
				{
					measurement = Tempurature<T>.Table[(int)_TempuratureUnits1][(int)TempuratureUnits1](measurement);
					//if (TempuratureUnits1 < _TempuratureUnits1)
					//{
					//	measurement = Tempurature<T>.Table[(int)_TempuratureUnits1][(int)TempuratureUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Tempurature<T>.Table[(int)TempuratureUnits1][(int)_TempuratureUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Tempurature measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Tempurature measurement.</param>
		public static implicit operator Tempurature<T>((T, MeasurementUnitsSyntaxTypes.TempuratureUnits) valueTuple)
		{
			return new Tempurature<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Tempurature<T> MathBase(Tempurature<T> a, T b, Func<T, T, T> func)
		{
			return new Tempurature<T>(func(a._measurement, b)
				, a._TempuratureUnits1
			);
		}

		internal static Tempurature<T> MathBase(Tempurature<T> a, Tempurature<T> b, Func<T, T, T> func)
		{
			Tempurature.Units TempuratureUnits1 = a._TempuratureUnits1 <= b._TempuratureUnits1 ? a._TempuratureUnits1 : b._TempuratureUnits1;
			T A = a[TempuratureUnits1];
			T B = b[TempuratureUnits1];
			T C = func(A, B);
			return new Tempurature<T>(C, TempuratureUnits1);
		}

		internal static bool LogicBase(Tempurature<T> a, Tempurature<T> b, Func<T, T, bool> func)
		{
			Tempurature.Units TempuratureUnits1 = a._TempuratureUnits1 <= b._TempuratureUnits1 ? a._TempuratureUnits1 : b._TempuratureUnits1;
			T A = a[TempuratureUnits1];
			T B = b[TempuratureUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Tempurature measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Tempurature<T> Add(Tempurature<T> a, Tempurature<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Tempurature measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Tempurature<T> operator +(Tempurature<T> a, Tempurature<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Tempurature measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Tempurature<T> Add(Tempurature<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Tempurature measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Tempurature<T> Subtract(Tempurature<T> a, Tempurature<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Tempurature measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Tempurature<T> operator -(Tempurature<T> a, Tempurature<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Tempurature measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Tempurature<T> Subtract(Tempurature<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Tempurature by a scalar numeric value.</summary>
		/// <param name="a">The Tempurature measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Tempurature<T> Multiply(Tempurature<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Tempurature by a scalar numeric value.</summary>
		/// <param name="a">The Tempurature measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Tempurature<T> Multiply(T b, Tempurature<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Tempurature by a scalar numeric value.</summary>
		/// <param name="a">The Tempurature measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Tempurature<T> operator *(Tempurature<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Tempurature by a scalar numeric value.</summary>
		/// <param name="a">The Tempurature measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Tempurature<T> operator *(T b, Tempurature<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Tempurature by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Tempurature<T> Add(T b)
		{
			return this * b;
		}

		#endregion

		#region Divide

		/// <summary>Divides an Tempurature measurement by another Tempurature measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Tempurature<T> a, Tempurature<T> b)
		{
			Tempurature.Units TempuratureUnits1 = a._TempuratureUnits1 <= b._TempuratureUnits1 ? a._TempuratureUnits1 : b._TempuratureUnits1;
			T A = a[TempuratureUnits1];
			T B = b[TempuratureUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Tempurature measurement by a numaric scalar value.</summary>
		/// <param name="a">The Tempurature measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Tempurature<T> Divide(Tempurature<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Tempurature measurement by a numaric scalar value.</summary>
		/// <param name="a">The Tempurature measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Tempurature<T> operator /(Tempurature<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Tempurature measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Tempurature<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Tempurature measurement by another Tempurature measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Tempurature<T> a, Tempurature<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Tempurature measurement by another Tempurature measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Tempurature<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an Tempurature measurement is less than another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Tempurature measurement is less than another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Tempurature<T> a, Tempurature<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is less than another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Tempurature<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Tempurature measurement is greater than another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Tempurature measurement is greater than another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Tempurature<T> a, Tempurature<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is greater than another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Tempurature<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Tempurature measurement is less than or equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Tempurature measurement is less than or equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Tempurature<T> a, Tempurature<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is less than or equal to another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Tempurature<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Tempurature measurement is greater than or equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Tempurature measurement is greater than or equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Tempurature<T> a, Tempurature<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is greater than or equal to another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Tempurature<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Tempurature measurement is equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Tempurature measurement is equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Tempurature<T> a, Tempurature<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is equal to another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Tempurature<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Tempurature measurement is not equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Tempurature<T> a, Tempurature<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Tempurature measurement is not equal to another Tempurature measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Tempurature<T> a, Tempurature<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Tempurature measurement is not equal to another Tempurature measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Tempurature<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Tempurature<T>)
			{
				return this == (Tempurature<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Tempurature measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_TempuratureUnits1
				
				;
		}

		/// <summary>Base hashing function for Tempurature measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Time

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Time")]
		public static object Time<T>(T value, object[] units)
		{
			if (units.Length != 1)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Time Factory.");
			}
			if (!(units[0] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Time Factory.");
			}
			return new Time<T>(value
				, (Time.Units)units[0]
				);
		}
	}

	/// <summary>Time measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Time<T>
	{
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<Time.Units, T>();
		internal T _measurement;
		internal Time.Units _TimeUnits1;

		#region Statics

		/// <summary>Converts a Time measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromTimeUnits1">The current units of the measurement.</param>
		/// <param name="toTimeUnits1">The desired units of the measurement.</param>
		/// <returns>The Time measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Time.Units fromTimeUnits1
			, Time.Units toTimeUnits1
			)
		{
			Time<T> measurement = new Time<T>(value
				, fromTimeUnits1
				);
			return measurement[
				 toTimeUnits1
				];
		}

		/// <summary>Converts a Time measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Time measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.TimeUnits from,
			MeasurementUnitsSyntaxTypes.TimeUnits to)
		{
			return Convert(value
			, from._TimeUnits1
			, to._TimeUnits1
			);
		}

		/// <summary>Parses a Time measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Time<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Time<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Time with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Time.</param>
		/// <param name="units">The units of the Time.</param>
		public Time(T measurement, MeasurementUnitsSyntaxTypes.TimeUnits units) : this(measurement
			, units._TimeUnits1
			) { }


		/// <summary>Constructs an Time with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Time.</param>
		/// <param name="TimeUnits1">The units of the Time.</param>
		public Time(T measurement
			, Time.Units TimeUnits1
			)
		{
			_measurement = measurement;
			_TimeUnits1 = TimeUnits1;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Time.Units TimeUnits1
		{
			get { return _TimeUnits1; }
			set
			{
				if (value != _TimeUnits1)
				{
					_measurement = this[value];
					_TimeUnits1 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.TimeUnits units]
		{
			get { return this[units._TimeUnits1]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="TimeUnits1">The #1 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Time.Units TimeUnits1]
		{
			get
			{
				T measurement = _measurement;
				if (TimeUnits1 != _TimeUnits1)
				{
					measurement = Time<T>.Table[(int)_TimeUnits1][(int)TimeUnits1](measurement);
					//if (TimeUnits1 < _TimeUnits1)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits1][(int)TimeUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits1][(int)_TimeUnits1](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Time measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Time measurement.</param>
		public static implicit operator Time<T>((T, MeasurementUnitsSyntaxTypes.TimeUnits) valueTuple)
		{
			return new Time<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Time<T> MathBase(Time<T> a, T b, Func<T, T, T> func)
		{
			return new Time<T>(func(a._measurement, b)
				, a._TimeUnits1
			);
		}

		internal static Time<T> MathBase(Time<T> a, Time<T> b, Func<T, T, T> func)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			T A = a[TimeUnits1];
			T B = b[TimeUnits1];
			T C = func(A, B);
			return new Time<T>(C, TimeUnits1);
		}

		internal static bool LogicBase(Time<T> a, Time<T> b, Func<T, T, bool> func)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			T A = a[TimeUnits1];
			T B = b[TimeUnits1];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Time measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Time<T> Add(Time<T> a, Time<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Time measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Time<T> operator +(Time<T> a, Time<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Time measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Time<T> Add(Time<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Time measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Time<T> Subtract(Time<T> a, Time<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Time measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Time<T> operator -(Time<T> a, Time<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Time measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Time<T> Subtract(Time<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Time by a scalar numeric value.</summary>
		/// <param name="a">The Time measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Time<T> Multiply(Time<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Time by a scalar numeric value.</summary>
		/// <param name="a">The Time measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Time<T> Multiply(T b, Time<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Time by a scalar numeric value.</summary>
		/// <param name="a">The Time measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Time<T> operator *(Time<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Time by a scalar numeric value.</summary>
		/// <param name="a">The Time measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Time<T> operator *(T b, Time<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Time by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Time<T> Add(T b)
		{
			return this * b;
		}

		#region Time<T> * Acceleration<T> = Speed<T>

		/// <summary>Mulitplies Time by Acceleration resulting in Speed.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public static Speed<T> Multiply(Time<T> a, Acceleration<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._LengthUnits1, TimeUnits1, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new Speed<T>(C
				, b._LengthUnits1
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies Time by Acceleration resulting in Speed.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public static Speed<T> operator *(Time<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by Acceleration resulting in Speed.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Speed result of the multiplication.</returns>
		public Speed<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * AngularAcceleration<T> = AngularSpeed<T>

		/// <summary>Mulitplies Time by AngularAcceleration resulting in AngularSpeed.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public static AngularSpeed<T> Multiply(Time<T> a, AngularAcceleration<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._AngleUnits1, TimeUnits1, b._TimeUnits3];
			T C = Statics.Multiplication(A, B);

			return new AngularSpeed<T>(C
				, b._AngleUnits1
				, b._TimeUnits3
				);
		}

		/// <summary>Mulitplies Time by AngularAcceleration resulting in AngularSpeed.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public static AngularSpeed<T> operator *(Time<T> a, AngularAcceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by AngularAcceleration resulting in AngularSpeed.</summary>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The AngularSpeed result of the multiplication.</returns>
		public AngularSpeed<T> Multiply(AngularAcceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * AngularSpeed<T> = Angle<T>

		/// <summary>Mulitplies Time by AngularSpeed resulting in Angle.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The AngularSpeed to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> Multiply(Time<T> a, AngularSpeed<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._AngleUnits1, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Angle<T>(C
				, b._AngleUnits1
				);
		}

		/// <summary>Mulitplies Time by AngularSpeed resulting in Angle.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The AngularSpeed to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> operator *(Time<T> a, AngularSpeed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by AngularSpeed resulting in Angle.</summary>
		/// <param name="b">The AngularSpeed to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public Angle<T> Multiply(AngularSpeed<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * ElectricCurrent<T> = ElectricCharge<T>

		/// <summary>Mulitplies Time by ElectricCurrent resulting in ElectricCharge.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The ElectricCurrent to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public static ElectricCharge<T> Multiply(Time<T> a, ElectricCurrent<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._ElectricChargeUnits1, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new ElectricCharge<T>(C
				, b._ElectricChargeUnits1
				);
		}

		/// <summary>Mulitplies Time by ElectricCurrent resulting in ElectricCharge.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The ElectricCurrent to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public static ElectricCharge<T> operator *(Time<T> a, ElectricCurrent<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by ElectricCurrent resulting in ElectricCharge.</summary>
		/// <param name="b">The ElectricCurrent to multiply by.</param>
		/// <returns>The ElectricCharge result of the multiplication.</returns>
		public ElectricCharge<T> Multiply(ElectricCurrent<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * Force<T> = LinearMassFlow<T>

		/// <summary>Mulitplies Time by Force resulting in LinearMassFlow.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(Time<T> a, Force<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits3 ? a._TimeUnits1 : b._TimeUnits3;

			T A = a[TimeUnits1];
			T B = b[b._MassUnits1, b._LengthUnits2, TimeUnits1, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, b._MassUnits1
				, b._LengthUnits2
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Time by Force resulting in LinearMassFlow.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(Time<T> a, Force<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by Force resulting in LinearMassFlow.</summary>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(Force<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * LinearMassFlow<T> = LinearMass<T>

		/// <summary>Mulitplies Time by LinearMassFlow resulting in LinearMass.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Time<T> a, LinearMassFlow<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits3 ? a._TimeUnits1 : b._TimeUnits3;

			T A = a[TimeUnits1];
			T B = b[b._MassUnits1, b._LengthUnits2, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, b._MassUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Mulitplies Time by LinearMassFlow resulting in LinearMass.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Time<T> a, LinearMassFlow<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by LinearMassFlow resulting in LinearMass.</summary>
		/// <param name="b">The LinearMassFlow to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(LinearMassFlow<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * MassRate<T> = Mass<T>

		/// <summary>Mulitplies Time by MassRate resulting in Mass.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(Time<T> a, MassRate<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._MassUnits1, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, b._MassUnits1
				);
		}

		/// <summary>Mulitplies Time by MassRate resulting in Mass.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(Time<T> a, MassRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by MassRate resulting in Mass.</summary>
		/// <param name="b">The MassRate to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(MassRate<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * Power<T> = Energy<T>

		/// <summary>Mulitplies Time by Power resulting in Energy.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Power to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Time<T> a, Power<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits4 ? a._TimeUnits1 : b._TimeUnits4;

			T A = a[TimeUnits1];
			T B = b[b._MassUnits1, b._LengthUnits2, b._LengthUnits3, TimeUnits1, b._TimeUnits5, b._TimeUnits6];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, b._MassUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				, b._TimeUnits5
				, b._TimeUnits6
				);
		}

		/// <summary>Mulitplies Time by Power resulting in Energy.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Power to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Time<T> a, Power<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by Power resulting in Energy.</summary>
		/// <param name="b">The Power to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Power<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * Speed<T> = Length<T>

		/// <summary>Mulitplies Time by Speed resulting in Length.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> Multiply(Time<T> a, Speed<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;

			T A = a[TimeUnits1];
			T B = b[b._LengthUnits1, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Length<T>(C
				, b._LengthUnits1
				);
		}

		/// <summary>Mulitplies Time by Speed resulting in Length.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> operator *(Time<T> a, Speed<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by Speed resulting in Length.</summary>
		/// <param name="b">The Speed to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public Length<T> Multiply(Speed<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * Time<T> = TimeArea<T>

		/// <summary>Mulitplies Time by Time resulting in TimeArea.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The TimeArea result of the multiplication.</returns>
		public static TimeArea<T> Multiply(Time<T> a, Time<T> b)
		{

			T A = a[a._TimeUnits1];
			T B = b[b._TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new TimeArea<T>(C
				, a._TimeUnits1
				, b._TimeUnits1
				);
		}

		/// <summary>Mulitplies Time by Time resulting in TimeArea.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The TimeArea result of the multiplication.</returns>
		public static TimeArea<T> operator *(Time<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by Time resulting in TimeArea.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The TimeArea result of the multiplication.</returns>
		public TimeArea<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#region Time<T> * VolumeRate<T> = Volume<T>

		/// <summary>Mulitplies Time by VolumeRate resulting in Volume.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> Multiply(Time<T> a, VolumeRate<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits4 ? a._TimeUnits1 : b._TimeUnits4;

			T A = a[TimeUnits1];
			T B = b[b._LengthUnits1, b._LengthUnits2, b._LengthUnits3, TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Volume<T>(C
				, b._LengthUnits1
				, b._LengthUnits2
				, b._LengthUnits3
				);
		}

		/// <summary>Mulitplies Time by VolumeRate resulting in Volume.</summary>
		/// <param name="a">The Time to be multiplied.</param>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> operator *(Time<T> a, VolumeRate<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Time by VolumeRate resulting in Volume.</summary>
		/// <param name="b">The VolumeRate to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public Volume<T> Multiply(VolumeRate<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Time measurement by another Time measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Time<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			T A = a[TimeUnits1];
			T B = b[TimeUnits1];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Time measurement by a numaric scalar value.</summary>
		/// <param name="a">The Time measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Time<T> Divide(Time<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Time measurement by a numaric scalar value.</summary>
		/// <param name="a">The Time measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Time<T> operator /(Time<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Time measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Time<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Time measurement by another Time measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Time<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Time measurement by another Time measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion

		#region LessThan

		/// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Time<T> a, Time<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Time measurement is less than another Time measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Time<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Time<T> a, Time<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Time measurement is greater than another Time measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Time<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Time<T> a, Time<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Time measurement is less than or equal to another Time measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Time<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Time<T> a, Time<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Time measurement is greater than or equal to another Time measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Time<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Time<T> a, Time<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Time measurement is equal to another Time measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Time<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Time<T> a, Time<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Time<T> a, Time<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Time measurement is not equal to another Time measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Time<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Time<T>)
			{
				return this == (Time<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Time measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_TimeUnits1
				
				;
		}

		/// <summary>Base hashing function for Time measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region TimeArea

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Time*Time")]
		public static object TimeArea<T>(T value, object[] units)
		{
			if (units.Length != 2)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to TimeArea Factory.");
			}
			if (!(units[0] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to TimeArea Factory.");
			}
			if (!(units[1] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to TimeArea Factory.");
			}
			return new TimeArea<T>(value
				, (Time.Units)units[0]
				, (Time.Units)units[1]
				);
		}
	}

	/// <summary>TimeArea measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct TimeArea<T>
	{
		internal T _measurement;
		internal Time.Units _TimeUnits1;
		internal Time.Units _TimeUnits2;

		#region Statics

		/// <summary>Converts a TimeArea measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromTimeUnits1">The current units of the measurement.</param>
		/// <param name="fromTimeUnits2">The current units of the measurement.</param>
		/// <param name="toTimeUnits1">The desired units of the measurement.</param>
		/// <param name="toTimeUnits2">The desired units of the measurement.</param>
		/// <returns>The TimeArea measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Time.Units fromTimeUnits1
			, Time.Units fromTimeUnits2
			, Time.Units toTimeUnits1
			, Time.Units toTimeUnits2
			)
		{
			TimeArea<T> measurement = new TimeArea<T>(value
				, fromTimeUnits1
				, fromTimeUnits2
				);
			return measurement[
				 toTimeUnits1
				, toTimeUnits2
				];
		}

		/// <summary>Converts a TimeArea measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The TimeArea measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.TimeAreaBaseUnits from,
			MeasurementUnitsSyntaxTypes.TimeAreaBaseUnits to)
		{
			return Convert(value
			, from._TimeUnits1
			, from._TimeUnits2
			, to._TimeUnits1
			, to._TimeUnits2
			);
		}

		/// <summary>Parses a TimeArea measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, TimeArea<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, TimeArea<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an TimeArea with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the TimeArea.</param>
		/// <param name="units">The units of the TimeArea.</param>
		public TimeArea(T measurement, MeasurementUnitsSyntaxTypes.TimeAreaBaseUnits units) : this(measurement
			, units._TimeUnits1
			, units._TimeUnits2
			) { }


		/// <summary>Constructs an TimeArea with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the TimeArea.</param>
		/// <param name="TimeUnits1">The units of the TimeArea.</param>
		/// <param name="TimeUnits2">The units of the TimeArea.</param>
		public TimeArea(T measurement
			, Time.Units TimeUnits1
			, Time.Units TimeUnits2
			)
		{
			_measurement = measurement;
			_TimeUnits1 = TimeUnits1;
			_TimeUnits2 = TimeUnits2;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Time.Units TimeUnits1
		{
			get { return _TimeUnits1; }
			set
			{
				if (value != _TimeUnits1)
				{
					_measurement = this[value, _TimeUnits2];
					_TimeUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Time.Units TimeUnits2
		{
			get { return _TimeUnits2; }
			set
			{
				if (value != _TimeUnits2)
				{
					_measurement = this[_TimeUnits1, value];
					_TimeUnits2 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.TimeAreaBaseUnits units]
		{
			get { return this[units._TimeUnits1, units._TimeUnits2]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="TimeUnits1">The #1 component of this measurements units.</param>
		/// <param name="TimeUnits2">The #2 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Time.Units TimeUnits1, Time.Units TimeUnits2]
		{
			get
			{
				T measurement = _measurement;
				if (TimeUnits1 != _TimeUnits1)
				{
					measurement = Time<T>.Table[(int)_TimeUnits1][(int)TimeUnits1](measurement);
					//if (TimeUnits1 < _TimeUnits1)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits1][(int)TimeUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits1][(int)_TimeUnits1](measurement);
					//}
				}
				if (TimeUnits2 != _TimeUnits2)
				{
					measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//if (TimeUnits2 < _TimeUnits2)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits2][(int)TimeUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits2][(int)_TimeUnits2](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a TimeArea measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a TimeArea measurement.</param>
		public static implicit operator TimeArea<T>((T, MeasurementUnitsSyntaxTypes.TimeAreaBaseUnits) valueTuple)
		{
			return new TimeArea<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static TimeArea<T> MathBase(TimeArea<T> a, T b, Func<T, T, T> func)
		{
			return new TimeArea<T>(func(a._measurement, b)
				, a._TimeUnits1
				, a._TimeUnits2
			);
		}

		internal static TimeArea<T> MathBase(TimeArea<T> a, TimeArea<T> b, Func<T, T, T> func)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			T C = func(A, B);
			return new TimeArea<T>(C, TimeUnits1, TimeUnits2);
		}

		internal static bool LogicBase(TimeArea<T> a, TimeArea<T> b, Func<T, T, bool> func)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two TimeArea measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static TimeArea<T> Add(TimeArea<T> a, TimeArea<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two TimeArea measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static TimeArea<T> operator +(TimeArea<T> a, TimeArea<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two TimeArea measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public TimeArea<T> Add(TimeArea<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two TimeArea measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static TimeArea<T> Subtract(TimeArea<T> a, TimeArea<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two TimeArea measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static TimeArea<T> operator -(TimeArea<T> a, TimeArea<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two TimeArea measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public TimeArea<T> Subtract(TimeArea<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an TimeArea by a scalar numeric value.</summary>
		/// <param name="a">The TimeArea measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static TimeArea<T> Multiply(TimeArea<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an TimeArea by a scalar numeric value.</summary>
		/// <param name="a">The TimeArea measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static TimeArea<T> Multiply(T b, TimeArea<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an TimeArea by a scalar numeric value.</summary>
		/// <param name="a">The TimeArea measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static TimeArea<T> operator *(TimeArea<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an TimeArea by a scalar numeric value.</summary>
		/// <param name="a">The TimeArea measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static TimeArea<T> operator *(T b, TimeArea<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an TimeArea by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public TimeArea<T> Add(T b)
		{
			return this * b;
		}

		#region TimeArea<T> * Acceleration<T> = Length<T>

		/// <summary>Mulitplies TimeArea by Acceleration resulting in Length.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> Multiply(TimeArea<T> a, Acceleration<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits3 ? a._TimeUnits2 : b._TimeUnits3;

			T A = a[TimeUnits1, TimeUnits2];
			T B = b[b._LengthUnits1, TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Length<T>(C
				, b._LengthUnits1
				);
		}

		/// <summary>Mulitplies TimeArea by Acceleration resulting in Length.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public static Length<T> operator *(TimeArea<T> a, Acceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies TimeArea by Acceleration resulting in Length.</summary>
		/// <param name="b">The Acceleration to multiply by.</param>
		/// <returns>The Length result of the multiplication.</returns>
		public Length<T> Multiply(Acceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region TimeArea<T> * AngularAcceleration<T> = Angle<T>

		/// <summary>Mulitplies TimeArea by AngularAcceleration resulting in Angle.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> Multiply(TimeArea<T> a, AngularAcceleration<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits2 ? a._TimeUnits1 : b._TimeUnits2;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits3 ? a._TimeUnits2 : b._TimeUnits3;

			T A = a[TimeUnits1, TimeUnits2];
			T B = b[b._AngleUnits1, TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new Angle<T>(C
				, b._AngleUnits1
				);
		}

		/// <summary>Mulitplies TimeArea by AngularAcceleration resulting in Angle.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public static Angle<T> operator *(TimeArea<T> a, AngularAcceleration<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies TimeArea by AngularAcceleration resulting in Angle.</summary>
		/// <param name="b">The AngularAcceleration to multiply by.</param>
		/// <returns>The Angle result of the multiplication.</returns>
		public Angle<T> Multiply(AngularAcceleration<T> b)
		{
			return this * b;
		}

		#endregion

		#region TimeArea<T> * Force<T> = LinearMass<T>

		/// <summary>Mulitplies TimeArea by Force resulting in LinearMass.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(TimeArea<T> a, Force<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits3 ? a._TimeUnits1 : b._TimeUnits3;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits4 ? a._TimeUnits2 : b._TimeUnits4;

			T A = a[TimeUnits1, TimeUnits2];
			T B = b[b._MassUnits1, b._LengthUnits2, TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, b._MassUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Mulitplies TimeArea by Force resulting in LinearMass.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(TimeArea<T> a, Force<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies TimeArea by Force resulting in LinearMass.</summary>
		/// <param name="b">The Force to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(Force<T> b)
		{
			return this * b;
		}

		#endregion

		#region TimeArea<T> * Pressure<T> = LinearDensity<T>

		/// <summary>Mulitplies TimeArea by Pressure resulting in LinearDensity.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> Multiply(TimeArea<T> a, Pressure<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits3 ? a._TimeUnits1 : b._TimeUnits3;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits4 ? a._TimeUnits2 : b._TimeUnits4;

			T A = a[TimeUnits1, TimeUnits2];
			T B = b[b._MassUnits1, b._LengthUnits2, TimeUnits1, TimeUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearDensity<T>(C
				, b._MassUnits1
				, b._LengthUnits2
				);
		}

		/// <summary>Mulitplies TimeArea by Pressure resulting in LinearDensity.</summary>
		/// <param name="a">The TimeArea to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public static LinearDensity<T> operator *(TimeArea<T> a, Pressure<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies TimeArea by Pressure resulting in LinearDensity.</summary>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The LinearDensity result of the multiplication.</returns>
		public LinearDensity<T> Multiply(Pressure<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an TimeArea measurement by another TimeArea measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(TimeArea<T> a, TimeArea<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;
			Time.Units TimeUnits2 = a._TimeUnits2 <= b._TimeUnits2 ? a._TimeUnits2 : b._TimeUnits2;
			T A = a[TimeUnits1, TimeUnits2];
			T B = b[TimeUnits1, TimeUnits2];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this TimeArea measurement by a numaric scalar value.</summary>
		/// <param name="a">The TimeArea measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static TimeArea<T> Divide(TimeArea<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this TimeArea measurement by a numaric scalar value.</summary>
		/// <param name="a">The TimeArea measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static TimeArea<T> operator /(TimeArea<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this TimeArea measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public TimeArea<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an TimeArea measurement by another TimeArea measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(TimeArea<T> a, TimeArea<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an TimeArea measurement by another TimeArea measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(TimeArea<T> b)
		{
			return this / b;
		}


		#region TimeArea<T> / Time<T> = Time<T>

		/// <summary>Divides TimeArea by Time resulting in Time.</summary>
		/// <param name="a">The TimeArea to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(TimeArea<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits1 <= b._TimeUnits1 ? a._TimeUnits1 : b._TimeUnits1;

			T A = a[TimeUnits1, a._TimeUnits2];
			T B = b[TimeUnits1];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, a._TimeUnits2
				);
		}

		/// <summary>Divides TimeArea by Time resulting in Time.</summary>
		/// <param name="a">The TimeArea to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(TimeArea<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides TimeArea by Time resulting in Time.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an TimeArea measurement is less than another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an TimeArea measurement is less than another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(TimeArea<T> a, TimeArea<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is less than another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(TimeArea<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an TimeArea measurement is greater than another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an TimeArea measurement is greater than another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(TimeArea<T> a, TimeArea<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is greater than another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(TimeArea<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an TimeArea measurement is less than or equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an TimeArea measurement is less than or equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(TimeArea<T> a, TimeArea<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is less than or equal to another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(TimeArea<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an TimeArea measurement is greater than or equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an TimeArea measurement is greater than or equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(TimeArea<T> a, TimeArea<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is greater than or equal to another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(TimeArea<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an TimeArea measurement is equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an TimeArea measurement is equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(TimeArea<T> a, TimeArea<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is equal to another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(TimeArea<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an TimeArea measurement is not equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(TimeArea<T> a, TimeArea<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an TimeArea measurement is not equal to another TimeArea measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(TimeArea<T> a, TimeArea<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an TimeArea measurement is not equal to another TimeArea measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(TimeArea<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is TimeArea<T>)
			{
				return this == (TimeArea<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the TimeArea measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_TimeUnits1 + "*" + _TimeUnits2
				
				;
		}

		/// <summary>Base hashing function for TimeArea measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region Volume

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length*Length*Length")]
		public static object Volume<T>(T value, object[] units)
		{
			if (units.Length != 3)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Volume Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Volume Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Volume Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to Volume Factory.");
			}
			return new Volume<T>(value
				, (Length.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				);
		}
	}

	/// <summary>Volume measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct Volume<T>
	{
		internal T _measurement;
		internal Length.Units _LengthUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;

		#region Statics

		/// <summary>Converts a Volume measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <returns>The Volume measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Length.Units toLengthUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			)
		{
			Volume<T> measurement = new Volume<T>(value
				, fromLengthUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				);
			return measurement[
				 toLengthUnits1
				, toLengthUnits2
				, toLengthUnits3
				];
		}

		/// <summary>Converts a Volume measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The Volume measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.VolumeBaseUnits from,
			MeasurementUnitsSyntaxTypes.VolumeBaseUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, to._LengthUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			);
		}

		/// <summary>Parses a Volume measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, Volume<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, Volume<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an Volume with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Volume.</param>
		/// <param name="units">The units of the Volume.</param>
		public Volume(T measurement, MeasurementUnitsSyntaxTypes.VolumeBaseUnits units) : this(measurement
			, units._LengthUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			) { }


		/// <summary>Constructs an Volume with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the Volume.</param>
		/// <param name="LengthUnits1">The units of the Volume.</param>
		/// <param name="LengthUnits2">The units of the Volume.</param>
		/// <param name="LengthUnits3">The units of the Volume.</param>
		public Volume(T measurement
			, Length.Units LengthUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_LengthUnits1, value, _LengthUnits3];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_LengthUnits1, _LengthUnits2, value];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.VolumeBaseUnits units]
		{
			get { return this[units._LengthUnits1, units._LengthUnits2, units._LengthUnits3]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//if (LengthUnits3 < _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a Volume measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a Volume measurement.</param>
		public static implicit operator Volume<T>((T, MeasurementUnitsSyntaxTypes.VolumeBaseUnits) valueTuple)
		{
			return new Volume<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static Volume<T> MathBase(Volume<T> a, T b, Func<T, T, T> func)
		{
			return new Volume<T>(func(a._measurement, b)
				, a._LengthUnits1
				, a._LengthUnits2
				, a._LengthUnits3
			);
		}

		internal static Volume<T> MathBase(Volume<T> a, Volume<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3];
			T C = func(A, B);
			return new Volume<T>(C, LengthUnits1, LengthUnits2, LengthUnits3);
		}

		internal static bool LogicBase(Volume<T> a, Volume<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two Volume measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Volume<T> Add(Volume<T> a, Volume<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two Volume measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static Volume<T> operator +(Volume<T> a, Volume<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two Volume measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public Volume<T> Add(Volume<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two Volume measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Volume<T> Subtract(Volume<T> a, Volume<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two Volume measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static Volume<T> operator -(Volume<T> a, Volume<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two Volume measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public Volume<T> Subtract(Volume<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an Volume by a scalar numeric value.</summary>
		/// <param name="a">The Volume measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Volume<T> Multiply(Volume<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an Volume by a scalar numeric value.</summary>
		/// <param name="a">The Volume measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Volume<T> Multiply(T b, Volume<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Volume by a scalar numeric value.</summary>
		/// <param name="a">The Volume measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Volume<T> operator *(Volume<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an Volume by a scalar numeric value.</summary>
		/// <param name="a">The Volume measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static Volume<T> operator *(T b, Volume<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an Volume by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public Volume<T> Add(T b)
		{
			return this * b;
		}

		#region Volume<T> * AreaDensity<T> = LinearMass<T>

		/// <summary>Mulitplies Volume by AreaDensity resulting in LinearMass.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> Multiply(Volume<T> a, AreaDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;

			T A = a[LengthUnits1, LengthUnits2, a._LengthUnits3];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMass<T>(C
				, b._MassUnits1
				, a._LengthUnits3
				);
		}

		/// <summary>Mulitplies Volume by AreaDensity resulting in LinearMass.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public static LinearMass<T> operator *(Volume<T> a, AreaDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Volume by AreaDensity resulting in LinearMass.</summary>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMass result of the multiplication.</returns>
		public LinearMass<T> Multiply(AreaDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region Volume<T> * Density<T> = Mass<T>

		/// <summary>Mulitplies Volume by Density resulting in Mass.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> Multiply(Volume<T> a, Density<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits4 ? a._LengthUnits3 : b._LengthUnits4;

			T A = a[LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2, LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new Mass<T>(C
				, b._MassUnits1
				);
		}

		/// <summary>Mulitplies Volume by Density resulting in Mass.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public static Mass<T> operator *(Volume<T> a, Density<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Volume by Density resulting in Mass.</summary>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The Mass result of the multiplication.</returns>
		public Mass<T> Multiply(Density<T> b)
		{
			return this * b;
		}

		#endregion

		#region Volume<T> * Pressure<T> = Energy<T>

		/// <summary>Mulitplies Volume by Pressure resulting in Energy.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> Multiply(Volume<T> a, Pressure<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._LengthUnits2, a._LengthUnits3];
			T B = b[b._MassUnits1, LengthUnits1, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Energy<T>(C
				, b._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies Volume by Pressure resulting in Energy.</summary>
		/// <param name="a">The Volume to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public static Energy<T> operator *(Volume<T> a, Pressure<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies Volume by Pressure resulting in Energy.</summary>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Energy result of the multiplication.</returns>
		public Energy<T> Multiply(Pressure<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an Volume measurement by another Volume measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(Volume<T> a, Volume<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
		/// <param name="a">The Volume measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Volume<T> Divide(Volume<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
		/// <param name="a">The Volume measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static Volume<T> operator /(Volume<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this Volume measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public Volume<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an Volume measurement by another Volume measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(Volume<T> a, Volume<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an Volume measurement by another Volume measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(Volume<T> b)
		{
			return this / b;
		}


		#region Volume<T> / Area<T> = Length<T>

		/// <summary>Divides Volume by Area resulting in Length.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> Divide(Volume<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[LengthUnits1, LengthUnits2, a._LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2];
			T C = Statics.Division(A, B);

			return new Length<T>(C
				, a._LengthUnits3
				);
		}

		/// <summary>Divides Volume by Area resulting in Length.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public static Length<T> operator /(Volume<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Volume by Area resulting in Length.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Length result of the division.</returns>
		public Length<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region Volume<T> / Length<T> = Area<T>

		/// <summary>Divides Volume by Length resulting in Area.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(Volume<T> a, Length<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;

			T A = a[LengthUnits1, a._LengthUnits2, a._LengthUnits3];
			T B = b[LengthUnits1];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, a._LengthUnits2
				, a._LengthUnits3
				);
		}

		/// <summary>Divides Volume by Length resulting in Area.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(Volume<T> a, Length<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Volume by Length resulting in Area.</summary>
		/// <param name="b">The Length to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(Length<T> b)
		{
			return this / b;
		}

		#endregion


		#region Volume<T> / Time<T> = VolumeRate<T>

		/// <summary>Divides Volume by Time resulting in VolumeRate.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> Divide(Volume<T> a, Time<T> b)
		{

			T A = a[a._LengthUnits1, a._LengthUnits2, a._LengthUnits3];
			T B = b[b._TimeUnits1];
			T C = Statics.Division(A, B);

			return new VolumeRate<T>(C
				, a._LengthUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, b._TimeUnits1
				);
		}

		/// <summary>Divides Volume by Time resulting in VolumeRate.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public static VolumeRate<T> operator /(Volume<T> a, Time<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Volume by Time resulting in VolumeRate.</summary>
		/// <param name="b">The Time to divide by.</param>
		/// <returns>The VolumeRate result of the division.</returns>
		public VolumeRate<T> Divide(Time<T> b)
		{
			return this / b;
		}

		#endregion


		#region Volume<T> / VolumeRate<T> = Time<T>

		/// <summary>Divides Volume by VolumeRate resulting in Time.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> Divide(Volume<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;

			T A = a[LengthUnits1, LengthUnits2, LengthUnits3];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3, b._TimeUnits4];
			T C = Statics.Division(A, B);

			return new Time<T>(C
				, b._TimeUnits4
				);
		}

		/// <summary>Divides Volume by VolumeRate resulting in Time.</summary>
		/// <param name="a">The Volume to be divided.</param>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public static Time<T> operator /(Volume<T> a, VolumeRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides Volume by VolumeRate resulting in Time.</summary>
		/// <param name="b">The VolumeRate to divide by.</param>
		/// <returns>The Time result of the division.</returns>
		public Time<T> Divide(VolumeRate<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(Volume<T> a, Volume<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an Volume measurement is less than another Volume measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(Volume<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(Volume<T> a, Volume<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an Volume measurement is greater than another Volume measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(Volume<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(Volume<T> a, Volume<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an Volume measurement is less than or equal to another Volume measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(Volume<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(Volume<T> a, Volume<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an Volume measurement is greater than or equal to another Volume measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(Volume<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(Volume<T> a, Volume<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an Volume measurement is equal to another Volume measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(Volume<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(Volume<T> a, Volume<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(Volume<T> a, Volume<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an Volume measurement is not equal to another Volume measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(Volume<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is Volume<T>)
			{
				return this == (Volume<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the Volume measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1 + "*" + _LengthUnits2 + "*" + _LengthUnits3
				
				;
		}

		/// <summary>Base hashing function for Volume measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion

	#region VolumeRate

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("Length*Length*Length/Time")]
		public static object VolumeRate<T>(T value, object[] units)
		{
			if (units.Length != 4)
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to VolumeRate Factory.");
			}
			if (!(units[0] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to VolumeRate Factory.");
			}
			if (!(units[1] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to VolumeRate Factory.");
			}
			if (!(units[2] is Length.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to VolumeRate Factory.");
			}
			if (!(units[3] is Time.Units))
			{
				throw new Exception("Bug in JeezFoundation.Algorithm. Invalid parameters to VolumeRate Factory.");
			}
			return new VolumeRate<T>(value
				, (Length.Units)units[0]
				, (Length.Units)units[1]
				, (Length.Units)units[2]
				, (Time.Units)units[3]
				);
		}
	}

	/// <summary>VolumeRate measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct VolumeRate<T>
	{
		internal T _measurement;
		internal Length.Units _LengthUnits1;
		internal Length.Units _LengthUnits2;
		internal Length.Units _LengthUnits3;
		internal Time.Units _TimeUnits4;

		#region Statics

		/// <summary>Converts a VolumeRate measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="fromLengthUnits1">The current units of the measurement.</param>
		/// <param name="fromLengthUnits2">The current units of the measurement.</param>
		/// <param name="fromLengthUnits3">The current units of the measurement.</param>
		/// <param name="fromTimeUnits4">The current units of the measurement.</param>
		/// <param name="toLengthUnits1">The desired units of the measurement.</param>
		/// <param name="toLengthUnits2">The desired units of the measurement.</param>
		/// <param name="toLengthUnits3">The desired units of the measurement.</param>
		/// <param name="toTimeUnits4">The desired units of the measurement.</param>
		/// <returns>The VolumeRate measurement converted into the desired units.</returns>
		public static T Convert(T value
			, Length.Units fromLengthUnits1
			, Length.Units fromLengthUnits2
			, Length.Units fromLengthUnits3
			, Time.Units fromTimeUnits4
			, Length.Units toLengthUnits1
			, Length.Units toLengthUnits2
			, Length.Units toLengthUnits3
			, Time.Units toTimeUnits4
			)
		{
			VolumeRate<T> measurement = new VolumeRate<T>(value
				, fromLengthUnits1
				, fromLengthUnits2
				, fromLengthUnits3
				, fromTimeUnits4
				);
			return measurement[
				 toLengthUnits1
				, toLengthUnits2
				, toLengthUnits3
				, toTimeUnits4
				];
		}

		/// <summary>Converts a VolumeRate measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The VolumeRate measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.VolumeRateBaseUnits from,
			MeasurementUnitsSyntaxTypes.VolumeRateBaseUnits to)
		{
			return Convert(value
			, from._LengthUnits1
			, from._LengthUnits2
			, from._LengthUnits3
			, from._TimeUnits4
			, to._LengthUnits1
			, to._LengthUnits2
			, to._LengthUnits3
			, to._TimeUnits4
			);
		}

		/// <summary>Parses a VolumeRate measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static (bool Success, VolumeRate<T>? Value) TryParse(string @string, Func<string, (bool Success, T Value)> tryParse = null) => Measurement.TryParse<T, VolumeRate<T>>(@string, tryParse);

		#endregion

		#region Constructors

		/// <summary>Constructs an VolumeRate with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the VolumeRate.</param>
		/// <param name="units">The units of the VolumeRate.</param>
		public VolumeRate(T measurement, MeasurementUnitsSyntaxTypes.VolumeRateBaseUnits units) : this(measurement
			, units._LengthUnits1
			, units._LengthUnits2
			, units._LengthUnits3
			, units._TimeUnits4
			) { }


		/// <summary>Constructs an VolumeRate with the measurement value and units.</summary>
		/// <param name="measurement">The measurement value of the VolumeRate.</param>
		/// <param name="LengthUnits1">The units of the VolumeRate.</param>
		/// <param name="LengthUnits2">The units of the VolumeRate.</param>
		/// <param name="LengthUnits3">The units of the VolumeRate.</param>
		/// <param name="TimeUnits4">The units of the VolumeRate.</param>
		public VolumeRate(T measurement
			, Length.Units LengthUnits1
			, Length.Units LengthUnits2
			, Length.Units LengthUnits3
			, Time.Units TimeUnits4
			)
		{
			_measurement = measurement;
			_LengthUnits1 = LengthUnits1;
			_LengthUnits2 = LengthUnits2;
			_LengthUnits3 = LengthUnits3;
			_TimeUnits4 = TimeUnits4;
		}

		#endregion

		#region Properties

		/// <summary>The #1 component of this measurements units.</summary>
		public Length.Units LengthUnits1
		{
			get { return _LengthUnits1; }
			set
			{
				if (value != _LengthUnits1)
				{
					_measurement = this[value, _LengthUnits2, _LengthUnits3, _TimeUnits4];
					_LengthUnits1 = value;
				}
			}
		}

		/// <summary>The #2 component of this measurements units.</summary>
		public Length.Units LengthUnits2
		{
			get { return _LengthUnits2; }
			set
			{
				if (value != _LengthUnits2)
				{
					_measurement = this[_LengthUnits1, value, _LengthUnits3, _TimeUnits4];
					_LengthUnits2 = value;
				}
			}
		}

		/// <summary>The #3 component of this measurements units.</summary>
		public Length.Units LengthUnits3
		{
			get { return _LengthUnits3; }
			set
			{
				if (value != _LengthUnits3)
				{
					_measurement = this[_LengthUnits1, _LengthUnits2, value, _TimeUnits4];
					_LengthUnits3 = value;
				}
			}
		}

		/// <summary>The #4 component of this measurements units.</summary>
		public Time.Units TimeUnits4
		{
			get { return _TimeUnits4; }
			set
			{
				if (value != _TimeUnits4)
				{
					_measurement = this[_LengthUnits1, _LengthUnits2, _LengthUnits3, value];
					_TimeUnits4 = value;
				}
			}
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="units">The units to get the measurement in.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.VolumeRateBaseUnits units]
		{
			get { return this[units._LengthUnits1, units._LengthUnits2, units._LengthUnits3, units._TimeUnits4]; }
		}

		/// <summary>Gets the measurement in the specified units.</summary>
		/// <param name="LengthUnits1">The #1 component of this measurements units.</param>
		/// <param name="LengthUnits2">The #2 component of this measurements units.</param>
		/// <param name="LengthUnits3">The #3 component of this measurements units.</param>
		/// <param name="TimeUnits4">The #4 component of this measurements units.</param>
		/// <returns>The measurement value in the specified units.</returns>
		public T this[Length.Units LengthUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4]
		{
			get
			{
				T measurement = _measurement;
				if (LengthUnits1 != _LengthUnits1)
				{
					measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//if (LengthUnits1 < _LengthUnits1)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits1][(int)LengthUnits1](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits1][(int)_LengthUnits1](measurement);
					//}
				}
				if (LengthUnits2 != _LengthUnits2)
				{
					measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//if (LengthUnits2 < _LengthUnits2)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits2][(int)LengthUnits2](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits2][(int)_LengthUnits2](measurement);
					//}
				}
				if (LengthUnits3 != _LengthUnits3)
				{
					measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//if (LengthUnits3 < _LengthUnits3)
					//{
					//	measurement = Length<T>.Table[(int)_LengthUnits3][(int)LengthUnits3](measurement);
					//}
					//else
					//{
					//	measurement = Length<T>.Table[(int)LengthUnits3][(int)_LengthUnits3](measurement);
					//}
				}
				if (TimeUnits4 != _TimeUnits4)
				{
					measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//if (TimeUnits4 > _TimeUnits4)
					//{
					//	measurement = Time<T>.Table[(int)_TimeUnits4][(int)TimeUnits4](measurement);
					//}
					//else
					//{
					//	measurement = Time<T>.Table[(int)TimeUnits4][(int)_TimeUnits4](measurement);
					//}
				}
				return measurement;
			}
		}

		#endregion

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a VolumeRate measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a VolumeRate measurement.</param>
		public static implicit operator VolumeRate<T>((T, MeasurementUnitsSyntaxTypes.VolumeRateBaseUnits) valueTuple)
		{
			return new VolumeRate<T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

		#region Mathematics

		#region Bases

		internal static VolumeRate<T> MathBase(VolumeRate<T> a, T b, Func<T, T, T> func)
		{
			return new VolumeRate<T>(func(a._measurement, b)
				, a._LengthUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits4
			);
		}

		internal static VolumeRate<T> MathBase(VolumeRate<T> a, VolumeRate<T> b, Func<T, T, T> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			T C = func(A, B);
			return new VolumeRate<T>(C, LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4);
		}

		internal static bool LogicBase(VolumeRate<T> a, VolumeRate<T> b, Func<T, T, bool> func)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			return func(A, B);
		}

		#endregion

		#region Add

		/// <summary>Adds two VolumeRate measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static VolumeRate<T> Add(VolumeRate<T> a, VolumeRate<T> b)
		{
			return MathBase(a, b, Statics.Addition);
		}

		/// <summary>Adds two VolumeRate measurements.</summary>
		/// <param name="a">The first operand of the addition.</param>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public static VolumeRate<T> operator +(VolumeRate<T> a, VolumeRate<T> b)
		{
			return Add(a, b);
		}

		/// <summary>Adds two VolumeRate measurements.</summary>
		/// <param name="b">The second operand of the addition.</param>
		/// <returns>The result of the addition operation.</returns>
		public VolumeRate<T> Add(VolumeRate<T> b)
		{
			return this + b;
		}

		#endregion

		#region Subtract

		/// <summary>Subtracts two VolumeRate measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static VolumeRate<T> Subtract(VolumeRate<T> a, VolumeRate<T> b)
		{
			return MathBase(a, b, Statics.Subtraction);
		}

		/// <summary>Subtracts two VolumeRate measurements.</summary>
		/// <param name="a">The first operand of the subtraction.</param>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public static VolumeRate<T> operator -(VolumeRate<T> a, VolumeRate<T> b)
		{
			return Subtract(a, b);
		}

		/// <summary>Subtracts two VolumeRate measurements.</summary>
		/// <param name="b">The second operand of the subtraction.</param>
		/// <returns>The result of the subtraction.</returns>
		public VolumeRate<T> Subtract(VolumeRate<T> b)
		{
			return this - b;
		}

		#endregion

		#region Multiply

		/// <summary>Multiplies an VolumeRate by a scalar numeric value.</summary>
		/// <param name="a">The VolumeRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static VolumeRate<T> Multiply(VolumeRate<T> a, T b)
		{
			return MathBase(a, b, Statics.Multiplication);
		}

		/// <summary>Multiplies an VolumeRate by a scalar numeric value.</summary>
		/// <param name="a">The VolumeRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static VolumeRate<T> Multiply(T b, VolumeRate<T> a)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an VolumeRate by a scalar numeric value.</summary>
		/// <param name="a">The VolumeRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static VolumeRate<T> operator *(VolumeRate<T> a, T b)
		{
			return Multiply(a, b);
		}

		/// <summary>Multiplies an VolumeRate by a scalar numeric value.</summary>
		/// <param name="a">The VolumeRate measurement to multiply.</param>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public static VolumeRate<T> operator *(T b, VolumeRate<T> a)
		{
			return Multiply(b, a);
		}

		/// <summary>Multiplies an VolumeRate by a scalar numeric value.</summary>
		/// <param name="b">The scalar numeric value to multiply the measurement by.</param>
		/// <returns>The result of the multiplication.</returns>
		public VolumeRate<T> Add(T b)
		{
			return this * b;
		}

		#region VolumeRate<T> * AreaDensity<T> = LinearMassFlow<T>

		/// <summary>Mulitplies VolumeRate by AreaDensity resulting in LinearMassFlow.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> Multiply(VolumeRate<T> a, AreaDensity<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;

			T A = a[LengthUnits1, LengthUnits2, a._LengthUnits3, a._TimeUnits4];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2];
			T C = Statics.Multiplication(A, B);

			return new LinearMassFlow<T>(C
				, b._MassUnits1
				, a._LengthUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies VolumeRate by AreaDensity resulting in LinearMassFlow.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public static LinearMassFlow<T> operator *(VolumeRate<T> a, AreaDensity<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies VolumeRate by AreaDensity resulting in LinearMassFlow.</summary>
		/// <param name="b">The AreaDensity to multiply by.</param>
		/// <returns>The LinearMassFlow result of the multiplication.</returns>
		public LinearMassFlow<T> Multiply(AreaDensity<T> b)
		{
			return this * b;
		}

		#endregion

		#region VolumeRate<T> * Density<T> = MassRate<T>

		/// <summary>Mulitplies VolumeRate by Density resulting in MassRate.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> Multiply(VolumeRate<T> a, Density<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits3 ? a._LengthUnits2 : b._LengthUnits3;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits4 ? a._LengthUnits3 : b._LengthUnits4;

			T A = a[LengthUnits1, LengthUnits2, LengthUnits3, a._TimeUnits4];
			T B = b[b._MassUnits1, LengthUnits1, LengthUnits2, LengthUnits3];
			T C = Statics.Multiplication(A, B);

			return new MassRate<T>(C
				, b._MassUnits1
				, a._TimeUnits4
				);
		}

		/// <summary>Mulitplies VolumeRate by Density resulting in MassRate.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public static MassRate<T> operator *(VolumeRate<T> a, Density<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies VolumeRate by Density resulting in MassRate.</summary>
		/// <param name="b">The Density to multiply by.</param>
		/// <returns>The MassRate result of the multiplication.</returns>
		public MassRate<T> Multiply(Density<T> b)
		{
			return this * b;
		}

		#endregion

		#region VolumeRate<T> * Pressure<T> = Power<T>

		/// <summary>Mulitplies VolumeRate by Pressure resulting in Power.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> Multiply(VolumeRate<T> a, Pressure<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits2 ? a._LengthUnits1 : b._LengthUnits2;

			T A = a[LengthUnits1, a._LengthUnits2, a._LengthUnits3, a._TimeUnits4];
			T B = b[b._MassUnits1, LengthUnits1, b._TimeUnits3, b._TimeUnits4];
			T C = Statics.Multiplication(A, B);

			return new Power<T>(C
				, b._MassUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				, a._TimeUnits4
				, b._TimeUnits3
				, b._TimeUnits4
				);
		}

		/// <summary>Mulitplies VolumeRate by Pressure resulting in Power.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public static Power<T> operator *(VolumeRate<T> a, Pressure<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies VolumeRate by Pressure resulting in Power.</summary>
		/// <param name="b">The Pressure to multiply by.</param>
		/// <returns>The Power result of the multiplication.</returns>
		public Power<T> Multiply(Pressure<T> b)
		{
			return this * b;
		}

		#endregion

		#region VolumeRate<T> * Time<T> = Volume<T>

		/// <summary>Mulitplies VolumeRate by Time resulting in Volume.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> Multiply(VolumeRate<T> a, Time<T> b)
		{
			Time.Units TimeUnits1 = a._TimeUnits4 <= b._TimeUnits1 ? a._TimeUnits4 : b._TimeUnits1;

			T A = a[a._LengthUnits1, a._LengthUnits2, a._LengthUnits3, TimeUnits1];
			T B = b[TimeUnits1];
			T C = Statics.Multiplication(A, B);

			return new Volume<T>(C
				, a._LengthUnits1
				, a._LengthUnits2
				, a._LengthUnits3
				);
		}

		/// <summary>Mulitplies VolumeRate by Time resulting in Volume.</summary>
		/// <param name="a">The VolumeRate to be multiplied.</param>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public static Volume<T> operator *(VolumeRate<T> a, Time<T> b)
		{
			return Multiply(a, b);
		}

		/// <summary>Mulitplies VolumeRate by Time resulting in Volume.</summary>
		/// <param name="b">The Time to multiply by.</param>
		/// <returns>The Volume result of the multiplication.</returns>
		public Volume<T> Multiply(Time<T> b)
		{
			return this * b;
		}

		#endregion

		#endregion

		#region Divide

		/// <summary>Divides an VolumeRate measurement by another VolumeRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T Divide(VolumeRate<T> a, VolumeRate<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;
			Length.Units LengthUnits3 = a._LengthUnits3 <= b._LengthUnits3 ? a._LengthUnits3 : b._LengthUnits3;
			Time.Units TimeUnits4 = a._TimeUnits4 <= b._TimeUnits4 ? a._TimeUnits4 : b._TimeUnits4;
			T A = a[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			T B = b[LengthUnits1, LengthUnits2, LengthUnits3, TimeUnits4];
			return Statics.Division(A, B);
		}

		/// <summary>Divides this VolumeRate measurement by a numaric scalar value.</summary>
		/// <param name="a">The VolumeRate measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static VolumeRate<T> Divide(VolumeRate<T> a, T b)
		{
			return MathBase(a, b, Statics.Division);
		}

		/// <summary>Divides this VolumeRate measurement by a numaric scalar value.</summary>
		/// <param name="a">The VolumeRate measurement to divide.</param>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public static VolumeRate<T> operator /(VolumeRate<T> a, T b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides this VolumeRate measurement by a numaric scalar value.</summary>
		/// <param name="b">The numeric scalar to divide by.</param>
		/// <returns>The result of the division.</returns>
		public VolumeRate<T> Divide(T b)
		{
			return this / b;
		}

		/// <summary>Divides an VolumeRate measurement by another VolumeRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="a">The first operand of the division operation.</param>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public static T operator /(VolumeRate<T> a, VolumeRate<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides an VolumeRate measurement by another VolumeRate measurement resulting in a scalar numeric value.</summary>
		/// <param name="b">The second operand of the division operation.</param>
		/// <returns>The scalar numeric value result from the division.</returns>
		public T Divide(VolumeRate<T> b)
		{
			return this / b;
		}


		#region VolumeRate<T> / Area<T> = Speed<T>

		/// <summary>Divides VolumeRate by Area resulting in Speed.</summary>
		/// <param name="a">The VolumeRate to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> Divide(VolumeRate<T> a, Area<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Length.Units LengthUnits2 = a._LengthUnits2 <= b._LengthUnits2 ? a._LengthUnits2 : b._LengthUnits2;

			T A = a[LengthUnits1, LengthUnits2, a._LengthUnits3, a._TimeUnits4];
			T B = b[LengthUnits1, LengthUnits2];
			T C = Statics.Division(A, B);

			return new Speed<T>(C
				, a._LengthUnits3
				, a._TimeUnits4
				);
		}

		/// <summary>Divides VolumeRate by Area resulting in Speed.</summary>
		/// <param name="a">The VolumeRate to be divided.</param>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public static Speed<T> operator /(VolumeRate<T> a, Area<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides VolumeRate by Area resulting in Speed.</summary>
		/// <param name="b">The Area to divide by.</param>
		/// <returns>The Speed result of the division.</returns>
		public Speed<T> Divide(Area<T> b)
		{
			return this / b;
		}

		#endregion


		#region VolumeRate<T> / Speed<T> = Area<T>

		/// <summary>Divides VolumeRate by Speed resulting in Area.</summary>
		/// <param name="a">The VolumeRate to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> Divide(VolumeRate<T> a, Speed<T> b)
		{
			Length.Units LengthUnits1 = a._LengthUnits1 <= b._LengthUnits1 ? a._LengthUnits1 : b._LengthUnits1;
			Time.Units TimeUnits2 = a._TimeUnits4 <= b._TimeUnits2 ? a._TimeUnits4 : b._TimeUnits2;

			T A = a[LengthUnits1, a._LengthUnits2, a._LengthUnits3, TimeUnits2];
			T B = b[LengthUnits1, TimeUnits2];
			T C = Statics.Division(A, B);

			return new Area<T>(C
				, a._LengthUnits2
				, a._LengthUnits3
				);
		}

		/// <summary>Divides VolumeRate by Speed resulting in Area.</summary>
		/// <param name="a">The VolumeRate to be divided.</param>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public static Area<T> operator /(VolumeRate<T> a, Speed<T> b)
		{
			return Divide(a, b);
		}

		/// <summary>Divides VolumeRate by Speed resulting in Area.</summary>
		/// <param name="b">The Speed to divide by.</param>
		/// <returns>The Area result of the division.</returns>
		public Area<T> Divide(Speed<T> b)
		{
			return this / b;
		}

		#endregion

		#endregion

		#region LessThan

		/// <summary>Determines if an VolumeRate measurement is less than another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool LessThan(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.LessThan);
		}

		/// <summary>Determines if an VolumeRate measurement is less than another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the less than operation.</param>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public static bool operator <(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LessThan(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is less than another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the less than operation.</param>
		/// <returns>True if the first operand is less than the second operand. False if not.</returns>
		public bool LessThan(VolumeRate<T> b)
		{
			return this < b;
		}

		#endregion

		#region GreaterThan

		/// <summary>Determines if an VolumeRate measurement is greater than another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool GreaterThan(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThan);
		}

		/// <summary>Determines if an VolumeRate measurement is greater than another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the greater than operation.</param>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public static bool operator >(VolumeRate<T> a, VolumeRate<T> b)
		{
			return GreaterThan(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is greater than another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the greater than operation.</param>
		/// <returns>True if the first operand is greater than the second operand. False if not.</returns>
		public bool GreaterThan(VolumeRate<T> b)
		{
			return this > b;
		}

		#endregion

		#region LessThanOrEqual

		/// <summary>Determines if an VolumeRate measurement is less than or equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool LessThanOrEqual(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.LessThanOrEqual);
		}

		/// <summary>Determines if an VolumeRate measurement is less than or equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the less than or equal to operation.</param>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public static bool operator <=(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LessThanOrEqual(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is less than or equal to another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the less than or equal to operation.</param>
		/// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
		public bool LessThanOrEqual(VolumeRate<T> b)
		{
			return this <= b;
		}

		#endregion

		#region GreaterThanOrEqual

		/// <summary>Determines if an VolumeRate measurement is greater than or equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool GreaterThanOrEqual(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.GreaterThanOrEqual);
		}

		/// <summary>Determines if an VolumeRate measurement is greater than or equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the greater than or equal to operation.</param>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public static bool operator >=(VolumeRate<T> a, VolumeRate<T> b)
		{
			return GreaterThanOrEqual(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is greater than or equal to another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the greater than or equal to operation.</param>
		/// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
		public bool GreaterThanOrEqual(VolumeRate<T> b)
		{
			return this >= b;
		}

		#endregion

		#region Equal

		/// <summary>Determines if an VolumeRate measurement is equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool Equal(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.Equate);
		}

		/// <summary>Determines if an VolumeRate measurement is equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the equal to operation.</param>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public static bool operator ==(VolumeRate<T> a, VolumeRate<T> b)
		{
			return Equal(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is equal to another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the equal to operation.</param>
		/// <returns>True if the first operand is equal to the second operand. False if not.</returns>
		public bool Equal(VolumeRate<T> b)
		{
			return this == b;
		}

		#endregion

		#region NotEqual

		/// <summary>Determines if an VolumeRate measurement is not equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool NotEqual(VolumeRate<T> a, VolumeRate<T> b)
		{
			return LogicBase(a, b, Statics.Inequate);
		}

		/// <summary>Determines if an VolumeRate measurement is not equal to another VolumeRate measurement.</summary>
		/// <param name="a">The first operand of the not equal to operation.</param>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public static bool operator !=(VolumeRate<T> a, VolumeRate<T> b)
		{
			return NotEqual(a, b);
		}

		/// <summary>Determines if an VolumeRate measurement is not equal to another VolumeRate measurement.</summary>
		/// <param name="b">The second operand of the not equal to operation.</param>
		/// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
		public bool NotEqual(VolumeRate<T> b)
		{
			return this != b;
		}

		#endregion

		#endregion

		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
		/// <param name="obj">The object to check for equality with.</param>
		/// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
		{
			if (obj is VolumeRate<T>)
			{
				return this == (VolumeRate<T>)obj;
			}
			return false;
		}

		/// <summary>Converts the VolumeRate measurement to a string represenation.</summary>
		/// <returns>The string representation of the measurement.</returns>
		public override string ToString()
		{
			return _measurement + " " +
				_LengthUnits1 + "*" + _LengthUnits2 + "*" + _LengthUnits3
				+ "/" +
				_TimeUnits4
				;
		}

		/// <summary>Base hashing function for VolumeRate measurements.</summary>
		/// <returns>Computed hash code for this instance.</returns>
		public override int GetHashCode() => Hash(_measurement);

		#endregion
	}

	#endregion


	#region MeasurementUnitsSyntaxTypes

	#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

	public static class MeasurementUnitsSyntaxTypes
	{
		public struct AccelerationBaseUnits : Measurement.IUnits<AccelerationBaseUnits>
		{
			public Length.Units _LengthUnits1;
			public Time.Units _TimeUnits2;
			public Time.Units _TimeUnits3;

			public AccelerationBaseUnits(Length.Units LengthUnits1, Time.Units TimeUnits2, Time.Units TimeUnits3)
			{
				_LengthUnits1 = LengthUnits1;
				_TimeUnits2 = TimeUnits2;
				_TimeUnits3 = TimeUnits3;
			}

			public T Convert<T>(T value,
				AccelerationBaseUnits from,
				AccelerationBaseUnits to)
			{
				return Acceleration<T>.Convert(value, from, to);
			}
		
		
			public static EnergyBaseUnits operator *(AccelerationBaseUnits a, LinearMassBaseUnits b)
			{
				return new EnergyBaseUnits(b._MassUnits1, a._LengthUnits1, b._LengthUnits2, a._TimeUnits2, a._TimeUnits3);
			}
		
			public static PowerBaseUnits operator *(AccelerationBaseUnits a, LinearMassFlowBaseUnits b)
			{
				return new PowerBaseUnits(b._MassUnits1, a._LengthUnits1, b._LengthUnits2, a._TimeUnits2, a._TimeUnits3, b._TimeUnits3);
			}
		
			public static ForceBaseUnits operator *(AccelerationBaseUnits a, MassUnits b)
			{
				return new ForceBaseUnits(b._MassUnits1, a._LengthUnits1, a._TimeUnits2, a._TimeUnits3);
			}
		
		
		}

		public struct AngularAccelerationBaseUnits : Measurement.IUnits<AngularAccelerationBaseUnits>
		{
			public Angle.Units _AngleUnits1;
			public Time.Units _TimeUnits2;
			public Time.Units _TimeUnits3;

			public AngularAccelerationBaseUnits(Angle.Units AngleUnits1, Time.Units TimeUnits2, Time.Units TimeUnits3)
			{
				_AngleUnits1 = AngleUnits1;
				_TimeUnits2 = TimeUnits2;
				_TimeUnits3 = TimeUnits3;
			}

			public T Convert<T>(T value,
				AngularAccelerationBaseUnits from,
				AngularAccelerationBaseUnits to)
			{
				return AngularAcceleration<T>.Convert(value, from, to);
			}
		
		
		}

		public struct AngleUnits : Measurement.IUnits<AngleUnits>
		{
			public Angle.Units _AngleUnits1;

			public AngleUnits(Angle.Units AngleUnits1)
			{
				_AngleUnits1 = AngleUnits1;
			}

			public T Convert<T>(T value,
				AngleUnits from,
				AngleUnits to)
			{
				return Angle<T>.Convert(value, from, to);
			}
		
		
		
			public static AngularSpeedBaseUnits operator /(AngleUnits a, TimeUnits b)
			{
				return new AngularSpeedBaseUnits(a._AngleUnits1, b._TimeUnits1);
			}
		
			public static AngularAccelerationBaseUnits operator /(AngleUnits a, TimeAreaBaseUnits b)
			{
				return new AngularAccelerationBaseUnits(a._AngleUnits1, b._TimeUnits1, b._TimeUnits2);
			}
		}

		public struct AngularSpeedBaseUnits : Measurement.IUnits<AngularSpeedBaseUnits>
		{
			public Angle.Units _AngleUnits1;
			public Time.Units _TimeUnits2;

			public AngularSpeedBaseUnits(Angle.Units AngleUnits1, Time.Units TimeUnits2)
			{
				_AngleUnits1 = AngleUnits1;
				_TimeUnits2 = TimeUnits2;
			}

			public T Convert<T>(T value,
				AngularSpeedBaseUnits from,
				AngularSpeedBaseUnits to)
			{
				return AngularSpeed<T>.Convert(value, from, to);
			}
		
		
		
			public static AngularAccelerationBaseUnits operator /(AngularSpeedBaseUnits a, TimeUnits b)
			{
				return new AngularAccelerationBaseUnits(a._AngleUnits1, a._TimeUnits2, b._TimeUnits1);
			}
		}

		public struct AreaBaseUnits : Measurement.IUnits<AreaBaseUnits>
		{
			public Length.Units _LengthUnits1;
			public Length.Units _LengthUnits2;

			public AreaBaseUnits(Length.Units LengthUnits1, Length.Units LengthUnits2)
			{
				_LengthUnits1 = LengthUnits1;
				_LengthUnits2 = LengthUnits2;
			}

			public T Convert<T>(T value,
				AreaBaseUnits from,
				AreaBaseUnits to)
			{
				return Area<T>.Convert(value, from, to);
			}
		
		
		
			public static VolumeBaseUnits operator *(AreaBaseUnits a, LengthUnits b)
			{
				return new VolumeBaseUnits(a._LengthUnits1, a._LengthUnits2, b._LengthUnits1);
			}
		
		
		
			public static VolumeRateBaseUnits operator *(AreaBaseUnits a, SpeedBaseUnits b)
			{
				return new VolumeRateBaseUnits(a._LengthUnits1, a._LengthUnits2, b._LengthUnits1, b._TimeUnits2);
			}
		
		}

		public struct AreaDensityBaseUnits : Measurement.IUnits<AreaDensityBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;

			public AreaDensityBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
			}

			public T Convert<T>(T value,
				AreaDensityBaseUnits from,
				AreaDensityBaseUnits to)
			{
				return AreaDensity<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		
			public static DensityBaseUnits operator /(AreaDensityBaseUnits a, LengthUnits b)
			{
				return new DensityBaseUnits(a._MassUnits1, a._LengthUnits2, a._LengthUnits3, b._LengthUnits1);
			}
		}

		public struct DensityBaseUnits : Measurement.IUnits<DensityBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;
			public Length.Units _LengthUnits4;

			public DensityBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Length.Units LengthUnits4)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
				_LengthUnits4 = LengthUnits4;
			}

			public T Convert<T>(T value,
				DensityBaseUnits from,
				DensityBaseUnits to)
			{
				return Density<T>.Convert(value, from, to);
			}
		
		
		
		
		}

		public struct ElectricChargeUnits : Measurement.IUnits<ElectricChargeUnits>
		{
			public ElectricCharge.Units _ElectricChargeUnits1;

			public ElectricChargeUnits(ElectricCharge.Units ElectricChargeUnits1)
			{
				_ElectricChargeUnits1 = ElectricChargeUnits1;
			}

			public T Convert<T>(T value,
				ElectricChargeUnits from,
				ElectricChargeUnits to)
			{
				return ElectricCharge<T>.Convert(value, from, to);
			}
		
		
			public static ElectricCurrentBaseUnits operator /(ElectricChargeUnits a, TimeUnits b)
			{
				return new ElectricCurrentBaseUnits(a._ElectricChargeUnits1, b._TimeUnits1);
			}
		}

		public struct ElectricCurrentBaseUnits : Measurement.IUnits<ElectricCurrentBaseUnits>
		{
			public ElectricCharge.Units _ElectricChargeUnits1;
			public Time.Units _TimeUnits2;

			public ElectricCurrentBaseUnits(ElectricCharge.Units ElectricChargeUnits1, Time.Units TimeUnits2)
			{
				_ElectricChargeUnits1 = ElectricChargeUnits1;
				_TimeUnits2 = TimeUnits2;
			}

			public T Convert<T>(T value,
				ElectricCurrentBaseUnits from,
				ElectricCurrentBaseUnits to)
			{
				return ElectricCurrent<T>.Convert(value, from, to);
			}
		
		}

		public struct EnergyBaseUnits : Measurement.IUnits<EnergyBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;
			public Time.Units _TimeUnits4;
			public Time.Units _TimeUnits5;

			public EnergyBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4, Time.Units TimeUnits5)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
				_TimeUnits4 = TimeUnits4;
				_TimeUnits5 = TimeUnits5;
			}

			public T Convert<T>(T value,
				EnergyBaseUnits from,
				EnergyBaseUnits to)
			{
				return Energy<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		
		
		
			public static PowerBaseUnits operator /(EnergyBaseUnits a, TimeUnits b)
			{
				return new PowerBaseUnits(a._MassUnits1, a._LengthUnits2, a._LengthUnits3, a._TimeUnits4, a._TimeUnits5, b._TimeUnits1);
			}
		
		}

		public struct ForceBaseUnits : Measurement.IUnits<ForceBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Time.Units _TimeUnits3;
			public Time.Units _TimeUnits4;

			public ForceBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3, Time.Units TimeUnits4)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_TimeUnits3 = TimeUnits3;
				_TimeUnits4 = TimeUnits4;
			}

			public T Convert<T>(T value,
				ForceBaseUnits from,
				ForceBaseUnits to)
			{
				return Force<T>.Convert(value, from, to);
			}
		
			public static EnergyBaseUnits operator *(ForceBaseUnits a, LengthUnits b)
			{
				return new EnergyBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, a._TimeUnits3, a._TimeUnits4);
			}
		
			public static PowerBaseUnits operator *(ForceBaseUnits a, SpeedBaseUnits b)
			{
				return new PowerBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, a._TimeUnits3, a._TimeUnits4, b._TimeUnits2);
			}
		
		
		
		
		
		
		
		
		}

		public struct LengthUnits : Measurement.IUnits<LengthUnits>
		{
			public Length.Units _LengthUnits1;

			public LengthUnits(Length.Units LengthUnits1)
			{
				_LengthUnits1 = LengthUnits1;
			}

			public T Convert<T>(T value,
				LengthUnits from,
				LengthUnits to)
			{
				return Length<T>.Convert(value, from, to);
			}
		
			public static VolumeBaseUnits operator *(LengthUnits a, AreaBaseUnits b)
			{
				return new VolumeBaseUnits(a._LengthUnits1, b._LengthUnits1, b._LengthUnits2);
			}
		
		
		
			public static EnergyBaseUnits operator *(LengthUnits a, ForceBaseUnits b)
			{
				return new EnergyBaseUnits(b._MassUnits1, a._LengthUnits1, b._LengthUnits2, b._TimeUnits3, b._TimeUnits4);
			}
		
			public static AreaBaseUnits operator *(LengthUnits a, LengthUnits b)
			{
				return new AreaBaseUnits(a._LengthUnits1, b._LengthUnits1);
			}
		
		
			public static LinearMassBaseUnits operator *(LengthUnits a, MassUnits b)
			{
				return new LinearMassBaseUnits(b._MassUnits1, a._LengthUnits1);
			}
		
			public static LinearMassFlowBaseUnits operator *(LengthUnits a, MassRateBaseUnits b)
			{
				return new LinearMassFlowBaseUnits(b._MassUnits1, a._LengthUnits1, b._TimeUnits2);
			}
		
		
		
			public static SpeedBaseUnits operator /(LengthUnits a, TimeUnits b)
			{
				return new SpeedBaseUnits(a._LengthUnits1, b._TimeUnits1);
			}
		
			public static AccelerationBaseUnits operator /(LengthUnits a, TimeAreaBaseUnits b)
			{
				return new AccelerationBaseUnits(a._LengthUnits1, b._TimeUnits1, b._TimeUnits2);
			}
		}

		public struct LinearDensityBaseUnits : Measurement.IUnits<LinearDensityBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;

			public LinearDensityBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
			}

			public T Convert<T>(T value,
				LinearDensityBaseUnits from,
				LinearDensityBaseUnits to)
			{
				return LinearDensity<T>.Convert(value, from, to);
			}
		
		
		
		
			public static DensityBaseUnits operator /(LinearDensityBaseUnits a, AreaBaseUnits b)
			{
				return new DensityBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, b._LengthUnits2);
			}
		
		
		
			public static AreaDensityBaseUnits operator /(LinearDensityBaseUnits a, LengthUnits b)
			{
				return new AreaDensityBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1);
			}
		
		
			public static PressureBaseUnits operator /(LinearDensityBaseUnits a, TimeAreaBaseUnits b)
			{
				return new PressureBaseUnits(a._MassUnits1, a._LengthUnits2, b._TimeUnits1, b._TimeUnits2);
			}
		}

		public struct LinearMassBaseUnits : Measurement.IUnits<LinearMassBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;

			public LinearMassBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
			}

			public T Convert<T>(T value,
				LinearMassBaseUnits from,
				LinearMassBaseUnits to)
			{
				return LinearMass<T>.Convert(value, from, to);
			}
		
			public static EnergyBaseUnits operator *(LinearMassBaseUnits a, AccelerationBaseUnits b)
			{
				return new EnergyBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, b._TimeUnits2, b._TimeUnits3);
			}
		
		
		
		
		
		
		
		
			public static LinearMassFlowBaseUnits operator /(LinearMassBaseUnits a, TimeUnits b)
			{
				return new LinearMassFlowBaseUnits(a._MassUnits1, a._LengthUnits2, b._TimeUnits1);
			}
		
			public static ForceBaseUnits operator /(LinearMassBaseUnits a, TimeAreaBaseUnits b)
			{
				return new ForceBaseUnits(a._MassUnits1, a._LengthUnits2, b._TimeUnits1, b._TimeUnits2);
			}
		
		}

		public struct LinearMassFlowBaseUnits : Measurement.IUnits<LinearMassFlowBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Time.Units _TimeUnits3;

			public LinearMassFlowBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_TimeUnits3 = TimeUnits3;
			}

			public T Convert<T>(T value,
				LinearMassFlowBaseUnits from,
				LinearMassFlowBaseUnits to)
			{
				return LinearMassFlow<T>.Convert(value, from, to);
			}
		
			public static PowerBaseUnits operator *(LinearMassFlowBaseUnits a, AccelerationBaseUnits b)
			{
				return new PowerBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, a._TimeUnits3, b._TimeUnits2, b._TimeUnits3);
			}
		
			public static EnergyBaseUnits operator *(LinearMassFlowBaseUnits a, SpeedBaseUnits b)
			{
				return new EnergyBaseUnits(a._MassUnits1, a._LengthUnits2, b._LengthUnits1, a._TimeUnits3, b._TimeUnits2);
			}
		
		
		
		
		
		
		
		
			public static ForceBaseUnits operator /(LinearMassFlowBaseUnits a, TimeUnits b)
			{
				return new ForceBaseUnits(a._MassUnits1, a._LengthUnits2, a._TimeUnits3, b._TimeUnits1);
			}
		
		}

		public struct MassUnits : Measurement.IUnits<MassUnits>
		{
			public Mass.Units _MassUnits1;

			public MassUnits(Mass.Units MassUnits1)
			{
				_MassUnits1 = MassUnits1;
			}

			public T Convert<T>(T value,
				MassUnits from,
				MassUnits to)
			{
				return Mass<T>.Convert(value, from, to);
			}
		
			public static ForceBaseUnits operator *(MassUnits a, AccelerationBaseUnits b)
			{
				return new ForceBaseUnits(a._MassUnits1, b._LengthUnits1, b._TimeUnits2, b._TimeUnits3);
			}
		
			public static LinearMassBaseUnits operator *(MassUnits a, LengthUnits b)
			{
				return new LinearMassBaseUnits(a._MassUnits1, b._LengthUnits1);
			}
		
			public static LinearMassFlowBaseUnits operator *(MassUnits a, SpeedBaseUnits b)
			{
				return new LinearMassFlowBaseUnits(a._MassUnits1, b._LengthUnits1, b._TimeUnits2);
			}
		
			public static AreaDensityBaseUnits operator /(MassUnits a, AreaBaseUnits b)
			{
				return new AreaDensityBaseUnits(a._MassUnits1, b._LengthUnits1, b._LengthUnits2);
			}
		
		
		
			public static LinearDensityBaseUnits operator /(MassUnits a, LengthUnits b)
			{
				return new LinearDensityBaseUnits(a._MassUnits1, b._LengthUnits1);
			}
		
		
		
			public static MassRateBaseUnits operator /(MassUnits a, TimeUnits b)
			{
				return new MassRateBaseUnits(a._MassUnits1, b._TimeUnits1);
			}
		
			public static DensityBaseUnits operator /(MassUnits a, VolumeBaseUnits b)
			{
				return new DensityBaseUnits(a._MassUnits1, b._LengthUnits1, b._LengthUnits2, b._LengthUnits3);
			}
		}

		public struct MassRateBaseUnits : Measurement.IUnits<MassRateBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Time.Units _TimeUnits2;

			public MassRateBaseUnits(Mass.Units MassUnits1, Time.Units TimeUnits2)
			{
				_MassUnits1 = MassUnits1;
				_TimeUnits2 = TimeUnits2;
			}

			public T Convert<T>(T value,
				MassRateBaseUnits from,
				MassRateBaseUnits to)
			{
				return MassRate<T>.Convert(value, from, to);
			}
		
			public static LinearMassFlowBaseUnits operator *(MassRateBaseUnits a, LengthUnits b)
			{
				return new LinearMassFlowBaseUnits(a._MassUnits1, b._LengthUnits1, a._TimeUnits2);
			}
		
			public static ForceBaseUnits operator *(MassRateBaseUnits a, SpeedBaseUnits b)
			{
				return new ForceBaseUnits(a._MassUnits1, b._LengthUnits1, a._TimeUnits2, b._TimeUnits2);
			}
		
		
		
		
		
		}

		public struct PowerBaseUnits : Measurement.IUnits<PowerBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;
			public Time.Units _TimeUnits4;
			public Time.Units _TimeUnits5;
			public Time.Units _TimeUnits6;

			public PowerBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4, Time.Units TimeUnits5, Time.Units TimeUnits6)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
				_TimeUnits4 = TimeUnits4;
				_TimeUnits5 = TimeUnits5;
				_TimeUnits6 = TimeUnits6;
			}

			public T Convert<T>(T value,
				PowerBaseUnits from,
				PowerBaseUnits to)
			{
				return Power<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		
		}

		public struct PressureBaseUnits : Measurement.IUnits<PressureBaseUnits>
		{
			public Mass.Units _MassUnits1;
			public Length.Units _LengthUnits2;
			public Time.Units _TimeUnits3;
			public Time.Units _TimeUnits4;

			public PressureBaseUnits(Mass.Units MassUnits1, Length.Units LengthUnits2, Time.Units TimeUnits3, Time.Units TimeUnits4)
			{
				_MassUnits1 = MassUnits1;
				_LengthUnits2 = LengthUnits2;
				_TimeUnits3 = TimeUnits3;
				_TimeUnits4 = TimeUnits4;
			}

			public T Convert<T>(T value,
				PressureBaseUnits from,
				PressureBaseUnits to)
			{
				return Pressure<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		}

		public struct SpeedBaseUnits : Measurement.IUnits<SpeedBaseUnits>
		{
			public Length.Units _LengthUnits1;
			public Time.Units _TimeUnits2;

			public SpeedBaseUnits(Length.Units LengthUnits1, Time.Units TimeUnits2)
			{
				_LengthUnits1 = LengthUnits1;
				_TimeUnits2 = TimeUnits2;
			}

			public T Convert<T>(T value,
				SpeedBaseUnits from,
				SpeedBaseUnits to)
			{
				return Speed<T>.Convert(value, from, to);
			}
		
			public static VolumeRateBaseUnits operator *(SpeedBaseUnits a, AreaBaseUnits b)
			{
				return new VolumeRateBaseUnits(a._LengthUnits1, b._LengthUnits1, b._LengthUnits2, a._TimeUnits2);
			}
		
			public static PowerBaseUnits operator *(SpeedBaseUnits a, ForceBaseUnits b)
			{
				return new PowerBaseUnits(b._MassUnits1, a._LengthUnits1, b._LengthUnits2, a._TimeUnits2, b._TimeUnits3, b._TimeUnits4);
			}
		
		
			public static EnergyBaseUnits operator *(SpeedBaseUnits a, LinearMassFlowBaseUnits b)
			{
				return new EnergyBaseUnits(b._MassUnits1, a._LengthUnits1, b._LengthUnits2, a._TimeUnits2, b._TimeUnits3);
			}
		
			public static LinearMassFlowBaseUnits operator *(SpeedBaseUnits a, MassUnits b)
			{
				return new LinearMassFlowBaseUnits(b._MassUnits1, a._LengthUnits1, a._TimeUnits2);
			}
		
			public static ForceBaseUnits operator *(SpeedBaseUnits a, MassRateBaseUnits b)
			{
				return new ForceBaseUnits(b._MassUnits1, a._LengthUnits1, a._TimeUnits2, b._TimeUnits2);
			}
		
		
		
			public static AccelerationBaseUnits operator /(SpeedBaseUnits a, TimeUnits b)
			{
				return new AccelerationBaseUnits(a._LengthUnits1, a._TimeUnits2, b._TimeUnits1);
			}
		}

		public struct TempuratureUnits : Measurement.IUnits<TempuratureUnits>
		{
			public Tempurature.Units _TempuratureUnits1;

			public TempuratureUnits(Tempurature.Units TempuratureUnits1)
			{
				_TempuratureUnits1 = TempuratureUnits1;
			}

			public T Convert<T>(T value,
				TempuratureUnits from,
				TempuratureUnits to)
			{
				return Tempurature<T>.Convert(value, from, to);
			}
		}

		public struct TimeUnits : Measurement.IUnits<TimeUnits>
		{
			public Time.Units _TimeUnits1;

			public TimeUnits(Time.Units TimeUnits1)
			{
				_TimeUnits1 = TimeUnits1;
			}

			public T Convert<T>(T value,
				TimeUnits from,
				TimeUnits to)
			{
				return Time<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		
		
		
		
			public static TimeAreaBaseUnits operator *(TimeUnits a, TimeUnits b)
			{
				return new TimeAreaBaseUnits(a._TimeUnits1, b._TimeUnits1);
			}
		
		}

		public struct TimeAreaBaseUnits : Measurement.IUnits<TimeAreaBaseUnits>
		{
			public Time.Units _TimeUnits1;
			public Time.Units _TimeUnits2;

			public TimeAreaBaseUnits(Time.Units TimeUnits1, Time.Units TimeUnits2)
			{
				_TimeUnits1 = TimeUnits1;
				_TimeUnits2 = TimeUnits2;
			}

			public T Convert<T>(T value,
				TimeAreaBaseUnits from,
				TimeAreaBaseUnits to)
			{
				return TimeArea<T>.Convert(value, from, to);
			}
		
		
		
		
		
		}

		public struct VolumeBaseUnits : Measurement.IUnits<VolumeBaseUnits>
		{
			public Length.Units _LengthUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;

			public VolumeBaseUnits(Length.Units LengthUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3)
			{
				_LengthUnits1 = LengthUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
			}

			public T Convert<T>(T value,
				VolumeBaseUnits from,
				VolumeBaseUnits to)
			{
				return Volume<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
			public static VolumeRateBaseUnits operator /(VolumeBaseUnits a, TimeUnits b)
			{
				return new VolumeRateBaseUnits(a._LengthUnits1, a._LengthUnits2, a._LengthUnits3, b._TimeUnits1);
			}
		
		}

		public struct VolumeRateBaseUnits : Measurement.IUnits<VolumeRateBaseUnits>
		{
			public Length.Units _LengthUnits1;
			public Length.Units _LengthUnits2;
			public Length.Units _LengthUnits3;
			public Time.Units _TimeUnits4;

			public VolumeRateBaseUnits(Length.Units LengthUnits1, Length.Units LengthUnits2, Length.Units LengthUnits3, Time.Units TimeUnits4)
			{
				_LengthUnits1 = LengthUnits1;
				_LengthUnits2 = LengthUnits2;
				_LengthUnits3 = LengthUnits3;
				_TimeUnits4 = TimeUnits4;
			}

			public T Convert<T>(T value,
				VolumeRateBaseUnits from,
				VolumeRateBaseUnits to)
			{
				return VolumeRate<T>.Convert(value, from, to);
			}
		
		
		
		
		
		
		}

	}

	#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

	#endregion
}